/*! shifty - v1.4.2 - 2015-04-24 - http://jeremyckahn.github.io/shifty */
(function(){var t=this,n=function(){"use strict";function n(){}function e(t,n){var e;for(e in t)Object.hasOwnProperty.call(t,e)&&n(e)}function i(t,n){return e(n,function(e){t[e]=n[e]}),t}function r(t,n){e(n,function(e){t[e]===void 0&&(t[e]=n[e])})}function o(t,n,e,i,r,o,u){var s,c=o>t?0:(t-o)/r;for(s in n)n.hasOwnProperty(s)&&(n[s]=a(e[s],i[s],f[u[s]],c));return n}function a(t,n,e,i){return t+(n-t)*e(i)}function u(t,n){var i=h.prototype.filter,r=t._filterArgs;e(i,function(e){i[e][n]!==void 0&&i[e][n].apply(t,r)})}function s(t,n,e,i,r,a,s,c,h,f,p){g=n+e+i,y=Math.min(p||d(),g),v=y>=g,M=i-(g-y),t.isPlaying()&&!v?(t._scheduleId=f(t._timeoutHandler,m),u(t,"beforeTween"),n+e>y?o(1,r,a,s,1,1,c):o(y,r,a,s,i,n+e,c),u(t,"afterTween"),h(r,t._attachment,M)):t.isPlaying()&&v&&(h(s,t._attachment,M),t.stop(!0))}function c(t,n){var i={};return"string"==typeof n?e(t,function(t){i[t]=n}):e(t,function(t){i[t]||(i[t]=n[t]||l)}),i}function h(t,n){this._currentState=t||{},this._configured=!1,this._scheduleFunction=p,n!==void 0&&this.setConfig(n)}var f,p,l="linear",_=500,m=1e3/60,w=Date.now?Date.now:function(){return+new Date},d="undefined"!=typeof SHIFTY_DEBUG_NOW?SHIFTY_DEBUG_NOW:w;p="undefined"!=typeof window?window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||window.mozCancelRequestAnimationFrame&&window.mozRequestAnimationFrame||setTimeout:setTimeout;var g,y,v,M;return h.prototype.tween=function(t){return this._isTweening?this:(void 0===t&&this._configured||this.setConfig(t),this._timestamp=d(),this._start(this.get(),this._attachment),this.resume())},h.prototype.setConfig=function(t){t=t||{},this._configured=!0,this._attachment=t.attachment,this._pausedAtTime=null,this._scheduleId=null,this._delay=t.delay||0,this._start=t.start||n,this._step=t.step||n,this._finish=t.finish||n,this._duration=t.duration||_,this._currentState=i({},t.from)||this.get(),this._originalState=this.get(),this._targetState=i({},t.to)||this.get();var e=this;this._timeoutHandler=function(){s(e,e._timestamp,e._delay,e._duration,e._currentState,e._originalState,e._targetState,e._easing,e._step,e._scheduleFunction)};var o=this._currentState,a=this._targetState;return r(a,o),this._easing=c(o,t.easing||l),this._filterArgs=[o,this._originalState,a,this._easing],u(this,"tweenCreated"),this},h.prototype.get=function(){return i({},this._currentState)},h.prototype.set=function(t){this._currentState=t},h.prototype.pause=function(){return this._pausedAtTime=d(),this._isPaused=!0,this},h.prototype.resume=function(){return this._isPaused&&(this._timestamp+=d()-this._pausedAtTime),this._isPaused=!1,this._isTweening=!0,this._timeoutHandler(),this},h.prototype.seek=function(t){t=Math.max(t,0);var n=d();return 0===this._timestamp+t?this:(this._timestamp=n-t,this.isPlaying()||(this._isTweening=!0,this._isPaused=!1,s(this,this._timestamp,this._delay,this._duration,this._currentState,this._originalState,this._targetState,this._easing,this._step,this._scheduleFunction,n),this.pause()),this)},h.prototype.stop=function(e){return this._isTweening=!1,this._isPaused=!1,this._timeoutHandler=n,(t.cancelAnimationFrame||t.webkitCancelAnimationFrame||t.oCancelAnimationFrame||t.msCancelAnimationFrame||t.mozCancelRequestAnimationFrame||t.clearTimeout)(this._scheduleId),e&&(i(this._currentState,this._targetState),u(this,"afterTweenEnd"),this._finish.call(this,this._currentState,this._attachment)),this},h.prototype.isPlaying=function(){return this._isTweening&&!this._isPaused},h.prototype.setScheduleFunction=function(t){this._scheduleFunction=t},h.prototype.dispose=function(){var t;for(t in this)this.hasOwnProperty(t)&&delete this[t]},h.prototype.filter={},h.prototype.formula={linear:function(t){return t}},f=h.prototype.formula,i(h,{now:d,each:e,tweenProps:o,tweenProp:a,applyFilter:u,shallowCopy:i,defaults:r,composeEasingObject:c}),"function"==typeof SHIFTY_DEBUG_NOW&&(t.timeoutHandler=s),"object"==typeof exports?module.exports=h:"function"==typeof define&&define.amd?define(function(){return h}):t.Tweenable===void 0&&(t.Tweenable=h),h}();(function(){n.shallowCopy(n.prototype.formula,{easeInQuad:function(t){return Math.pow(t,2)},easeOutQuad:function(t){return-(Math.pow(t-1,2)-1)},easeInOutQuad:function(t){return 1>(t/=.5)?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},easeInCubic:function(t){return Math.pow(t,3)},easeOutCubic:function(t){return Math.pow(t-1,3)+1},easeInOutCubic:function(t){return 1>(t/=.5)?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},easeInQuart:function(t){return Math.pow(t,4)},easeOutQuart:function(t){return-(Math.pow(t-1,4)-1)},easeInOutQuart:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeInQuint:function(t){return Math.pow(t,5)},easeOutQuint:function(t){return Math.pow(t-1,5)+1},easeInOutQuint:function(t){return 1>(t/=.5)?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},easeInSine:function(t){return-Math.cos(t*(Math.PI/2))+1},easeOutSine:function(t){return Math.sin(t*(Math.PI/2))},easeInOutSine:function(t){return-.5*(Math.cos(Math.PI*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:-Math.pow(2,-10*t)+1},easeInOutExpo:function(t){return 0===t?0:1===t?1:1>(t/=.5)?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-Math.pow(t-1,2))},easeInOutCirc:function(t){return 1>(t/=.5)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeOutBounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},easeInBack:function(t){var n=1.70158;return t*t*((n+1)*t-n)},easeOutBack:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},easeInOutBack:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},elastic:function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*2*Math.PI/2)+1},swingFromTo:function(t){var n=1.70158;return 1>(t/=.5)?.5*t*t*(((n*=1.525)+1)*t-n):.5*((t-=2)*t*(((n*=1.525)+1)*t+n)+2)},swingFrom:function(t){var n=1.70158;return t*t*((n+1)*t-n)},swingTo:function(t){var n=1.70158;return(t-=1)*t*((n+1)*t+n)+1},bounce:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},bouncePast:function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?2-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},easeFromTo:function(t){return 1>(t/=.5)?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeFrom:function(t){return Math.pow(t,4)},easeTo:function(t){return Math.pow(t,.25)}})})(),function(){function t(t,n,e,i,r,o){function a(t){return((l*t+_)*t+m)*t}function u(t){return((w*t+d)*t+g)*t}function s(t){return(3*l*t+2*_)*t+m}function c(t){return 1/(200*t)}function h(t,n){return u(p(t,n))}function f(t){return t>=0?t:0-t}function p(t,n){var e,i,r,o,u,c;for(r=t,c=0;8>c;c++){if(o=a(r)-t,n>f(o))return r;if(u=s(r),1e-6>f(u))break;r-=o/u}if(e=0,i=1,r=t,e>r)return e;if(r>i)return i;for(;i>e;){if(o=a(r),n>f(o-t))return r;t>o?e=r:i=r,r=.5*(i-e)+e}return r}var l=0,_=0,m=0,w=0,d=0,g=0;return m=3*n,_=3*(i-n)-m,l=1-m-_,g=3*e,d=3*(r-e)-g,w=1-g-d,h(t,c(o))}function e(n,e,i,r){return function(o){return t(o,n,e,i,r,1)}}n.setBezierFunction=function(t,i,r,o,a){var u=e(i,r,o,a);return u.displayName=t,u.x1=i,u.y1=r,u.x2=o,u.y2=a,n.prototype.formula[t]=u},n.unsetBezierFunction=function(t){delete n.prototype.formula[t]}}(),function(){function t(t,e,i,r,o,a){return n.tweenProps(r,e,t,i,1,a,o)}var e=new n;e._filterArgs=[],n.interpolate=function(i,r,o,a,u){var s=n.shallowCopy({},i),c=u||0,h=n.composeEasingObject(i,a||"linear");e.set({});var f=e._filterArgs;f.length=0,f[0]=s,f[1]=i,f[2]=r,f[3]=h,n.applyFilter(e,"tweenCreated"),n.applyFilter(e,"beforeTween");var p=t(i,s,r,o,h,c);return n.applyFilter(e,"afterTween"),p}}(),function(t){function n(t,n){var e,i=[],r=t.length;for(e=0;r>e;e++)i.push("_"+n+"_"+e);return i}function e(t){var n=t.match(M);return n?(1===n.length||t[0].match(v))&&n.unshift(""):n=["",""],n.join(O)}function i(n){t.each(n,function(t){var e=n[t];"string"==typeof e&&e.match(T)&&(n[t]=r(e))})}function r(t){return s(T,t,o)}function o(t){var n=a(t);return"rgb("+n[0]+","+n[1]+","+n[2]+")"}function a(t){return t=t.replace(/#/,""),3===t.length&&(t=t.split(""),t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),b[0]=u(t.substr(0,2)),b[1]=u(t.substr(2,2)),b[2]=u(t.substr(4,2)),b}function u(t){return parseInt(t,16)}function s(t,n,e){var i=n.match(t),r=n.replace(t,O);if(i)for(var o,a=i.length,u=0;a>u;u++)o=i.shift(),r=r.replace(O,e(o));return r}function c(t){return s(I,t,h)}function h(t){for(var n=t.match(F),e=n.length,i=t.match(S)[0],r=0;e>r;r++)i+=parseInt(n[r],10)+",";return i=i.slice(0,-1)+")"}function f(i){var r={};return t.each(i,function(t){var o=i[t];if("string"==typeof o){var a=d(o);r[t]={formatString:e(o),chunkNames:n(a,t)}}}),r}function p(n,e){t.each(e,function(t){for(var i=n[t],r=d(i),o=r.length,a=0;o>a;a++)n[e[t].chunkNames[a]]=+r[a];delete n[t]})}function l(n,e){t.each(e,function(t){var i=n[t],r=_(n,e[t].chunkNames),o=m(r,e[t].chunkNames);i=w(e[t].formatString,o),n[t]=c(i)})}function _(t,n){for(var e,i={},r=n.length,o=0;r>o;o++)e=n[o],i[e]=t[e],delete t[e];return i}function m(t,n){k.length=0;for(var e=n.length,i=0;e>i;i++)k.push(t[n[i]]);return k}function w(t,n){for(var e=t,i=n.length,r=0;i>r;r++)e=e.replace(O,+n[r].toFixed(4));return e}function d(t){return t.match(F)}function g(n,e){t.each(e,function(t){for(var i=e[t],r=i.chunkNames,o=r.length,a=n[t].split(" "),u=a[a.length-1],s=0;o>s;s++)n[r[s]]=a[s]||u;delete n[t]})}function y(n,e){t.each(e,function(t){for(var i=e[t],r=i.chunkNames,o=r.length,a="",u=0;o>u;u++)a+=" "+n[r[u]],delete n[r[u]];n[t]=a.substr(1)})}var v=/(\d|\-|\.)/,M=/([^\-0-9\.]+)/g,F=/[0-9.\-]+/g,I=RegExp("rgb\\("+F.source+/,\s*/.source+F.source+/,\s*/.source+F.source+"\\)","g"),S=/^.*\(/,T=/#([0-9]|[a-f]){3,6}/gi,O="VAL",b=[],k=[];t.prototype.filter.token={tweenCreated:function(t,n,e){i(t),i(n),i(e),this._tokenData=f(t)},beforeTween:function(t,n,e,i){g(i,this._tokenData),p(t,this._tokenData),p(n,this._tokenData),p(e,this._tokenData)},afterTween:function(t,n,e,i){l(t,this._tokenData),l(n,this._tokenData),l(e,this._tokenData),y(i,this._tokenData)}}}(n)}).call(null);
;
// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.0 - JavaScript Vector Library                          │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

// ┌──────────────────────────────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.3.4 - JavaScript Events Library                                                │ \\
// ├──────────────────────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)          │ \\
// │ Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license. │ \\
// └──────────────────────────────────────────────────────────────────────────────────────┘ \\

// THIS FILES IS PATCHED BY FREEGROUP
// you can't replace this file with a new version without migrate all changes
// tagged with "FREEGROUP"
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.4.2 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\
(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("eve", function() {
            return factory();
        });
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        glob.eve = factory();
    }
}(this, function(){
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
     \*/
        eve = function (name, scope) {
            name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
     \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
     \*/
    eve.on = function (name, f) {
        name = String(name);
        if (typeof f != "function") {
            return function () {};
        }
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
     \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
     \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
     \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
     \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
     \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
     \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
     \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };

    return eve;
}));

// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                      │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Core Module                                                        │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.core", ["eve"], function(eve) {
            return factory(eve);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("eve"));
    } else {
        glob.Raphael = factory(glob.eve);
    }
}(this, function (eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport’s 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
     \*/
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.1.4";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
             \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute “hue” will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
             \*/
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            "stroke-scale": false, // FreeGroup: draw2d enhancement
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () {},
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set : function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
    /*\
     * Raphael.mapPath
     [ method ]
     **
     * Transform the path string with given matrix.
     > Parameters
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
     \*/
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be “SVG”, “VML” or empty, depending on browser support.
     \*/
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
     \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
     \*/
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphaël instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {…},
     |     star: function () {…},
     |     // etc…
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
     \*/
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    R._oid = 0;
    /*\
     * Raphael.is
     [ method ]
     **
     * Handful of replacements for `typeof` operator.
     > Parameters
     - o (…) any object or primitive
     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
     = (boolean) is given value is of given type
     \*/
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return  (type == "null" && o === null) ||
            (type == typeof o && o !== null) ||
            (type == "object" && o === Object(o)) ||
            (type == "array" && Array.isArray && Array.isArray(o)) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
     \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
     \*/
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - rad (number) angle in radians
     = (number) angle in degrees.
     \*/
    R.deg = function (rad) {
        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;
    };
    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
     \*/
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
     \*/
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
     \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
            if (R.vml) {
                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                var trim = /^\s+|\s+$/g;
                var bod;
                try {
                    var docum = new ActiveXObject("htmlfile");
                    docum.write("<body>");
                    docum.close();
                    bod = docum.body;
                } catch(e) {
                    bod = createPopup().document.body;
                }
                var range = bod.createTextRange();
                toHex = cacher(function (color) {
                    try {
                        bod.style.color = Str(color).replace(trim, E);
                        var value = range.queryCommandValue("ForeColor");
                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                        return "#" + ("000000" + value.toString(16)).slice(-6);
                    } catch(e) {
                        return "none";
                    }
                });
            } else {
                var i = g.doc.createElement("i");
                i.title = "Rapha\xebl Colour Picker";
                i.style.display = "none";
                g.doc.body.appendChild(i);
                toHex = cacher(function (color) {
                    i.style.color = color;
                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                });
            }
            return toHex(color);
        },
        hsbtoString = function () {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function () {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function () {
            return this.hex;
        },
        prepareRGB = function (r, g, b) {
            if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && R.is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function (r, g, b, o) {
            r *= 255;
            g *= 255;
            b *= 255;
            var rgb = {
                r: r,
                g: g,
                b: b,
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            R.is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) `true` if string can’t be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
     \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
     \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #••••••
     o }
     \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
     \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
                V == r ? (g - b) / C :
                    V == g ? (b - r) / C + 2 :
                    (r - g) / C + 4
        );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
     \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
            M == r ? (g - b) / C :
                M == g ? (b - r) / C + 2 :
                (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
            L < .5 ? C / (2 * L) :
            C / (2 - 2 * L));
        return {h: H, s: S, l: L, toString: hsltoString};
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsl(•••, •••, •••) — same as hsb</li>
     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #••••••,
     o     error (boolean) true if string can’t be parsed
     o }
     \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
    }, R);
    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
     \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
     \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
     \*/
    R.rgb = cacher(function (r, g, b) {
        function round(x) { return (x + 0.5) | 0; }
        return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
    });
    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
     \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
     \*/
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                {x: +crp[i - 2], y: +crp[i - 1]},
                {x: +crp[i],     y: +crp[i + 1]},
                {x: +crp[i + 2], y: +crp[i + 3]},
                {x: +crp[i + 4], y: +crp[i + 5]}
            ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6*p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }

        return d;
    }
    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
     \*/
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
     \*/
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {r: 3, s: 4, t: 2, m: 6},
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
     \*/
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
     \*/
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
     \*/
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
     \*/
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
     \*/
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
     \*/
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
            interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
     \*/
    var pathDimensions = R.pathBBox = function (path) {
            var pth = paths(path);
            if (pth.bbox) {
                var b= pth.bbox;
                return {x: b.x, y: b.y, width: b.width, height: b.height, x2: b.x2, y2: b.y2} ; // FREEGROUP FIX!!!!!!
                // raphael reuse the returned bbox. You must clone it here if the caller need the bbxo for
                //further calculation
            }
            if (!path) {
                return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
            }
            path = path2curve(path);
            var x = 0,
                y = 0,
                X = [],
                Y = [],
                p;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = p[1];
                    y = p[2];
                    X.push(x);
                    Y.push(y);
                } else {
                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    X = X[concat](dim.min.x, dim.max.x);
                    Y = Y[concat](dim.min.y, dim.max.y);
                    x = p[5];
                    y = p[6];
                }
            }
            var xmin = mmin[apply](0, X),
                ymin = mmin[apply](0, Y),
                xmax = mmax[apply](0, X),
                ymax = mmax[apply](0, Y),
                width = xmax - xmin,
                height = ymax - ymin,
                bb = {
                    x: xmin,
                    y: ymin,
                    x2: xmax,
                    y2: ymax,
                    width: width,
                    height: height,
                    cx: xmin + width / 2,
                    cy: ymin + height / 2
                };
            pth.bbox = clone(bb);
            return bb;
        },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d, pcom) {
                    var nx, ny, tq = {T:1, Q:1};
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in tq) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case "S".
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                            p2 && (pcoms2[i]="A"); // the same as above
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                pcoms1 = [], // path commands of original path p
                pcoms2 = [], // path commands of original path p2
                pfirst = "", // temporary holder for original path command
                pcom = ""; // holder for previous path command of original path
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                {
                    pcoms1[i] = pfirst; // Save current path command
                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) { // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);
                    if (pfirst != "C")
                    {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i-1]);
                    }
                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                    fixArc(p2, i);
                }
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.opacity = dot.color.opacity;
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
    /*\
     * Raphael.toMatrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix of transformations applied to a given path
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (object) @Matrix
     \*/
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
    /*\
     * Raphael.transformPath
     [ method ]
     **
     * Utility method
     **
     * Returns path transformed by a given transformation
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (string) path
     \*/
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
             \*/
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
     \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};
    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
     \*/
    R.path2curve = path2curve;
    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
     \*/
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
         \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
         \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
         \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
         \*/
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
         \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
         \*/
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
         \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
         \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
         \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
         \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                    (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                    (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    var preventDefault = function () {
            this.returnValue = false;
        },
        preventTouch = function () {
            return this.originalEvent.preventDefault();
        },
        stopPropagation = function () {
            this.cancelBubble = true;
        },
        stopTouch = function () {
            return this.originalEvent.stopPropagation();
        },
        getEventPosition = function (e) {
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

            return {
                x: e.clientX + scrollX,
                y: e.clientY + scrollY
            };
        },
        addEvent = (function () {
            if (g.doc.addEventListener) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        var pos = getEventPosition(e);
                        return fn.call(element, e, pos.x, pos.y);
                    };
                    obj.addEventListener(type, f, false);

                    if (supportsTouch && touchMap[type]) {
                        var _f = function (e) {
                            var pos = getEventPosition(e),
                                olde = e;

                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                                if (e.targetTouches[i].target == obj) {
                                    e = e.targetTouches[i];
                                    e.originalEvent = olde;
                                    e.preventDefault = preventTouch;
                                    e.stopPropagation = stopTouch;
                                    break;
                                }
                            }

                            return fn.call(element, e, pos.x, pos.y);
                        };
                        obj.addEventListener(touchMap[type], _f, false);
                    }

                    return function () {
                        obj.removeEventListener(type, f, false);

                        if (supportsTouch && touchMap[type])
                            obj.removeEventListener(touchMap[type], _f, false);

                        return true;
                    };
                };
            } else if (g.doc.attachEvent) {
                return function (obj, type, fn, element) {
                    var f = function (e) {
                        e = e || g.win.event;
                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                            x = e.clientX + scrollX,
                            y = e.clientY + scrollY;
                        e.preventDefault = e.preventDefault || preventDefault;
                        e.stopPropagation = e.stopPropagation || stopPropagation;
                        return fn.call(element, e, x, y);
                    };
                    obj.attachEvent("on" + type, f);
                    var detacher = function () {
                        obj.detachEvent("on" + type, f);
                        return true;
                    };
                    return detacher;
                };
            }
        })(),
        drag = [],
        dragMove = function (e) {
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                dragi,
                j = drag.length;
            while (j--) {
                dragi = drag[j];
                if (supportsTouch && e.touches) {
                    var i = e.touches.length,
                        touch;
                    while (i--) {
                        touch = e.touches[i];
                        if (touch.identifier == dragi.el._drag.id) {
                            x = touch.clientX;
                            y = touch.clientY;
                            (e.originalEvent ? e.originalEvent : e).preventDefault();
                            break;
                        }
                    }
                } else {
                    e.preventDefault();
                }
                var node = dragi.el.node,
                    o,
                    next = node.nextSibling,
                    parent = node.parentNode,
                    display = node.style.display;
                g.win.opera && parent.removeChild(node);
                node.style.display = "none";
                o = dragi.el.paper.getElementByPoint(x, y);
                node.style.display = display;
                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
                x += scrollX;
                y += scrollY;
                eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        },
        dragUp = function (e) {
            R.unmousemove(dragMove).unmouseup(dragUp);
            var i = drag.length,
                dragi;
            while (i--) {
                dragi = drag[i];
                dragi.el._drag = {};
                eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            }
            drag = [];
        },
    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
     \*/
        elproto = R.el = {};
    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
     \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
     \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--){
                    if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                    }
                }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
     \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            return data;
        }
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
     \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
     \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };
    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
     \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
     \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
     \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                var i = e.touches.length, touch;
                while (i--) {
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
     \*/
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
     \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphaël element object with type “circle”
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
     \*/
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphaël element object with type “rect”
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
     \*/
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphaël element object with type “ellipse”
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
     \*/
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
     \*/
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphaël element object with type “image”
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
     \*/
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put “\n” in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphaël element object with type “text”
     **
     > Usage
     | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
     \*/
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements — all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
     \*/
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out["paper"] = this;
        out["type"] = "set";
        return out;
    };
    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
     \*/
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
     \*/
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    /*\
     * Paper.getSize
     [ method ]
     **
     * Obtains current paper actual size.
     **
     = (object)
     \*/
    paperproto.getSize = function () {
        var container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    };
    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
     \*/
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
     \*/
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
     \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
     \*/
    paperproto.top = paperproto.bottom = null;
    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
     \*/
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphaël element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
     \*/
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
    paperproto.getElementsByBBox = function (bbox) {
        var set = this.set();
        this.forEach(function (el) {
            if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        return set;
    };

    /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphaël element object
     \*/
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
     \*/
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
     \*/
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element’s shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
     \*/
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
     \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
     \*/
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
     \*/
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
                width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
                fill: glow.fill || false,
                opacity: glow.opacity == null ? .5 : glow.opacity,
                offsetx: glow.offsetx || 0,
                offsety: glow.offsety || 0,
                color: glow.color || "#000"
            },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
        getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
            if (length == null) {
                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            } else {
                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
            }
        },
        getLengthFactory = function (istotal, subpath) {
            return function (path, length, onlystart) {
                path = path2curve(path);
                var x, y, p, l, sp = "", subpaths = {}, point,
                    len = 0;
                for (var i = 0, ii = path.length; i < ii; i++) {
                    p = path[i];
                    if (p[0] == "M") {
                        x = +p[1];
                        y = +p[2];
                    } else {
                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                        if (len + l > length) {
                            if (subpath && !subpaths.start) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                                if (onlystart) {return sp;}
                                subpaths.start = sp;
                                sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                                len += l;
                                x = +p[5];
                                y = +p[6];
                                continue;
                            }
                            if (!istotal && !subpath) {
                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                                return {x: point.x, y: point.y, alpha: point.alpha};
                            }
                        }
                        len += l;
                        x = +p[5];
                        y = +p[6];
                    }
                    sp += p.shift() + p;
                }
                subpaths.end = sp;
                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
                point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
                return point;
            };
        };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
     \*/
    R.getTotalLength = getTotalLength;
    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
     \*/
    R.getPointAtLength = getPointAtLength;
    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
     \*/
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of “path” type.
     = (number) length.
     \*/
    elproto.getTotalLength = function () {
        var path = this.getPath();
        if (!path) {
            return;
        }

        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }

        return getTotalLength(path);
    };
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
     \*/
    elproto.getPointAtLength = function (length) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return getPointAtLength(path, length);
    };
    /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
     = (object) path
     **
     \*/
    elproto.getPath = function () {
        var path,
            getPath = R._getPath[this.type];

        if (this.type == "text" || this.type == "set") {
            return;
        }

        if (getPath) {
            path = getPath(this);
        }

        return path;
    };
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of “path” type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
     \*/
    elproto.getSubpath = function (from, to) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return R.getSubpath(path, from, to);
    };
    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>“linear”</li>
     #     <li>“&lt;” or “easeIn” or “ease-in”</li>
     #     <li>“>” or “easeOut” or “ease-out”</li>
     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
     #     <li>“backIn” or “back-in”</li>
     #     <li>“backOut” or “back-out”</li>
     #     <li>“elastic”</li>
     #     <li>“bounce”</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
     \*/
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function (callback) {
                setTimeout(callback, 16);
            },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                        upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                        upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                        upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                    ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
     \*/
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        //
        //
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
     \*/
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
     \*/
    Animation.prototype.repeat = function (times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
     \*/
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if(callback){
                // find the last one
                var lastKey = 0;
                for(var i in params){
                    var percent = toInt(i);
                    if(params[has](i) && percent > lastKey){
                        lastKey = percent;
                    }
                }
                lastKey += '%';
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({100: p}, ms);
        }
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
     \*/
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
     \*/
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
     \*/
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
     \*/
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
            this.items = [];
            this.length = 0;
            this.type = "set";
            if (items) {
                for (var i = 0, ii = items.length; i < ii; i++) {
                    if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                        this[this.items.length] = this.items[this.items.length] = items[i];
                        this.length++;
                    }
                }
            }
        },
        setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
     \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
     \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
     \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
     \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
     \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
     \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            (this.items[i] && !this.items[i].removed) || len--;
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };

    // FREEGROUP Fix: RaphaelJS changes the order of the elements of the 'set' by calling the toBack method.
    //                "toBack" must be called reverse to care about the rendering order. In this case we override
    //                the buggy default implementation here.
    //
    setproto.toBack = function () {
        var i = this.items.length;
        while (i--) {
            this.items[i].toBack();
        }
        return this;
    };

    // FREEGROUP Fix: Unfortunately raphael didn'T expose the "set.prototype". In this case
    //                I must add all extension to the raphael implementation itself.
    //                Provide support method for easy check if the elements are visible.
    setproto.isVisible = function () {
        var i = this.items.length;
        var visible = false;
        while (i--) {
            visible = visible ||this.items[i].isVisible();
        }
        return visible;
    };


    // FREEGROUP FIX: Adding "isWithoutTransform" to the function and redirect them to the elements
    setproto.getBBox = function (isWithoutTransform) {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox(isWithoutTransform);
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = this.paper.set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    setproto.glow = function(glowConfig) {
        var ret = this.paper.set();
        this.forEach(function(shape, index){
            var g = shape.glow(glowConfig);
            if(g != null){
                g.forEach(function(shape2, index2){
                    ret.push(shape2);
                });
            }
        });
        return ret;
    };


    /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this set’s elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
    setproto.isPointInside = function (x, y) {
        var isPointInside = false;
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false; // stop loop
            }
        });
        return isPointInside;
    };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({…}));
     \*/
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                        return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                    }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
     \*/
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
     \*/
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
     \*/
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - … (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
     \*/
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
     \*/
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     …
     | })(Raphael.ninja());
     \*/
    R.ninja = function () {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
     \*/
    R.st = setproto;

    eve.on("raphael.DOMload", function () {
        loaded = true;
    });

    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener){
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    return R;
}));

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ SVG Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.svg", ["raphael.core"], function(raphael) {
            return factory(raphael);
        });
    } else if (typeof exports === "object") {
        factory(require("./raphael.core"));
    } else {
        factory(glob.Raphael);
    }
}(this, function(R) {
    if (R && !R.svg) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = /[, ]+/,
        eve = R.eve,
        E = "",
        S = " ";
    var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {};
    R.toString = function () {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var $ = function (el, attr) {
            if (attr) {
                if (typeof el == "string") {
                    el = $(el);
                }
                for (var key in attr) if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
            } else {
                el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
            }
            return el;
        },
        addGradientFill = function (element, gradient) {
            var type = "linear",
                id = element.id + gradient,
                fx = .5, fy = .5,
                o = element.node,
                SVG = element.paper,
                s = o.style,
                el = R._g.doc.getElementById(id);
            if (!el) {
                gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                    type = "radial";
                    if (_fx && _fy) {
                        fx = toFloat(_fx);
                        fy = toFloat(_fy);
                        var dir = ((fy > .5) * 2 - 1);
                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                    }
                    return E;
                });
                gradient = gradient.split(/\s*\-\s*/);
                if (type == "linear") {
                    var angle = gradient.shift();
                    angle = -toFloat(angle);
                    if (isNaN(angle)) {
                        return null;
                    }
                    var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                    vector[2] *= max;
                    vector[3] *= max;
                    if (vector[2] < 0) {
                        vector[0] = -vector[2];
                        vector[2] = 0;
                    }
                    if (vector[3] < 0) {
                        vector[1] = -vector[3];
                        vector[3] = 0;
                    }
                }
                var dots = R._parseDots(gradient);
                if (!dots) {
                    return null;
                }
                id = id.replace(/[\(\)\s,\xb0#]/g, "_");

                if (element.gradient && id != element.gradient.id) {
                    SVG.defs.removeChild(element.gradient);
                    delete element.gradient;
                }

                if (!element.gradient) {
                    el = $(type + "Gradient", {id: id});
                    element.gradient = el;
                    $(el, type == "radial" ? {
                        fx: fx,
                        fy: fy
                    } : {
                        x1: vector[0],
                        y1: vector[1],
                        x2: vector[2],
                        y2: vector[3],
                        gradientTransform: element.matrix.invert()
                    });
                    SVG.defs.appendChild(el);
                    for (var i = 0, ii = dots.length; i < ii; i++) {
                        el.appendChild($("stop", {
                            offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                            "stop-color": dots[i].color || "#fff",
                            "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                        }));
                    }
                }
            }
            /* FREEGROUP: don't push URL parameter into the drawing. This will break Apps with "?" in the URL
             * see: https://github.com/DmitryBaranovskiy/raphael/issues/693
             **/
            var url ="";//document.location.protocol + "//" + document.location.host  + document.location.pathname;
            $(o, {
                fill: "url('" + url + "#" + id + "')",
                opacity: 1,
                "fill-opacity": 1
            });

            s.fill = E;
            s.opacity = 1;
            s.fillOpacity = 1;
            return 1;
        },
        updatePosition = function (o) {
            var bbox = o.getBBox(1);
            $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
        },
        addArrow = function (o, value, isEnd) {
            if (o.type == "path") {
                var values = Str(value).toLowerCase().split("-"),
                    p = o.paper,
                    se = isEnd ? "end" : "start",
                    node = o.node,
                    attrs = o.attrs,
                    stroke = attrs["stroke-width"],
                    i = values.length,
                    type = "classic",
                    from,
                    to,
                    dx,
                    refX,
                    attr,
                    w = 3,
                    h = 3,
                    t = 5;
                while (i--) {
                    switch (values[i]) {
                        case "block":
                        case "classic":
                        case "oval":
                        case "diamond":
                        case "open":
                        case "none":
                            type = values[i];
                            break;
                        case "wide": h = 5; break;
                        case "narrow": h = 2; break;
                        case "long": w = 5; break;
                        case "short": w = 2; break;
                    }
                }
                if (type == "open") {
                    w += 2;
                    h += 2;
                    t += 2;
                    dx = 1;
                    refX = isEnd ? 4 : 1;
                    attr = {
                        fill: "none",
                        stroke: attrs.stroke
                    };
                } else {
                    refX = dx = w / 2;
                    attr = {
                        fill: attrs.stroke,
                        stroke: "none"
                    };
                }
                if (o._.arrows) {
                    if (isEnd) {
                        o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                        o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                    } else {
                        o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                        o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                    }
                } else {
                    o._.arrows = {};
                }
                if (type != "none") {
                    var pathId = "raphael-marker-" + type,
                        markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                    if (!R._g.doc.getElementById(pathId)) {
                        p.defs.appendChild($($("path"), {
                            "stroke-linecap": "round",
                            d: markers[type],
                            id: pathId
                        }));
                        markerCounter[pathId] = 1;
                    } else {
                        markerCounter[pathId]++;
                    }
                    var marker = R._g.doc.getElementById(markerId),
                        use;
                    if (!marker) {
                        marker = $($("marker"), {
                            id: markerId,
                            markerHeight: h,
                            markerWidth: w,
                            orient: "auto",
                            refX: refX,
                            refY: h / 2
                        });
                        use = $($("use"), {
                            "xlink:href": "#" + pathId,
                            transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                            "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                        });
                        marker.appendChild(use);
                        p.defs.appendChild(marker);
                        markerCounter[markerId] = 1;
                    } else {
                        markerCounter[markerId]++;
                        use = marker.getElementsByTagName("use")[0];
                    }
                    $(use, attr);
                    var delta = dx * (type != "diamond" && type != "oval");
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - delta * stroke;
                    } else {
                        from = delta * stroke;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    attr = {};
                    attr["marker-" + se] = "url(#" + markerId + ")";
                    if (to || from) {
                        attr.d = R.getSubpath(attrs.path, from, to);
                    }
                    $(node, attr);
                    o._.arrows[se + "Path"] = pathId;
                    o._.arrows[se + "Marker"] = markerId;
                    o._.arrows[se + "dx"] = delta;
                    o._.arrows[se + "Type"] = type;
                    o._.arrows[se + "String"] = value;
                } else {
                    if (isEnd) {
                        from = o._.arrows.startdx * stroke || 0;
                        to = R.getTotalLength(attrs.path) - from;
                    } else {
                        from = 0;
                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                    }
                    o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                    delete o._.arrows[se + "Path"];
                    delete o._.arrows[se + "Marker"];
                    delete o._.arrows[se + "dx"];
                    delete o._.arrows[se + "Type"];
                    delete o._.arrows[se + "String"];
                }
                for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                    var item = R._g.doc.getElementById(attr);
                    item && item.parentNode.removeChild(item);
                }
            }
        },
        dasharray = {
            "-": [3, 1],
            ".": [1, 1],
            "-.": [3, 1, 1, 1],
            "-..": [3, 1, 1, 1, 1, 1],
            ". ": [1, 3],
            "- ": [4, 3],
            "--": [8, 3],
            "- .": [4, 3, 1, 3],
            "--.": [8, 3, 1, 3],
            "--..": [8, 3, 1, 3, 1, 3]
        },
        addDashes = function (o, value, params) {
            value = dasharray[Str(value).toLowerCase()];
            if (value) {
                var width = o.attrs["stroke-width"] || "1",
                    butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                    dashes = [],
                    i = value.length;
                while (i--) {
                    dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                }
                $(o.node, {"stroke-dasharray": dashes.join(",")});
            }
            else {
                $(o.node, {"stroke-dasharray": "none"});
            }
        },
        setFillAndStroke = function (o, params) {
            var node = o.node,
                attrs = o.attrs,
                vis = node.style.visibility;
            node.style.visibility = "hidden";
            for (var att in params) {
                if (params[has](att)) {
                    if (!R._availableAttrs[has](att)) {
                        continue;
                    }
                    var value = params[att];
                    attrs[att] = value;
                    switch (att) {
                        case "blur":
                            o.blur(value);
                            break;
                        case "title":
                            var title = node.getElementsByTagName("title");

                            // Use the existing <title>.
                            if (title.length && (title = title[0])) {
                                title.firstChild.nodeValue = value;
                            } else {
                                title = $("title");
                                var val = R._g.doc.createTextNode(value);
                                title.appendChild(val);
                                node.appendChild(title);
                            }
                            break;
                        case "href":
                        case "target":
                            var pn = node.parentNode;
                            if (pn.tagName.toLowerCase() != "a") {
                                var hl = $("a");
                                pn.insertBefore(hl, node);
                                hl.appendChild(node);
                                pn = hl;
                            }
                            if (att == "target") {
                                pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                            } else {
                                pn.setAttributeNS(xlink, att, value);
                            }
                            break;
                        case "cursor":
                            node.style.cursor = value;
                            break;
                        case "transform":
                            o.transform(value);
                            break;
                        case "arrow-start":
                            addArrow(o, value);
                            break;
                        case "arrow-end":
                            addArrow(o, value, 1);
                            break;
                        case "clip-rect":
                            var rect = Str(value).split(separator);
                            if (rect.length == 4) {
                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                var el = $("clipPath"),
                                    rc = $("rect");
                                el.id = R.createUUID();
                                $(rc, {
                                    x: rect[0],
                                    y: rect[1],
                                    width: rect[2],
                                    height: rect[3]
                                });
                                el.appendChild(rc);
                                o.paper.defs.appendChild(el);
                                $(node, {"clip-path": "url(#" + el.id + ")"});
                                o.clip = rc;
                            }
                            if (!value) {
                                var path = node.getAttribute("clip-path");
                                if (path) {
                                    var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                    clip && clip.parentNode.removeChild(clip);
                                    $(node, {"clip-path": E});
                                    delete o.clip;
                                }
                            }
                            break;
                        case "path":
                            if (o.type == "path") {
                                $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                                o._.dirty = 1;
                                if (o._.arrows) {
                                    "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                    "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                                }
                            }
                            break;
                        case "width":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fx) {
                                att = "x";
                                value = attrs.x;
                            } else {
                                break;
                            }
                        case "x":
                            if (attrs.fx) {
                                value = -attrs.x - (attrs.width || 0);
                            }
                        case "rx":
                            if (att == "rx" && o.type == "rect") {
                                break;
                            }
                        case "cx":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "height":
                            node.setAttribute(att, value);
                            o._.dirty = 1;
                            if (attrs.fy) {
                                att = "y";
                                value = attrs.y;
                            } else {
                                break;
                            }
                        case "y":
                            if (attrs.fy) {
                                value = -attrs.y - (attrs.height || 0);
                            }
                        case "ry":
                            if (att == "ry" && o.type == "rect") {
                                break;
                            }
                        case "cy":
                            node.setAttribute(att, value);
                            o.pattern && updatePosition(o);
                            o._.dirty = 1;
                            break;
                        case "r":
                            if (o.type == "rect") {
                                $(node, {rx: value, ry: value});
                            } else {
                                node.setAttribute(att, value);
                            }
                            o._.dirty = 1;
                            break;
                        case "src":
                            if (o.type == "image") {
                                node.setAttributeNS(xlink, "href", value);
                            }
                            break;
                        case "stroke-width":
                            /* FREEGROUP fix
                             * draw2d version 3.0.3
                             *
                             * don't scale the line width if the user resize an shape/element.
                             * Obscure stroke-width in case of "Draw2D touch" usage
                             */
                            if(!attrs["stroke-scale"]){
                                if (o._.sx != 1 || o._.sy != 1) {
                                    value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                                }
                                if (o.paper._vbSize) {
                                //    value *= o.paper._vbSize;
                                }
                            }


                            node.setAttribute(att, value);
                            if (attrs["stroke-dasharray"]) {
                                addDashes(o, attrs["stroke-dasharray"], params);
                            }
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "stroke-dasharray":
                            addDashes(o, value, params);
                            break;
                        case "fill":
                            var isURL = Str(value).match(R._ISURL);
                            if (isURL) {
                                el = $("pattern");
                                var ig = $("image");
                                el.id = R.createUUID();
                                $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                                el.appendChild(ig);

                                (function (el) {
                                    R._preload(isURL[1], function () {
                                        var w = this.offsetWidth,
                                            h = this.offsetHeight;
                                        $(el, {width: w, height: h});
                                        $(ig, {width: w, height: h});
                                    });
                                })(el);
                                o.paper.defs.appendChild(el);
                                $(node, {fill: "url(#" + el.id + ")"});
                                o.pattern = el;
                                o.pattern && updatePosition(o);
                                break;
                            }
                            var clr = R.getRGB(value);
                            if (!clr.error) {
                                delete params.gradient;
                                delete attrs.gradient;
                                !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {opacity: attrs.opacity});
                                !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {"fill-opacity": attrs["fill-opacity"]});
                            } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                                if ("opacity" in attrs || "fill-opacity" in attrs) {
                                    var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                    if (gradient) {
                                        var stops = gradient.getElementsByTagName("stop");
                                        $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                    }
                                }
                                attrs.gradient = value;
                                attrs.fill = "none";
                                break;
                            }
                            clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        case "stroke":
                            clr = R.getRGB(value);
                            node.setAttribute(att, clr.hex);
                            att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                            if (att == "stroke" && o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                            break;
                        case "gradient":
                            (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                            break;
                        case "opacity":
                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                            }
                        // fall
                        case "fill-opacity":
                            if (attrs.gradient) {
                                gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    stops = gradient.getElementsByTagName("stop");
                                    // FREEGROUP FIX
                                    for (gri = 0, grii = stops.length; gri < grii; gri++) {
                                        $(stops[gri], {"stop-opacity": value});
                                    }
                                    // END FIX
                                }
                                break;
                            }
                        default:
                            att == "font-size" && (value = toInt(value, 10) + "px");
                            var cssrule = att.replace(/(\-.)/g, function (w) {
                                return w.substring(1).toUpperCase();
                            });
                            node.style[cssrule] = value;
                            o._.dirty = 1;
                            node.setAttribute(att, value);
                            break;
                    }
                }
            }

            tuneText(o, params);
            node.style.visibility = vis;
        },
        leading = 1.2,
        tuneText = function (el, params) {
            if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                return;
            }
            var a = el.attrs,
                node = el.node,
                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

            if (params[has]("text")) {
                a.text = params.text;
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var texts = Str(params.text).split("\n"),
                    tspans = [],
                    tspan;
                for (var i = 0, ii = texts.length; i < ii; i++) {
                    tspan = $("tspan");
                    i && $(tspan, {dy: fontSize * leading, x: a.x});
                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                    node.appendChild(tspan);
                    tspans[i] = tspan;
                }
            } else {
                tspans = node.getElementsByTagName("tspan");
                for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                    $(tspans[i], {dy: fontSize * leading, x: a.x});
                } else {
                    $(tspans[0], {dy: 0});
                }
            }
            $(node, {x: a.x, y: a.y});
            el._.dirty = 1;
            var bb = el._getBBox(),
                dif = a.y - (bb.y + bb.height / 2);
            dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
        },
        getRealNode = function (node) {
            if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
                return node.parentNode;
            } else {
                return node;
            }
        },
        Element = function (node, svg) {
            var X = 0,
                Y = 0;
            /*\
             * Element.node
             [ property (object) ]
             **
             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
             **
             * Note: Don’t mess with it.
             > Usage
             | // draw a circle at coordinate 10,10 with radius of 10
             | var c = paper.circle(10, 10, 10);
             | c.node.onclick = function () {
             |     c.attr("fill", "red");
             | };
             \*/
            this[0] = this.node = node;
            /*\
             * Element.raphael
             [ property (object) ]
             **
             * Internal reference to @Raphael object. In case it is not available.
             > Usage
             | Raphael.el.red = function () {
             |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
             |     hsb.h = 1;
             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
             | }
             \*/
            node.raphael = true;
            /*\
             * Element.id
             [ property (number) ]
             **
             * Unique id of the element. Especially useful when you want to listen to events of the element,
             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
             \*/
            this.id = R._oid++;
            node.raphaelid = this.id;
            this.matrix = R.matrix();
            this.realPath = null;
            /*\
             * Element.paper
             [ property (object) ]
             **
             * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
             > Usage
             | Raphael.el.cross = function () {
             |     this.attr({fill: "red"});
             |     this.paper.path("M10,10L50,50M50,10L10,50")
             |         .attr({stroke: "red"});
             | }
             \*/
            this.paper = svg;
            this.attrs = this.attrs || {};
            this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                deg: 0,
                dx: 0,
                dy: 0,
                dirty: 1
            };
            !svg.bottom && (svg.bottom = this);
            /*\
             * Element.prev
             [ property (object) ]
             **
             * Reference to the previous element in the hierarchy.
             \*/
            this.prev = svg.top;
            svg.top && (svg.top.next = this);
            svg.top = this;
            /*\
             * Element.next
             [ property (object) ]
             **
             * Reference to the next element in the hierarchy.
             \*/
            this.next = null;
        },
        elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = function (pathString, SVG) {
        var el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        var p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    /*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     > Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
     = (object) @Element
     \*/
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    /*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     > Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx & cy aren’t specified centre of the shape is used instead.
     = (object) @Element
     \*/
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        return this;
    };
    /*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     > Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
     \*/
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    /*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesn’t change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     > Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45°, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     > Parameters
     - tstr (string) #optional transformation string
     * If tstr isn’t specified
     = (string) current transformation string
     * else
     = (object) @Element
     \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(this, tstr);

        this.clip && $(this.clip, {transform: this.matrix.invert()});
        this.pattern && updatePosition(this);
        this.node && $(this.node, {transform: this.matrix});

        if (_.sx != 1 || _.sy != 1) {
            var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({"stroke-width": sw});
        }

        //Reduce transform string
        _.transform = this.matrix.toTransformString();

        return this;
    };
    /*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
     \*/
    elproto.hide = function () {
        if(!this.removed) this.node.style.display = "none";
        return this;
    };
    /*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
     \*/
    elproto.show = function () {
        if(!this.removed) this.node.style.display = "";
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
     \*/
    elproto.remove = function () {
        var node = getRealNode(this.node);
        if (this.removed || !node.parentNode) {
            return;
        }
        var paper = this.paper;
        paper.__set__ && paper.__set__.exclude(this);
        eve.unbind("raphael.*.*." + this.id);
        if (this.gradient) {
            paper.defs.removeChild(this.gradient);
        }
        R._tear(this, paper);

        node.parentNode.removeChild(node);

        // Remove custom data for element
        this.removeData();

        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto._getBBox = function () {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        var canvasHidden = false,
            containerStyle;
        if (this.paper.canvas.parentElement) {
            containerStyle = this.paper.canvas.parentElement.style;
        } //IE10+ can't find parentElement
        else if (this.paper.canvas.parentNode) {
            containerStyle = this.paper.canvas.parentNode.style;
        }

        if(containerStyle && containerStyle.display == "none") {
            canvasHidden = true;
            containerStyle.display = "";
        }
        var bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch(e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            }
        } finally {
            bbox = bbox || {};
            if(canvasHidden){
                containerStyle.display = "none";
            }
        }
        hide && this.hide();
        return bbox;
    };
    /*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     > Parameters
     - attrName (string) attribute’s name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attribute’s name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName & value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     > Possible parameters
     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     > Gradients
     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
     *
     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     > Path String
     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
     > Colour Parsing
     # <ul>
     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
     # </ul>
     \*/
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par) if (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(this, params);
        return this;
    };
    /*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
     = (object) @Element
     \*/
    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        var svg = this.paper;
        svg.top != this && R._tofront(this, svg);
        return this;
    };
    /*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
     = (object) @Element
     \*/
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        var parentNode = node.parentNode;
        parentNode.insertBefore(node, parentNode.firstChild);
        R._toback(this, this.paper);
        var svg = this.paper;
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
     \*/
    elproto.insertAfter = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) {
            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        } else {
            afterNode.parentNode.appendChild(node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
     \*/
    elproto.insertBefore = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || 1.5});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: "url(#" + fltr.id + ")"});
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
        return t;
    };
    R._engine.circle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = "image";
        return res;
    };
    R._engine.text = function (svg, x, y, text) {
        var el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            "text-anchor": "middle",
            text: text,
            "font-family": R._availableAttrs["font-family"],
            "font-size": R._availableAttrs["font-size"],
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    R._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
            css = "overflow:hidden;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg",
            "xmlns:xlink": "http://www.w3.org/1999/xlink"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            size = mmax(w / paperSize.width, h / paperSize.height),
            top = this.top,
            aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({"stroke-width": sw});
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };
    /*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
     \*/
    R.prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };
    /*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
     \*/
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
    };
    /*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
     \*/
    R.prototype.remove = function () {
        eve("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
    };
    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}));

// ┌─────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ VML Module                                                          │ \\
// ├─────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\
// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\
// └─────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael.vml", ["raphael.core"], function(raphael) {
            return factory(raphael);
        });
    } else if (typeof exports === "object") {
        factory(require("./raphael.core"));
    } else {
        factory(glob.Raphael);
    }
}(this, function(R) {
    if (R && !R.vml) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
        zoom = 21600,
        pathTypes = {path: 1, rect: 1, image: 1},
        ovalTypes = {circle: 1, ellipse: 1},
        path2vml = function (path) {
            var total =  /[ahqstv]/ig,
                command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function (all, command, args) {
                    var vals = [],
                        isMove = command.toLowerCase() == "m",
                        res = map[command];
                    args.replace(val, function (value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });
                return res;
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.join(S);
        },
        compensation = function (deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function (p, sx, sy, dx, dy, deg) {
            var _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = 1,
                flip = "",
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
    R.toString = function () {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function (o, value, isEnd) {
            var values = Str(value).toLowerCase().split("-"),
                se = isEnd ? "end" : "start",
                i = values.length,
                type = "classic",
                w = "medium",
                h = "medium";
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                    case "narrow": h = values[i]; break;
                    case "long":
                    case "short": w = values[i]; break;
                }
            }
            var stroke = o.node.getElementsByTagName("stroke")[0];
            stroke[se + "arrow"] = type;
            stroke[se + "arrowlength"] = w;
            stroke[se + "arrowwidth"] = h;
        },
        setFillAndStroke = function (o, params) {
            // o.paper.canvas.style.display = "none";
            o.attrs = o.attrs || {};
            var node = o.node,
                a = o.attrs,
                s = node.style,
                xy,
                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
                res = o;


            for (var par in params) if (params[has](par)) {
                a[par] = params[par];
            }
            if (newpath) {
                a.path = R._getPath[o.type](o);
                o._.dirty = 1;
            }
            params.href && (node.href = params.href);
            params.title && (node.title = params.title);
            params.target && (node.target = params.target);
            params.cursor && (s.cursor = params.cursor);
            "blur" in params && o.blur(params.blur);
            if (params.path && o.type == "path" || newpath) {
                node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
                o._.dirty = 1;
                if (o.type == "image") {
                    o._.fillpos = [a.x, a.y];
                    o._.fillsize = [a.width, a.height];
                    setCoords(o, 1, 1, 0, 0, 0);
                }
            }
            "transform" in params && o.transform(params.transform);
            if (isOval) {
                var cx = +a.cx,
                    cy = +a.cy,
                    rx = +a.rx || +a.r || 0,
                    ry = +a.ry || +a.r || 0;
                node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
                o._.dirty = 1;
            }
            if ("clip-rect" in params) {
                var rect = Str(params["clip-rect"]).split(separator);
                if (rect.length == 4) {
                    rect[2] = +rect[2] + (+rect[0]);
                    rect[3] = +rect[3] + (+rect[1]);
                    var div = node.clipRect || R._g.doc.createElement("div"),
                        dstyle = div.style;
                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                    if (!node.clipRect) {
                        dstyle.position = "absolute";
                        dstyle.top = 0;
                        dstyle.left = 0;
                        dstyle.width = o.paper.width + "px";
                        dstyle.height = o.paper.height + "px";
                        node.parentNode.insertBefore(div, node);
                        div.appendChild(node);
                        node.clipRect = div;
                    }
                }
                if (!params["clip-rect"]) {
                    node.clipRect && (node.clipRect.style.clip = "auto");
                }
            }
            if (o.textpath) {
                var textpathStyle = o.textpath.style;
                params.font && (textpathStyle.font = params.font);
                params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
                params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
                params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
                params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
            }
            if ("arrow-start" in params) {
                addArrow(res, params["arrow-start"]);
            }
            if ("arrow-end" in params) {
                addArrow(res, params["arrow-end"], 1);
            }
            if (params.opacity != null ||
                params["stroke-width"] != null ||
                params.fill != null ||
                params.src != null ||
                params.stroke != null ||
                params["stroke-width"] != null ||
                params["stroke-opacity"] != null ||
                params["fill-opacity"] != null ||
                params["stroke-dasharray"] != null ||
                params["stroke-miterlimit"] != null ||
                params["stroke-linejoin"] != null ||
                params["stroke-linecap"] != null) {
                var fill = node.getElementsByTagName(fillString),
                    newfill = false;
                fill = fill && fill[0];
                !fill && (newfill = fill = createNode(fillString));
                if (o.type == "image" && params.src) {
                    fill.src = params.src;
                }
                params.fill && (fill.on = true);
                if (fill.on == null || params.fill == "none" || params.fill === null) {
                    fill.on = false;
                }
                if (fill.on && params.fill) {
                    var isURL = Str(params.fill).match(R._ISURL);
                    if (isURL) {
                        fill.parentNode == node && node.removeChild(fill);
                        fill.rotate = true;
                        fill.src = isURL[1];
                        fill.type = "tile";
                        var bbox = o.getBBox(1);
                        fill.position = bbox.x + S + bbox.y;
                        o._.fillpos = [bbox.x, bbox.y];

                        R._preload(isURL[1], function () {
                            o._.fillsize = [this.offsetWidth, this.offsetHeight];
                        });
                    } else {
                        fill.color = R.getRGB(params.fill).hex;
                        fill.src = E;
                        fill.type = "solid";
                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                            a.fill = "none";
                            a.gradient = params.fill;
                            fill.rotate = false;
                        }
                    }
                }
                if ("fill-opacity" in params || "opacity" in params) {
                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                    opacity = mmin(mmax(opacity, 0), 1);
                    fill.opacity = opacity;
                    if (fill.src) {
                        fill.color = "none";
                    }
                }
                node.appendChild(fill);
                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                    newstroke = false;
                !stroke && (newstroke = stroke = createNode("stroke"));
                if ((params.stroke && params.stroke != "none") ||
                    params["stroke-width"] ||
                    params["stroke-opacity"] != null ||
                    params["stroke-dasharray"] ||
                    params["stroke-miterlimit"] ||
                    params["stroke-linejoin"] ||
                    params["stroke-linecap"]) {
                    stroke.on = true;
                }
                (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                var strokeColor = R.getRGB(params.stroke);
                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                var width = (toFloat(params["stroke-width"]) || 1) * .75;
                opacity = mmin(mmax(opacity, 0), 1);
                params["stroke-width"] == null && (width = a["stroke-width"]);
                params["stroke-width"] && (stroke.weight = width);
                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                stroke.opacity = opacity;

                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                stroke.miterlimit = params["stroke-miterlimit"] || 8;
                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                if ("stroke-dasharray" in params) {
                    var dasharray = {
                        "-": "shortdash",
                        ".": "shortdot",
                        "-.": "shortdashdot",
                        "-..": "shortdashdotdot",
                        ". ": "dot",
                        "- ": "dash",
                        "--": "longdash",
                        "- .": "dashdot",
                        "--.": "longdashdot",
                        "--..": "longdashdotdot"
                    };
                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                }
                newstroke && node.appendChild(stroke);
            }
            if (res.type == "text") {
                res.paper.canvas.style.display = E;
                var span = res.paper.span,
                    m = 100,
                    fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
                s = span.style;
                a.font && (s.font = a.font);
                a["font-family"] && (s.fontFamily = a["font-family"]);
                a["font-weight"] && (s.fontWeight = a["font-weight"]);
                a["font-style"] && (s.fontStyle = a["font-style"]);
                fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
                s.fontSize = fontSize * m + "px";
                res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
                var brect = span.getBoundingClientRect();
                res.W = a.w = (brect.right - brect.left) / m;
                res.H = a.h = (brect.bottom - brect.top) / m;
                // res.paper.canvas.style.display = "none";
                res.X = a.x;
                res.Y = a.y + res.H / 2;

                ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
                var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
                for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                    res._.dirty = 1;
                    break;
                }

                // text-anchor emulation
                switch (a["text-anchor"]) {
                    case "start":
                        res.textpath.style["v-text-align"] = "left";
                        res.bbx = res.W / 2;
                        break;
                    case "end":
                        res.textpath.style["v-text-align"] = "right";
                        res.bbx = -res.W / 2;
                        break;
                    default:
                        res.textpath.style["v-text-align"] = "center";
                        res.bbx = 0;
                        break;
                }
                res.textpath.style["v-text-kern"] = true;
            }
            // res.paper.canvas.style.display = E;
        },
        addGradientFill = function (o, gradient, fill) {
            o.attrs = o.attrs || {};
            var attrs = o.attrs,
                pow = Math.pow,
                opacity,
                oindex,
                type = "linear",
                fxfy = ".5 .5";
            o.attrs.gradient = gradient;
            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
                type = "radial";
                if (fx && fy) {
                    fx = toFloat(fx);
                    fy = toFloat(fy);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                    fxfy = fx + S + fy;
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            o = o.shape || o.node;
            if (dots.length) {
                o.removeChild(fill);
                fill.on = true;
                fill.method = "none";
                fill.color = dots[0].color;
                fill.color2 = dots[dots.length - 1].color;
                var clrs = [];
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                }
                fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
                if (type == "radial") {
                    fill.type = "gradientTitle";
                    fill.focus = "100%";
                    fill.focussize = "0 0";
                    fill.focusposition = fxfy;
                    fill.angle = 0;
                } else {
                    // fill.rotate= true;
                    fill.type = "gradient";
                    fill.angle = (270 - angle) % 360;
                }
                o.appendChild(fill);
            }
            return 1;
        },
        Element = function (node, vml) {
            this[0] = this.node = node;
            node.raphael = true;
            this.id = R._oid++;
            node.raphaelid = this.id;
            this.X = 0;
            this.Y = 0;
            this.attrs = {};
            this.paper = vml;
            this.matrix = R.matrix();
            this._ = {
                transform: [],
                sx: 1,
                sy: 1,
                dx: 0,
                dy: 0,
                deg: 0,
                dirty: 1,
                dirtyT: 1
            };
            !vml.bottom && (vml.bottom = this);
            this.prev = vml.top;
            vml.top && (vml.top.next = this);
            vml.top = this;
            this.next = null;
        };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;
        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + tstr);
        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(1, 1);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        if (oldt !== null) { // empty string value is true as well
            this._.transform = oldt;
            R._extractTransform(this, oldt);
        }
        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;

        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function () {
        !this.removed && (this.node.style.display = "none");
        return this;
    };
    elproto.show = function () {
        !this.removed && (this.node.style.display = E);
        return this;
    };
    // Needed to fix the vml setViewBox issues
    elproto.auxGetBBox = R.el.getBBox;
    elproto.getBBox = function(){
        var b = this.auxGetBBox();
        if (this.paper && this.paper._viewBoxShift)
        {
            var c = {};
            var z = 1/this.paper._viewBoxShift.scale;
            c.x = b.x - this.paper._viewBoxShift.dx;
            c.x *= z;
            c.y = b.y - this.paper._viewBoxShift.dy;
            c.y *= z;
            c.width  = b.width  * z;
            c.height = b.height * z;
            c.x2 = c.x + c.width;
            c.y2 = c.y + c.height;
            return c;
        }
        return b;
    };
    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y - this.H,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        this.paper.__set__ && this.paper.__set__.exclude(this);
        R.eve.unbind("raphael.*.*." + this.id);
        R._tear(this, this.paper);
        this.node.parentNode.removeChild(this.node);
        this.shape && this.shape.parentNode.removeChild(this.shape);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            // this.paper.canvas.style.display = "none";
            if (params.text && this.type == "text") {
                this.textpath.string = params.text;
            }
            setFillAndStroke(this, params);
            // this.paper.canvas.style.display = E;
        }
        return this;
    };
    elproto.toFront = function () {
        !this.removed && this.node.parentNode.appendChild(this.node);
        this.paper && this.paper.top != this && R._tofront(this, this.paper);
        return this;
    };
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.firstChild != this.node) {
            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
            R._toback(this, this.paper);
        }
        return this;
    };
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[element.length - 1];
        }
        if (element.node.nextSibling) {
            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
        } else {
            element.node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[0];
        }
        element.node.parentNode.insertBefore(this.node, element.node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    R._engine.path = function (pathString, vml) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        var p = new Element(el, vml),
            attr = {fill: "none", stroke: "#000"};
        pathString && (attr.path = pathString);
        p.type = "path";
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
        var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = "rect";
        return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * 2;
        res.H = ry * 2;
        res.type = "ellipse";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        return res;
    };
    R._engine.circle = function (vml, x, y, r) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * 2;
        res.type = "circle";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
        var path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: "none"}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = "image";
        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = src;
        fill.type = "tile";
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function (vml, x, y, text) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = x || 0;
        y = y || 0;
        text = text || "";
        path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(text);
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml),
            attr = {
                fill: "#000",
                stroke: "none",
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            width = paperSize.width,
            height = paperSize.height,
            H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: paperSize
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
        var doc = win.document;
        if (doc.styleSheets.length < 31) {
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        } else {
            // no more room, add to the existing one
            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
            doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
        }
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = function (tagName) {
                return doc.createElement('<rvml:' + tagName + ' class="rvml">');
            };
        } catch (e) {
            createNode = function (tagName) {
                return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
            };
        }
    };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}));

// ┌────────────────────────────────────────────────────────────────────┐ \\
// │ Raphaël @VERSION - JavaScript Vector Library                       │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\
// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\
// ├────────────────────────────────────────────────────────────────────┤ \\
// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\
// └────────────────────────────────────────────────────────────────────┘ \\

(function (glob, factory) {
    if (typeof define === "function" && define.amd) {
        define("raphael", ["raphael.core", "raphael.svg", "raphael.vml"], function(Raphael) {
            return (glob.Raphael = factory(Raphael));
        });
    } else if (typeof exports === "object") {
        var raphael = require("raphael.core");

        require("raphael.svg");
        require("raphael.vml");

        module.exports = factory(raphael);
    } else {
        glob.Raphael = factory(glob.Raphael);
    }
}(this, function (Raphael) {
    return Raphael.ninja();
}));









/**
 * FRaphael
 * 	An extension for Raphael.js to make it easier to work with Filter Effects
 *
 * Copyright © 2013 Chris Scott <chris.scott@factmint.com>
 * Delivered with and licensed under the MIT licence
 *
 */

// Create the global FRaphael object
(function(scope) {
    var	version = "0.0.1",
        license = "MIT";

    var	ns = "http://www.w3.org/2000/svg",
        idCounter = 0;

    var FR = {
        // Object prototype for a filter
        Filter: function(id) {
            if (id == undefined) {
                id = "filter-" + idCounter++;
                while(FR.filters[id] != undefined) {
                    id = "filter-" + idCounter++;
                }
            }

            if (FR.filters[id] != undefined) {
                throw "A filter with id " + id + " already exists";
            }

            this.element = document.createElementNS(ns, "filter");
            this.element.setAttribute("id", id);
            this.element.setAttribute("x", "-25%");
            this.element.setAttribute("y", "-25%");
            this.element.setAttribute("width", "150%");
            this.element.setAttribute("height", "150%");

            this.lastFEResult = null;

            FR.filters[id] = this;
            this.id = id;
        },

        // Object prototype for an effect
        FilterEffect: function(type, attributes) {
            this.element = document.createElementNS(ns, type);
            for (var key in attributes) {
                this.element.setAttribute(key, attributes[key]);
            }
        },

        // Return the filter applied to an element or a new filter if none are currently applied
        getFilter: function(element) {
            var filterId = element.data("filterId");
            var filter = null;

            if (filterId == undefined) {
                filterId = "element-filter-" + element.id;
                filter = element.paper.createFilter(filterId);
                element.filter(filterId);
            } else {
                filter = FR.filters[filterId];
            }

            return filter;
        },

        // maintain a list of filters by id
        filters: {}
    };

    FR.Filter.prototype = {
        addEffect: function(type, attributes, children) {
            var effect = new FR.FilterEffect(type, attributes);

            if (children) {
                if (children instanceof Array) {
                    for (var x in children) {
                        if (!children.hasOwnProperty(x)) continue;

                        effect.element.appendChild(children[x].element);
                    }
                } else {
                    effect.element.appendChild(children.element);
                }
            }

            this.element.appendChild(effect.element);

            return this;
        },

        chainEffect: function(type, attributes, children) {
            if (attributes == undefined) {
                attributes = {};
            }

            var inId;
            var outId;
            if (attributes.in == undefined) {
                inId = this.getLastResult();
            } else {
                inId = attributes.in;
            }
            if (attributes.result == undefined) {
                outId = idCounter++;
            } else {
                outId = attributes.result;
            }

            this.lastFEResult = outId;

            attributes.in = inId;
            attributes.result = outId;

            this.addEffect(type, attributes, children);

            return this;
        },

        getLastResult: function() {
            return (this.lastFEResult == undefined) ? "SourceGraphic" : this.lastFEResult;
        },

        merge: function(in1, in2, attributes) {
            var mergeNode1 = new FR.FilterEffect("feMergeNode", {
                in: in1
            });
            var mergeNode2 = new FR.FilterEffect("feMergeNode", {
                in: in2
            });

            this.chainEffect("feMerge", attributes, [mergeNode1, mergeNode2]);

            return this;
        },

        compose: function(in1, in2, operator, attributes) {
            if (attributes == undefined) {
                attributes = {};
            }

            if (operator == undefined) {
                operator = "over";
            }

            attributes.in = in1;
            attributes.in2 = in2;
            attributes.operator = operator;

            this.chainEffect("feComposite", attributes);

            return this;
        },

        arithmeticCompose: function(in1, in2, k1, k2, k3, k4) {
            if (k1 == undefined) {
                k1 = 0;
            }
            if (k2 == undefined) {
                k2 = 0;
            }
            if (k3 == undefined) {
                k3 = 0;
            }
            if (k4 == undefined) {
                k4 = 0;
            }

            this.compose(in1, in2, "arithmetic", {
                k1: k1,
                k2: k2,
                k3: k3,
                k4: k4
            });

            return this;
        },

        addBlur: function(stdDeviation, attributes) {
            if (!stdDeviation) {
                throw "Standard deviation is required to perform a blur filter";
            }

            if (attributes == undefined) {
                attributes = {};
            }
            attributes.stdDeviation = stdDeviation;

            this.chainEffect("feGaussianBlur", attributes);

            return this;
        },

        addOffset: function(dx, dy, attributes) {
            if (dx == undefined | dy == undefined) {
                throw "dx and dy values are required to perform an offset FE";
            }

            if (attributes == undefined) {
                attributes = {};
            }
            attributes.dx = dx;
            attributes.dy = dy;

            this.chainEffect("feOffset", attributes);

            return this;
        },

        addLighting: function(x, y, z, color, type, attributes) {
            if (x == undefined | y == undefined | z == undefined) {
                throw "Three co-ordinates are required to create a light source";
            }

            var previousResult = this.getLastResult();

            var id = idCounter++;

            if (attributes == undefined) {
                attributes = {};
            }

            attributes.result = id;
            if (color != undefined) {
                attributes["lighting-color"] = color;
            }

            if (type == undefined || type == "diffuse") {
                type = "feDiffuseLighting";
            } else if (type == "specular") {
                type = "feSpecularLighting";
            }

            var lightSource = new FR.FilterEffect("fePointLight", {
                x: x,
                y: y,
                z: z
            });

            this.chainEffect(type, attributes, lightSource).arithmeticCompose(previousResult, id, 3, 0.2, 0, 0);

            return this;
        },

        addShiftToColor: function(color, moveBy, attributes) {
            if (color == undefined) {
                throw "A colour string is a required argument to create a colorMatrix";
            }
            if (moveBy == undefined) {
                moveBy = 0.5;
            }

            var remainingColor = 1 - moveBy, x = remainingColor;

            if (attributes == undefined) {
                attributes = {};
            }

            var colorObject = Raphael.color(color);
            var	r = colorObject.r * moveBy / 255,
                g = colorObject.g * moveBy / 255,
                b = colorObject.b * moveBy / 255;

            /**
             * r'	x 0 0 0 r		r
             * g'	0 x 0 0 g		g
             * b' =	0 0 x 0 b	.	b
             * a'	0 0 0 1 0		o
             * 1					1
             */
            attributes.values = x + " 0 0 0 " + r + " 0 " + x + " 0 0 " + g + " 0 0 " + x + " 0 " + b + " 0 0 0 1 0 ";

            this.chainEffect("feColorMatrix", attributes);

            return this;
        },

        addRecolor: function(color, opacity, attributes) {
            if (color == undefined) {
                throw "A colour string is a required argument to create a colorMatrix";
            }
            if (opacity == undefined) {
                opacity = 1;
            }

            if (attributes == undefined) {
                attributes = {};
            }

            var colorObject = Raphael.color(color);
            var	r = colorObject.r / 255,
                g = colorObject.g / 255,
                b = colorObject.b / 255;

            /**
             * r'	0 0 0 0 r		r
             * g'	0 0 0 0 g		g
             * b' =	0 0 0 0 b	.	b
             * a'	0 0 0 a 0		a
             * 1					1
             */
            attributes.values = "0 0 0 0 " + r + " 0 0 0 0 " + g + " 0 0 0 0 " + b + " 0 0 0 " + opacity + " 0 ";

            this.chainEffect("feColorMatrix", attributes);

            return this;
        },

        addDesaturate: function(saturation, attributes) {
            if (saturation == undefined) {
                saturnation = 0;
            }

            if (attributes == undefined) {
                attributes = {};
            }

            attributes.values = saturation;
            attributes.type = "saturate";

            this.chainEffect("feColorMatrix", attributes);

            return this;
        },

        addConvolveMatrix: function(matrix, attributes) {
            if (matrix == undefined) {
                throw "A matrix (usually 9 numbers) must be provided to apply a convolve matrix transform";
            }

            if (attributes == undefined) {
                attributes = {};
            }

            attributes.kernelMatrix = matrix;

            this.chainEffect("feConvolveMatrix", attributes);

            return this;
        },

        createShadow: function(dx, dy, blur, opacity, color) {
            if (dx == undefined) {
                throw "dx is required for the shadow effect";
            }
            if (dy == undefined) {
                throw "dy is required for the shadow effect";
            }
            if (blur == undefined) {
                throw "blur (stdDeviation) is required for the shadow effect";
            }

            if (opacity == undefined) {
                opacity = 0.6;
            }

            var previousResult = this.getLastResult();

            if (color == undefined) {
                color = "#000000";
            }

            this.addOffset(dx, dy, {
                in: "SourceAlpha"
            });

            this.addRecolor(color, opacity);

            this.addBlur(blur);

            this.merge(this.getLastResult(), previousResult);

            return this;
        },

        createEmboss: function(height, x, y, z) {
            if (height == undefined) {
                height = 2;
            }
            if (x == undefined) {
                x = -1000;
            }
            if (y == undefined) {
                y = -5000;
            }
            if (z == undefined) {
                z = 300;
            }

            // Create the highlight

            this.addOffset(height * x / (x + y), height * y / (x + y), {
                in: "SourceAlpha"
            });

            this.addBlur(height * 0.5);

            var whiteLightSource = new FR.FilterEffect("fePointLight", {
                x: x,
                y: y,
                z: z
            });

            this.chainEffect("feSpecularLighting", {
                surfaceScale: height,
                specularConstant: 0.8,
                specularExponent: 15
            }, whiteLightSource);

            this.compose(this.getLastResult(), "SourceAlpha", "in");
            var whiteLight = this.getLastResult();

            // Create the lowlight

            this.addOffset(height * -1 * x / (x + y), height * -1 * y / (x + y), {
                in: "SourceAlpha"
            });

            this.addBlur(height * 0.5);

            var darkLightSource = new FR.FilterEffect("fePointLight", {
                x: -1 * x,
                y: -1 * y,
                z:      z
            });

            this.chainEffect("feSpecularLighting", {
                surfaceScale: height,
                specularConstant: 1.8,
                specularExponent: 6
            }, darkLightSource);

            this.compose(this.getLastResult(), "SourceAlpha", "in");
            this.chainEffect("feColorMatrix", {
                values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0"
            });
            var darkLight = this.getLastResult();

            this.arithmeticCompose(whiteLight, darkLight, 0, 0.8, 0.5, 0);

            this.merge("SourceGraphic", this.getLastResult());

            return this;
        }
    };

    scope.FRaphael = FR;
})(this);

/**
 * add a filter to the paper by id
 */
Raphael.fn.createFilter = function(id) {
    var paper = this;
    var filter = new FRaphael.Filter(id);
    paper.defs.appendChild(filter.element);

    return filter;
};

/**
 * Apply a filter to an element by id
 */
Raphael.el.filter = function(filter) {
    var id = (filter instanceof FRaphael.Filter) ? filter.id : filter;

    this.node.setAttribute("filter", "url(#" + id + ")");
    this.data("filterId", id);

    return this;
};

/**
 * Get the current filter for an element or a new one if not
 */
Raphael.el.getFilter = function() {
    return FRaphael.getFilter(this);
};

/**
 * A shorthand method for applying blur
 */
Raphael.el.blur = function(stdDeviation) {
    if (stdDeviation == undefined) {
        stdDeviation = 3;
    }

    this.getFilter().addBlur(stdDeviation);

    return this;
};

/**
 * A shorthand method for applying a drop shadow
 */
Raphael.el.shadow = function(dx, dy, blur, opacity, color) {
    if (dx == undefined) {
        dx = 3;
    }
    if (dy == undefined) {
        dy = 3;
    }
    if (blur == undefined) {
        blur = 3;
    }

    this.getFilter().createShadow(dx, dy, blur, opacity, color);

    return this;
};

/**
 * A shorthand method for applying lighting
 */
Raphael.el.light = function(x, y, z, color, type) {
    if (x == undefined) {
        x = this.paper.width;
    }
    if (y == undefined) {
        y = 0;
    }
    if (z == undefined) {
        z = 20;
    }

    this.getFilter().addLighting(x, y, z, color, type);

    return this;
};

/**
 * A shorthand method for applying a colour shift
 */
Raphael.el.colorShift = function(color, shift) {
    if (color == undefined) {
        color = "black";
    }
    if (shift == undefined) {
        shift = 0.5;
    }

    this.getFilter().addShiftToColor(color, shift);

    return this;
};

/**
 * A shorthand method for embossing
 */
Raphael.el.emboss = function(height) {
    this.getFilter().createEmboss(height);

    return this;
};

/**
 * A shorthand method for desaturating
 */
Raphael.el.desaturate = function(saturation) {
    this.getFilter().addDesaturate(saturation);

    return this;
};

/**
 * A shorthand method for complete desaturation
 */
Raphael.el.greyScale = function() {
    this.getFilter().addDesaturate(0);

    return this;
};

;
/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);

;
/*!
 * jQuery contextMenu - Plugin for simple contextMenu handling
 *
 * Version: 1.6.5
 *
 * Authors: Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://medialize.github.com/jQuery-contextMenu/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */

(function($, undefined){
    
    // TODO: -
        // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
        // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

// determine html5 compatibility
$.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
$.support.htmlCommand = ('HTMLCommandElement' in window);
$.support.eventSelectstart = ("onselectstart" in document.documentElement);
/* // should the need arise, test for css user-select
$.support.cssUserSelect = (function(){
    var t = false,
        e = document.createElement('div');
    
    $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
        var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
            prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';
            
        e.style.cssText = prop + ': text;';
        if (e.style[propCC] == 'text') {
            t = true;
            return false;
        }
        
        return true;
    });
    
    return t;
})();
*/

if (!$.ui || !$.ui.widget) {
    // duck punch $.cleanData like jQueryUI does to get that remove event
    // https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js#L16-24
    var _cleanData = $.cleanData;
    $.cleanData = function( elems ) {
        for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
            try {
                $( elem ).triggerHandler( "remove" );
                // http://bugs.jquery.com/ticket/8235
            } catch( e ) {}
        }
        _cleanData( elems );
    };
}

var // currently active contextMenu trigger
    $currentTrigger = null,
    // is contextMenu initialized with at least one menu?
    initialized = false,
    // window handle
    $win = $(window),
    // number of registered menus
    counter = 0,
    // mapping selector to namespace
    namespaces = {},
    // mapping namespace to options
    menus = {},
    // custom command type handlers
    types = {},
    // default values
    defaults = {
        // selector of contextMenu trigger
        selector: null,
        // where to append the menu to
        appendTo: null,
        // method to trigger context menu ["right", "left", "hover"]
        trigger: "right",
        // hide menu when mouse leaves trigger / menu elements
        autoHide: false,
        // ms to wait before showing a hover-triggered context menu
        delay: 200,
        // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
        // as long as the trigger happened on one of the trigger-element's child nodes
        reposition: false,
        // determine position to show menu at
        determinePosition: function($menu) {
            // position to the lower middle of the trigger element
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "center top",
                    at: "center bottom",
                    of: this,
                    offset: "0 5",
                    collision: "fit"
                }).css('display', 'none');
            } else {
                // determine contextMenu position
                var offset = this.offset();
                offset.top += this.outerHeight();
                offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                $menu.css(offset);
            }
        },
        // position menu
        position: function(opt, x, y) {
            var $this = this,
                offset;
            // determine contextMenu position
            if (!x && !y) {
                opt.determinePosition.call(this, opt.$menu);
                return;
            } else if (x === "maintain" && y === "maintain") {
                // x and y must not be changed (after re-show on command click)
                offset = opt.$menu.position();
            } else {
                // x and y are given (by mouse event)
                offset = {top: y, left: x};
            }
            
            // correct offset if viewport demands it
            var bottom = $win.scrollTop() + $win.height(),
                right = $win.scrollLeft() + $win.width(),
                height = opt.$menu.height(),
                width = opt.$menu.width();
            
            if (offset.top + height > bottom) {
                offset.top -= height;
            }
            
            if (offset.left + width > right) {
                offset.left -= width;
            }
            
            opt.$menu.css(offset);
        },
        // position the sub-menu
        positionSubmenu: function($menu) {
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "left top",
                    at: "right top",
                    of: this,
                    collision: "flipfit fit"
                }).css('display', '');
            } else {
                // determine contextMenu position
                var offset = {
                    top: 0,
                    left: this.outerWidth()
                };
                $menu.css(offset);
            }
        },
        // offset to add to zIndex
        zIndex: 1,
        // show hide animation settings
        animation: {
            duration: 50,
            show: 'slideDown',
            hide: 'slideUp'
        },
        // events
        events: {
            show: $.noop,
            hide: $.noop
        },
        // default callback
        callback: null,
        // list of contextMenu items
        items: {}
    },
    // mouse position for hover activation
    hoveract = {
        timer: null,
        pageX: null,
        pageY: null
    },
    // determine zIndex
    zindex = function($t) {
        var zin = 0,
            $tt = $t;

        while (true) {
            zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
            $tt = $tt.parent();
            if (!$tt || !$tt.length || "html body".indexOf($tt.prop('nodeName').toLowerCase()) > -1 ) {
                break;
            }
        }
        
        return zin;
    },
    // event handlers
    handle = {
        // abort anything
        abortevent: function(e){
            e.preventDefault();
            e.stopImmediatePropagation();
        },
        
        // contextmenu show dispatcher
        contextmenu: function(e) {
            var $this = $(this);
            
            // disable actual context-menu
            e.preventDefault();
            e.stopImmediatePropagation();
            
            // abort native-triggered events unless we're triggering on right click
            if (e.data.trigger != 'right' && e.originalEvent) {
                return;
            }
            
            // abort event if menu is visible for this trigger
            if ($this.hasClass('context-menu-active')) {
                return;
            }
            
            if (!$this.hasClass('context-menu-disabled')) {
                // theoretically need to fire a show event at <menu>
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                // e.data.$menu.trigger(evt);
                
                $currentTrigger = $this;
                if (e.data.build) {
                    var built = e.data.build($currentTrigger, e);
                    // abort if build() returned false
                    if (built === false) {
                        return;
                    }
                    
                    // dynamically build menu on invocation
                    e.data = $.extend(true, {}, defaults, e.data, built || {});

                    // abort if there are no items to display
                    if (!e.data.items || $.isEmptyObject(e.data.items)) {
                        // Note: jQuery captures and ignores errors from event handlers
                        if (window.console) {
                            (console.error || console.log)("No items specified to show in contextMenu");
                        }
                        
                        throw new Error('No Items sepcified');
                    }
                    
                    // backreference for custom command type creation
                    e.data.$trigger = $currentTrigger;
                    
                    op.create(e.data);
                }
                // show menu
                op.show.call($this, e.data, e.pageX, e.pageY);
            }
        },
        // contextMenu left-click trigger
        click: function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            $(this).trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
        },
        // contextMenu right-click trigger
        mousedown: function(e) {
            // register mouse down
            var $this = $(this);
            
            // hide any previous menus
            if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
            }
            
            // activate on right click
            if (e.button == 2) {
                $currentTrigger = $this.data('contextMenuActive', true);
            }
        },
        // contextMenu right-click trigger
        mouseup: function(e) {
            // show menu
            var $this = $(this);
            if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
            }
            
            $this.removeData('contextMenuActive');
        },
        // contextMenu hover trigger
        mouseenter: function(e) {
            var $this = $(this),
                $related = $(e.relatedTarget),
                $document = $(document);
            
            // abort if we're coming from a menu
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }
            
            // abort if a menu is shown
            if ($currentTrigger && $currentTrigger.length) {
                return;
            }
            
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
            hoveract.data = e.data;
            $document.on('mousemove.contextMenuShow', handle.mousemove);
            hoveract.timer = setTimeout(function() {
                hoveract.timer = null;
                $document.off('mousemove.contextMenuShow');
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: hoveract.data, pageX: hoveract.pageX, pageY: hoveract.pageY }));
            }, e.data.delay );
        },
        // contextMenu hover trigger
        mousemove: function(e) {
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
        },
        // contextMenu hover trigger
        mouseleave: function(e) {
            // abort if we're leaving for a menu
            var $related = $(e.relatedTarget);
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }
            
            try {
                clearTimeout(hoveract.timer);
            } catch(e) {}
            
            hoveract.timer = null;
        },
        
        // click on layer to hide contextMenu
        layerClick: function(e) {
            var $this = $(this),
                root = $this.data('contextMenuRoot'),
                mouseup = false,
                button = e.button,
                x = e.pageX,
                y = e.pageY,
                target, 
                offset,
                selectors;
                
            e.preventDefault();
            e.stopImmediatePropagation();
            
            setTimeout(function() {
                var $window, hideshow, possibleTarget;
                var triggerAction = ((root.trigger == 'left' && button === 0) || (root.trigger == 'right' && button === 2));
                
                // find the element that would've been clicked, wasn't the layer in the way
                if (document.elementFromPoint) {
                    root.$layer.hide();
                    target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
                    root.$layer.show();
                }
                
                if (root.reposition && triggerAction) {
                    if (document.elementFromPoint) {
                        if (root.$trigger.is(target) || root.$trigger.has(target).length) {
                            root.position.call(root.$trigger, root, x, y);
                            return;
                        }
                    } else {
                        offset = root.$trigger.offset();
                        $window = $(window);
                        // while this looks kinda awful, it's the best way to avoid
                        // unnecessarily calculating any positions
                        offset.top += $window.scrollTop();
                        if (offset.top <= e.pageY) {
                            offset.left += $window.scrollLeft();
                            if (offset.left <= e.pageX) {
                                offset.bottom = offset.top + root.$trigger.outerHeight();
                                if (offset.bottom >= e.pageY) {
                                    offset.right = offset.left + root.$trigger.outerWidth();
                                    if (offset.right >= e.pageX) {
                                        // reposition
                                        root.position.call(root.$trigger, root, x, y);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (target && triggerAction) {
                    root.$trigger.one('contextmenu:hidden', function() {
                        $(target).contextMenu({x: x, y: y});
                    });
                }

                root.$menu.trigger('contextmenu:hide');
            }, 50);
        },
        // key handled :hover
        keyStop: function(e, opt) {
            if (!opt.isInput) {
                e.preventDefault();
            }
            
            e.stopPropagation();
        },
        key: function(e) {
            var opt = $currentTrigger.data('contextMenu') || {};

            switch (e.keyCode) {
                case 9:
                case 38: // up
                    handle.keyStop(e, opt);
                    // if keyCode is [38 (up)] or [9 (tab) with shift]
                    if (opt.isInput) {
                        if (e.keyCode == 9 && e.shiftKey) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('prevcommand');
                            return;
                        } else if (e.keyCode == 38 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else if (e.keyCode != 9 || e.shiftKey) {
                        opt.$menu.trigger('prevcommand');
                        return;
                    }
                    // omitting break;
                    
                // case 9: // tab - reached through omitted break;
                case 40: // down
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (e.keyCode == 9) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('nextcommand');
                            return;
                        } else if (e.keyCode == 40 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else {
                        opt.$menu.trigger('nextcommand');
                        return;
                    }
                    break;
                
                case 37: // left
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }
                
                    if (!opt.$selected.parent().hasClass('context-menu-root')) {
                        var $parent = opt.$selected.parent().parent();
                        opt.$selected.trigger('contextmenu:blur');
                        opt.$selected = $parent;
                        return;
                    }
                    break;
                    
                case 39: // right
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }
                    
                    var itemdata = opt.$selected.data('contextMenu') || {};
                    if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                        opt.$selected = null;
                        itemdata.$selected = null;
                        itemdata.$menu.trigger('nextcommand');
                        return;
                    }
                    break;
                
                case 35: // end
                case 36: // home
                    if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                        return;
                    } else {
                        (opt.$selected && opt.$selected.parent() || opt.$menu)
                            .children(':not(.disabled, .not-selectable)')[e.keyCode == 36 ? 'first' : 'last']()
                            .trigger('contextmenu:focus');
                        e.preventDefault();
                        return;
                    }
                    break;
                    
                case 13: // enter
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (opt.$selected && !opt.$selected.is('textarea, select')) {
                            e.preventDefault();
                            return;
                        }
                        break;
                    }
                    opt.$selected && opt.$selected.trigger('mouseup');
                    return;
                    
                case 32: // space
                case 33: // page up
                case 34: // page down
                    // prevent browser from scrolling down while menu is visible
                    handle.keyStop(e, opt);
                    return;
                    
                case 27: // esc
                    handle.keyStop(e, opt);
                    opt.$menu.trigger('contextmenu:hide');
                    return;
                    
                default: // 0-9, a-z
                    var k = (String.fromCharCode(e.keyCode)).toUpperCase();
                    if (opt.accesskeys[k]) {
                        // according to the specs accesskeys must be invoked immediately
                        opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu
                            ? 'contextmenu:focus'
                            : 'mouseup'
                        );
                        return;
                    }
                    break;
            }
            // pass event to selected item, 
            // stop propagation to avoid endless recursion
            e.stopPropagation();
            opt.$selected && opt.$selected.trigger(e);
        },

        // select previous possible command in menu
        prevItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }
            
            var $children = opt.$menu.children(),
                $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                $round = $prev;
            
            // skip disabled
            while ($prev.hasClass('disabled') || $prev.hasClass('not-selectable')) {
                if ($prev.prev().length) {
                    $prev = $prev.prev();
                } else {
                    $prev = $children.last();
                }
                if ($prev.is($round)) {
                    // break endless loop
                    return;
                }
            }
            
            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            
            // activate next
            handle.itemMouseenter.call($prev.get(0), e);
            
            // focus input
            var $input = $prev.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        // select next possible command in menu
        nextItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                $round = $next;

            // skip disabled
            while ($next.hasClass('disabled') || $next.hasClass('not-selectable')) {
                if ($next.next().length) {
                    $next = $next.next();
                } else {
                    $next = $children.first();
                }
                if ($next.is($round)) {
                    // break endless loop
                    return;
                }
            }
            
            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }
            
            // activate next
            handle.itemMouseenter.call($next.get(0), e);
            
            // focus input
            var $input = $next.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        
        // flag that we're inside an input so the key handler can act accordingly
        focusInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.$selected = opt.$selected = $this;
            root.isInput = opt.isInput = true;
        },
        // flag that we're inside an input so the key handler can act accordingly
        blurInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.isInput = opt.isInput = false;
        },
        
        // :hover on menu
        menuMouseenter: function(e) {
            var root = $(this).data().contextMenuRoot;
            root.hovering = true;
        },
        // :hover on menu
        menuMouseleave: function(e) {
            var root = $(this).data().contextMenuRoot;
            if (root.$layer && root.$layer.is(e.relatedTarget)) {
                root.hovering = false;
            }
        },
        
        // :hover done manually so key handling is possible
        itemMouseenter: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;
            
            root.hovering = true;

            // abort if we're re-entering
            if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }

            // make sure only one item is selected
            (opt.$menu ? opt : root).$menu
                .children('.hover').trigger('contextmenu:blur');

            if ($this.hasClass('disabled') || $this.hasClass('not-selectable')) {
                opt.$selected = null;
                return;
            }
            
            $this.trigger('contextmenu:focus');
        },
        // :hover done manually so key handling is possible
        itemMouseleave: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                root.$selected && root.$selected.trigger('contextmenu:blur');
                e.preventDefault();
                e.stopImmediatePropagation();
                root.$selected = opt.$selected = opt.$node;
                return;
            }
            
            $this.trigger('contextmenu:blur');
        },
        // contextMenu item click
        itemClick: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot,
                key = data.contextMenuKey,
                callback;

            // abort if the key is unknown or disabled or is a menu
            if (!opt.items[key] || $this.is('.disabled, .context-menu-submenu, .context-menu-separator, .not-selectable')) {
                return;
            }

            e.preventDefault();
            e.stopImmediatePropagation();

            if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
                // item-specific callback
                callback = root.callbacks[key];
            } else if ($.isFunction(root.callback)) {
                // default callback
                callback = root.callback;                
            } else {
                // no callback, no action
                return;
            }

            // hide menu if callback doesn't stop that
            if (callback.call(root.$trigger, key, root) !== false) {
                root.$menu.trigger('contextmenu:hide');
            } else if (root.$menu.parent().length) {
                op.update.call(root.$trigger, root);
            }
        },
        // ignore click events on input elements
        inputClick: function(e) {
            e.stopImmediatePropagation();
        },
        
        // hide <menu>
        hideMenu: function(e, data) {
            var root = $(this).data('contextMenuRoot');
            op.hide.call(root.$trigger, root, data && data.force);
        },
        // focus <command>
        focusItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            $this.addClass('hover')
                .siblings('.hover').trigger('contextmenu:blur');
            
            // remember selected
            opt.$selected = root.$selected = $this;
            
            // position sub-menu - do after show so dumb $.ui.position can keep up
            if (opt.$node) {
                root.positionSubmenu.call(opt.$node, opt.$menu);
            }
        },
        // blur <command>
        blurItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;
            
            $this.removeClass('hover');
            opt.$selected = null;
        }
    },
    // operations
    op = {
        show: function(opt, x, y) {
            var $trigger = $(this),
                offset,
                css = {};

            // hide any open menus
            $('#context-menu-layer').trigger('mousedown');

            // backreference for callbacks
            opt.$trigger = $trigger;

            // show event
            if (opt.events.show.call($trigger, opt) === false) {
                $currentTrigger = null;
                return;
            }

            // create or update context menu
            op.update.call($trigger, opt);
            
            // position menu
            opt.position.call($trigger, opt, x, y);

            // make sure we're in front
            if (opt.zIndex) {
                css.zIndex = zindex($trigger) + opt.zIndex;
            }
            
            // add layer
            op.layer.call(opt.$menu, opt, css.zIndex);
            
            // adjust sub-menu zIndexes
            opt.$menu.find('ul').css('zIndex', css.zIndex + 1);
            
            // position and show context menu
            opt.$menu.css( css )[opt.animation.show](opt.animation.duration, function() {
                $trigger.trigger('contextmenu:visible');
            });
            // make options available and set state
            $trigger
                .data('contextMenu', opt)
                .addClass("context-menu-active");
            
            // register key handler
            $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
            // register autoHide handler
            if (opt.autoHide) {
                // mouse position handler
                $(document).on('mousemove.contextMenuAutoHide', function(e) {
                    // need to capture the offset on mousemove,
                    // since the page might've been scrolled since activation
                    var pos = $trigger.offset();
                    pos.right = pos.left + $trigger.outerWidth();
                    pos.bottom = pos.top + $trigger.outerHeight();
                    
                    if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                        // if mouse in menu...
                        opt.$menu.trigger('contextmenu:hide');
                    }
                });
            }
        },
        hide: function(opt, force) {
            var $trigger = $(this);
            if (!opt) {
                opt = $trigger.data('contextMenu') || {};
            }
            
            // hide event
            if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                return;
            }
            
            // remove options and revert state
            $trigger
                .removeData('contextMenu')
                .removeClass("context-menu-active");
            
            if (opt.$layer) {
                // keep layer for a bit so the contextmenu event can be aborted properly by opera
                setTimeout((function($layer) {
                    return function(){
                        $layer.remove();
                    };
                })(opt.$layer), 10);
                
                try {
                    delete opt.$layer;
                } catch(e) {
                    opt.$layer = null;
                }
            }
            
            // remove handle
            $currentTrigger = null;
            // remove selected
            opt.$menu.find('.hover').trigger('contextmenu:blur');
            opt.$selected = null;
            // unregister key and mouse handlers
            //$(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
            $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
            // hide menu
            opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function (){
                // tear down dynamically built menu after animation is completed.
                if (opt.build) {
                    opt.$menu.remove();
                    $.each(opt, function(key, value) {
                        switch (key) {
                            case 'ns':
                            case 'selector':
                            case 'build':
                            case 'trigger':
                                return true;

                            default:
                                opt[key] = undefined;
                                try {
                                    delete opt[key];
                                } catch (e) {}
                                return true;
                        }
                    });
                }
                
                setTimeout(function() {
                    $trigger.trigger('contextmenu:hidden');
                }, 10);
            });
        },
        create: function(opt, root) {
            if (root === undefined) {
                root = opt;
            }
            // create contextMenu
            opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
                'contextMenu': opt,
                'contextMenuRoot': root
            });
            
            $.each(['callbacks', 'commands', 'inputs'], function(i,k){
                opt[k] = {};
                if (!root[k]) {
                    root[k] = {};
                }
            });
            
            root.accesskeys || (root.accesskeys = {});
            
            // create contextMenu items
            $.each(opt.items, function(key, item){
                var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""),
                    $label = null,
                    $input = null;
                
                // iOS needs to see a click-event bound to an element to actually
                // have the TouchEvents infrastructure trigger the click event
                $t.on('click', $.noop);
                
                item.$node = $t.data({
                    'contextMenu': opt,
                    'contextMenuRoot': root,
                    'contextMenuKey': key
                });
                
                // register accesskey
                // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                if (item.accesskey) {
                    var aks = splitAccesskey(item.accesskey);
                    for (var i=0, ak; ak = aks[i]; i++) {
                        if (!root.accesskeys[ak]) {
                            root.accesskeys[ak] = item;
                            item._name = item.name.replace(new RegExp('(' + ak + ')', 'i'), '<span class="context-menu-accesskey">$1</span>');
                            break;
                        }
                    }
                }
                
                if (typeof item == "string") {
                    $t.addClass('context-menu-separator not-selectable');
                } else if (item.type && types[item.type]) {
                    // run custom type handler
                    types[item.type].call($t, item, opt, root);
                    // register commands
                    $.each([opt, root], function(i,k){
                        k.commands[key] = item;
                        if ($.isFunction(item.callback)) {
                            k.callbacks[key] = item.callback;
                        }
                    });
                } else {
                    // add label for input
                    if (item.type == 'html') {
                        $t.addClass('context-menu-html not-selectable');
                    } else if (item.type) {
                        $label = $('<label></label>').appendTo($t);
                        $('<span></span>').html(item._name || item.name).appendTo($label);
                        $t.addClass('context-menu-input');
                        opt.hasTypes = true;
                        $.each([opt, root], function(i,k){
                            k.commands[key] = item;
                            k.inputs[key] = item;
                        });
                    } else if (item.items) {
                        item.type = 'sub';
                    }
                
                    switch (item.type) {
                        case 'text':
                            $input = $('<input type="text" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);
                            break;
                    
                        case 'textarea':
                            $input = $('<textarea name=""></textarea>')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);

                            if (item.height) {
                                $input.height(item.height);
                            }
                            break;

                        case 'checkbox':
                            $input = $('<input type="checkbox" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;

                        case 'radio':
                            $input = $('<input type="radio" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + item.radio)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;
                    
                        case 'select':
                            $input = $('<select name="">')
                                .attr('name', 'context-menu-input-' + key)
                                .appendTo($label);
                            if (item.options) {
                                $.each(item.options, function(value, text) {
                                    $('<option></option>').val(value).text(text).appendTo($input);
                                });
                                $input.val(item.selected);
                            }
                            break;
                        
                        case 'sub':
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name).appendTo($t);
                            item.appendTo = item.$node;
                            op.create(item, root);
                            $t.data('contextMenu', item).addClass('context-menu-submenu');
                            item.callback = null;
                            break;
                        
                        case 'html':
                            $(item.html).appendTo($t);
                            break;
                        
                        default:
                            $.each([opt, root], function(i,k){
                                k.commands[key] = item;
                                if ($.isFunction(item.callback)) {
                                    k.callbacks[key] = item.callback;
                                }
                            });
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name || "").appendTo($t);
                            break;
                    }
                    
                    // disable key listener in <input>
                    if (item.type && item.type != 'sub' && item.type != 'html') {
                        $input
                            .on('focus', handle.focusInput)
                            .on('blur', handle.blurInput);
                        
                        if (item.events) {
                            $input.on(item.events, opt);
                        }
                    }
                
                    // add icons
                    if (item.icon) {
                        $t.addClass("icon icon-" + item.icon);
                    }
                }
                
                // cache contained elements
                item.$input = $input;
                item.$label = $label;

                // attach item to menu
                $t.appendTo(opt.$menu);
                
                // Disable text selection
                if (!opt.hasTypes && $.support.eventSelectstart) {
                    // browsers support user-select: none, 
                    // IE has a special event for text-selection
                    // browsers supporting neither will not be preventing text-selection
                    $t.on('selectstart.disableTextSelect', handle.abortevent);
                }
            });
            // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
            if (!opt.$node) {
                opt.$menu.css('display', 'none').addClass('context-menu-root');
            }
            opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function($menu, nested) {
            // determine widths of submenus, as CSS won't grow them automatically
            // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
            // kinda sucks hard...

            // determine width of absolutely positioned element
            $menu.css({position: 'absolute', display: 'block'});
            // don't apply yet, because that would break nested elements' widths
            // add a pixel to circumvent word-break issue in IE9 - #80
            $menu.data('width', Math.ceil($menu.width()) + 1);
            // reset styles so they allow nested elements to grow/shrink naturally
            $menu.css({
                position: 'static',
                minWidth: '0px',
                maxWidth: '100000px'
            });
            // identify width of nested menus
            $menu.find('> li > ul').each(function() {
                op.resize($(this), true);
            });
            // reset and apply changes in the end because nested
            // elements' widths wouldn't be calculatable otherwise
            if (!nested) {
                $menu.find('ul').andSelf().css({
                    position: '', 
                    display: '',
                    minWidth: '',
                    maxWidth: ''
                }).width(function() {
                    return $(this).data('width');
                });
            }
        },
        update: function(opt, root) {
            var $trigger = this;
            if (root === undefined) {
                root = opt;
                op.resize(opt.$menu);
            }
            // re-check disabled for each item
            opt.$menu.children().each(function(){
                var $item = $(this),
                    key = $item.data('contextMenuKey'),
                    item = opt.items[key],
                    disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true;

                // dis- / enable item
                $item[disabled ? 'addClass' : 'removeClass']('disabled');
                
                if (item.type) {
                    // dis- / enable input elements
                    $item.find('input, select, textarea').prop('disabled', disabled);
                    
                    // update input states
                    switch (item.type) {
                        case 'text':
                        case 'textarea':
                            item.$input.val(item.value || "");
                            break;
                            
                        case 'checkbox':
                        case 'radio':
                            item.$input.val(item.value || "").prop('checked', !!item.selected);
                            break;
                            
                        case 'select':
                            item.$input.val(item.selected || "");
                            break;
                    }
                }
                
                if (item.$menu) {
                    // update sub-menu
                    op.update.call($trigger, item, root);
                }
            });
        },
        layer: function(opt, zIndex) {
            // add transparent layer for click area
            // filter and background for Internet Explorer, Issue #23
            var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>')
                .css({height: $win.height(), width: $win.width(), display: 'block'})
                .data('contextMenuRoot', opt)
                .insertBefore(this)
                .on('contextmenu', handle.abortevent)
                .on('mousedown', handle.layerClick);
            
            // IE6 doesn't know position:fixed;
            if (!$.support.fixedPosition) {
                $layer.css({
                    'position' : 'absolute',
                    'height' : $(document).height()
                });
            }
            
            return $layer;
        }
    };

// split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
function splitAccesskey(val) {
    var t = val.split(/\s+/),
        keys = [];
        
    for (var i=0, k; k = t[i]; i++) {
        k = k[0].toUpperCase(); // first character only
        // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
        // a map to look up already used access keys would be nice
        keys.push(k);
    }
    
    return keys;
}

// handle contextMenu triggers
$.fn.contextMenu = function(operation) {
    if (operation === undefined) {
        this.first().trigger('contextmenu');
    } else if (operation.x && operation.y) {
        this.first().trigger($.Event("contextmenu", {pageX: operation.x, pageY: operation.y}));
    } else if (operation === "hide") {
        var $menu = this.data('contextMenu').$menu;
        $menu && $menu.trigger('contextmenu:hide');
    } else if (operation === "destroy") {
        $.contextMenu("destroy", {context: this});
    } else if ($.isPlainObject(operation)) {
        operation.context = this;
        $.contextMenu("create", operation);
    } else if (operation) {
        this.removeClass('context-menu-disabled');
    } else if (!operation) {
        this.addClass('context-menu-disabled');
    }
    
    return this;
};

// manage contextMenu instances
$.contextMenu = function(operation, options) {
    if (typeof operation != 'string') {
        options = operation;
        operation = 'create';
    }
    
    if (typeof options == 'string') {
        options = {selector: options};
    } else if (options === undefined) {
        options = {};
    }
    
    // merge with default options
    var o = $.extend(true, {}, defaults, options || {});
    var $document = $(document);
    var $context = $document;
    var _hasContext = false;
    
    if (!o.context || !o.context.length) {
        o.context = document;
    } else {
        // you never know what they throw at you...
        $context = $(o.context).first();
        o.context = $context.get(0);
        _hasContext = o.context !== document;
    }
    
    switch (operation) {
        case 'create':
            // no selector no joy
            if (!o.selector) {
                throw new Error('No selector specified');
            }
            // make sure internal classes are not bound to
            if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
            }
            if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                throw new Error('No Items sepcified');
            }
            counter ++;
            o.ns = '.contextMenu' + counter;
            if (!_hasContext) {
                namespaces[o.selector] = o.ns;
            }
            menus[o.ns] = o;
            
            // default to right click
            if (!o.trigger) {
                o.trigger = 'right';
            }
            
            if (!initialized) {
                // make sure item click is registered first
                $document
                    .on({
                        'contextmenu:hide.contextMenu': handle.hideMenu,
                        'prevcommand.contextMenu': handle.prevItem,
                        'nextcommand.contextMenu': handle.nextItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.menuMouseenter,
                        'mouseleave.contextMenu': handle.menuMouseleave
                    }, '.context-menu-list')
                    .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
                    .on({
                        'mouseup.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    }, '.context-menu-item');

                initialized = true;
            }
            
            // engage native contextmenu event
            $context
                .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);
            
            if (_hasContext) {
                // add remove hook, just in case
                $context.on('remove' + o.ns, function() {
                    $(this).contextMenu("destroy");
                });
            }
            
            switch (o.trigger) {
                case 'hover':
                        $context
                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);                    
                    break;
                    
                case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                    break;
                /*
                default:
                    // http://www.quirksmode.org/dom/events/contextmenu.html
                    $document
                        .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                        .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                    break;
                */
            }
            
            // create menu
            if (!o.build) {
                op.create(o);
            }
            break;
        
        case 'destroy':
            var $visibleMenu;
            if (_hasContext) {
                // get proper options 
                var context = o.context;
                $.each(menus, function(ns, o) {
                    if (o.context !== context) {
                        return true;
                    }
                    
                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                        $visibleMenu.trigger('contextmenu:hide', {force: true});
                    }

                    try {
                        if (menus[o.ns].$menu) {
                            menus[o.ns].$menu.remove();
                        }

                        delete menus[o.ns];
                    } catch(e) {
                        menus[o.ns] = null;
                    }

                    $(o.context).off(o.ns);
                    
                    return true;
                });
            } else if (!o.selector) {
                $document.off('.contextMenu .contextMenuAutoHide');
                $.each(menus, function(ns, o) {
                    $(o.context).off(o.ns);
                });
                
                namespaces = {};
                menus = {};
                counter = 0;
                initialized = false;
                
                $('#context-menu-layer, .context-menu-list').remove();
            } else if (namespaces[o.selector]) {
                $visibleMenu = $('.context-menu-list').filter(':visible');
                if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                    $visibleMenu.trigger('contextmenu:hide', {force: true});
                }
                
                try {
                    if (menus[namespaces[o.selector]].$menu) {
                        menus[namespaces[o.selector]].$menu.remove();
                    }
                    
                    delete menus[namespaces[o.selector]];
                } catch(e) {
                    menus[namespaces[o.selector]] = null;
                }
                
                $document.off(namespaces[o.selector]);
            }
            break;
        
        case 'html5':
            // if <command> or <menuitem> are not handled by the browser,
            // or options was a bool true,
            // initialize $.contextMenu for them
            if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options == "boolean" && options)) {
                $('menu[type="context"]').each(function() {
                    if (this.id) {
                        $.contextMenu({
                            selector: '[contextmenu=' + this.id +']',
                            items: $.contextMenu.fromMenu(this)
                        });
                    }
                }).css('display', 'none');
            }
            break;
        
        default:
            throw new Error('Unknown operation "' + operation + '"');
    }
    
    return this;
};

// import values into <input> commands
$.contextMenu.setInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }
    
    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
                item.value = data[key] || "";
                break;

            case 'checkbox':
                item.selected = data[key] ? true : false;
                break;
                
            case 'radio':
                item.selected = (data[item.radio] || "") == item.value ? true : false;
                break;
            
            case 'select':
                item.selected = data[key] || "";
                break;
        }
    });
};

// export values from <input> commands
$.contextMenu.getInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }
    
    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
            case 'select':
                data[key] = item.$input.val();
                break;

            case 'checkbox':
                data[key] = item.$input.prop('checked');
                break;
                
            case 'radio':
                if (item.$input.prop('checked')) {
                    data[item.radio] = item.value;
                }
                break;
        }
    });
    
    return data;
};

// find <label for="xyz">
function inputLabel(node) {
    return (node.id && $('label[for="'+ node.id +'"]').val()) || node.name;
}

// convert <menu> to items object
function menuChildren(items, $children, counter) {
    if (!counter) {
        counter = 0;
    }
    
    $children.each(function() {
        var $node = $(this),
            node = this,
            nodeName = this.nodeName.toLowerCase(),
            label,
            item;
        
        // extract <label><input>
        if (nodeName == 'label' && $node.find('input, textarea, select').length) {
            label = $node.text();
            $node = $node.children().first();
            node = $node.get(0);
            nodeName = node.nodeName.toLowerCase();
        }
        
        /*
         * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
         * Not being the sadistic kind, $.contextMenu only accepts:
         * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
         * Everything else will be imported as an html node, which is not interfaced with contextMenu.
         */
        
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
        switch (nodeName) {
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
            case 'menu':
                item = {name: $node.attr('label'), items: {}};
                counter = menuChildren(item.items, $node.children(), counter);
                break;
            
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
            case 'a':
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
            case 'button':
                item = {
                    name: $node.text(),
                    disabled: !!$node.attr('disabled'),
                    callback: (function(){ return function(){ $node.click(); }; })()
                };
                break;
            
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command

            case 'menuitem':
            case 'command':
                switch ($node.attr('type')) {
                    case undefined:
                    case 'command':
                    case 'menuitem':
                        item = {
                            name: $node.attr('label'),
                            disabled: !!$node.attr('disabled'),
                            callback: (function(){ return function(){ $node.click(); }; })()
                        };
                        break;
                        
                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    case 'radio':
                        item = {
                            type: 'radio',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            radio: $node.attr('radiogroup'),
                            value: $node.attr('id'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    default:
                        item = undefined;
                }
                break;
 
            case 'hr':
                item = '-------';
                break;
                
            case 'input':
                switch ($node.attr('type')) {
                    case 'text':
                        item = {
                            type: 'text',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            value: $node.val()
                        };
                        break;
                        
                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            selected: !!$node.attr('checked')
                        };
                        break;
                        
                    case 'radio':
                        item = {
                            type: 'radio',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            radio: !!$node.attr('name'),
                            value: $node.val(),
                            selected: !!$node.attr('checked')
                        };
                        break;
                    
                    default:
                        item = undefined;
                        break;
                }
                break;
                
            case 'select':
                item = {
                    type: 'select',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    selected: $node.val(),
                    options: {}
                };
                $node.children().each(function(){
                    item.options[this.value] = $(this).text();
                });
                break;
                
            case 'textarea':
                item = {
                    type: 'textarea',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    value: $node.val()
                };
                break;
            
            case 'label':
                break;
            
            default:
                item = {type: 'html', html: $node.clone(true)};
                break;
        }
        
        if (item) {
            counter++;
            items['key' + counter] = item;
        }
    });
    
    return counter;
}

// convert html5 menu
$.contextMenu.fromMenu = function(element) {
    var $this = $(element),
        items = {};
        
    menuChildren(items, $this.children());
    
    return items;
};

// make defaults accessible
$.contextMenu.defaults = defaults;
$.contextMenu.types = types;
// export internal functions - undocumented, for hacking only!
$.contextMenu.handle = handle;
$.contextMenu.op = op;
$.contextMenu.menus = menus;

})(jQuery);

;
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


;
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function ( global, factory ) {

    'use strict';

    // export as AMD...
    if ( typeof define !== 'undefined' && define.amd ) {
        define('canvgModule', [ 'rgbcolor', 'stackblur' ], factory );
    }

    // ...or as browserify
    else if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );
    }

    global.canvg = factory( global.RGBColor, global.stackBlur );

}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {

    // canvg(target, s)
    // empty parameters: replace all 'svg' elements on page with 'canvas' elements
    // target: canvas element or the id of a canvas element
    // s: svg string, url to svg file, or xml document
    // opts: optional hash of options
    //		 ignoreMouse: true => ignore mouse events
    //		 ignoreAnimation: true => ignore animations
    //		 ignoreDimensions: true => does not try to resize canvas
    //		 ignoreClear: true => does not clear canvas
    //		 offsetX: int => draws at a x offset
    //		 offsetY: int => draws at a y offset
    //		 scaleWidth: int => scales horizontally to width
    //		 scaleHeight: int => scales vertically to height
    //		 renderCallback: function => will call the function after the first render is completed
    //		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
    var canvg = function (target, s, opts) {
        // no parameters
        if (target == null && s == null && opts == null) {
            var svgTags = document.querySelectorAll('svg');
            for (var i=0; i<svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }

        if (typeof target == 'string') {
            target = document.getElementById(target);
        }

        // store class on canvas
        if (target.svg != null) target.svg.stop();
        var svg = build(opts || {});
        // on i.e. 8 for flash canvas, we can't assign the property so check for it
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            // load from xml doc
            svg.loadXmlDoc(ctx, s);
        }
        else if (s.substr(0,1) == '<') {
            // load from xml string
            svg.loadXml(ctx, s);
        }
        else {
            // load from url
            svg.load(ctx, s);
        }
    }

    // see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
    var matchesSelector;
    if (typeof(Element.prototype.matches) != 'undefined') {
        matchesSelector = function(node, selector) {
            return node.matches(selector);
        };
    } else if (typeof(Element.prototype.webkitMatchesSelector) != 'undefined') {
        matchesSelector = function(node, selector) {
            return node.webkitMatchesSelector(selector);
        };
    } else if (typeof(Element.prototype.mozMatchesSelector) != 'undefined') {
        matchesSelector = function(node, selector) {
            return node.mozMatchesSelector(selector);
        };
    } else if (typeof(Element.prototype.msMatchesSelector) != 'undefined') {
        matchesSelector = function(node, selector) {
            return node.msMatchesSelector(selector);
        };
    } else if (typeof(Element.prototype.oMatchesSelector) != 'undefined') {
        matchesSelector = function(node, selector) {
            return node.oMatchesSelector(selector);
        };
    } else {
        // requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
        // or jQuery: http://jquery.com/download/
        // or Zepto: http://zeptojs.com/#
        // without it, this is a ReferenceError

        if (typeof jQuery === 'function' || typeof Zepto === 'function') {
            matchesSelector = function (node, selector) {
                return $(node).is(selector);
            };
        }

        if (typeof matchesSelector === 'undefined') {
            matchesSelector = Sizzle.matchesSelector;
        }
    }

    // slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
    var attributeRegex = /(\[[^\]]+\])/g;
    var idRegex = /(#[^\s\+>~\.\[:]+)/g;
    var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
    var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
    var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
    var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
    var elementRegex = /([^\s\+>~\.\[:]+)/g;
    function getSelectorSpecificity(selector) {
        var typeCount = [0, 0, 0];
        var findMatch = function(regex, type) {
            var matches = selector.match(regex);
            if (matches == null) {
                return;
            }
            typeCount[type] += matches.length;
            selector = selector.replace(regex, ' ');
        };

        selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
        selector = selector.replace(/{[^]*/gm, ' ');
        findMatch(attributeRegex, 1);
        findMatch(idRegex, 0);
        findMatch(classRegex, 1);
        findMatch(pseudoElementRegex, 2);
        findMatch(pseudoClassWithBracketsRegex, 1);
        findMatch(pseudoClassRegex, 1);
        selector = selector.replace(/[\*\s\+>~]/g, ' ');
        selector = selector.replace(/[#\.]/g, ' ');
        findMatch(elementRegex, 2);
        return typeCount.join('');
    }

    function build(opts) {
        var svg = { opts: opts };

        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;

        svg.log = function(msg) {};
        if (svg.opts['log'] == true && typeof(console) != 'undefined') {
            svg.log = function(msg) { console.log(msg); };
        };

        // globals
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
            svg.Definitions = {};
            svg.Styles = {};
            svg.StylesSpecificity = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new (function () {
                this.viewPorts = [];
                this.Clear = function() { this.viewPorts = []; }
                this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
                this.RemoveCurrent = function() { this.viewPorts.pop(); }
                this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
                this.width = function() { return this.Current().width; }
                this.height = function() { return this.Current().height; }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') return d;
                    if (d == 'x') return this.width();
                    if (d == 'y') return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
                }
            });
        }
        svg.init();

        // images loaded
        svg.ImagesLoaded = function() {
            for (var i=0; i<svg.Images.length; i++) {
                if (!svg.Images[i].loaded) return false;
            }
            return true;
        }

        // trim
        svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

        // compress spaces
        svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

        // ajax
        svg.ajax = function(url) {
            var AJAX;
            if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
            else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
            if(AJAX){
                AJAX.open('GET',url,false);
                AJAX.send(null);
                return AJAX.responseText;
            }
            return null;
        }

        // parse xml
        svg.parseXml = function(xml) {
            if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
                var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
                var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
                settings.prohibitDtd = false;
                xmlDoc.loadXml(xml, settings);
                return xmlDoc;
            }
            else if (window.DOMParser)
            {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            }
            else
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml);
                return xmlDoc;
            }
        }

        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        }
        svg.Property.prototype.getValue = function() {
            return this.value;
        }

        svg.Property.prototype.hasValue = function() {
            return (this.value != null && this.value !== '');
        }

        // return the numerical value of the property
        svg.Property.prototype.numValue = function() {
            if (!this.hasValue()) return 0;

            var n = parseFloat(this.value);
            if ((this.value + '').match(/%$/)) {
                n = n / 100.0;
            }
            return n;
        }

        svg.Property.prototype.valueOrDefault = function(def) {
            if (this.hasValue()) return this.value;
            return def;
        }

        svg.Property.prototype.numValueOrDefault = function(def) {
            if (this.hasValue()) return this.numValue();
            return def;
        }

        // color extensions
        // augment the current color value with the opacity
        svg.Property.prototype.addOpacity = function(opacityProp) {
            var newValue = this.value;
            if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
                var color = new RGBColor(this.value);
                if (color.ok) {
                    newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
                }
            }
            return new svg.Property(this.name, newValue);
        }

        // definition extensions
        // get the definition from the definitions table
        svg.Property.prototype.getDefinition = function() {
            var name = this.value.match(/#([^\)'"]+)/);
            if (name) { name = name[1]; }
            if (!name) { name = this.value; }
            return svg.Definitions[name];
        }

        svg.Property.prototype.isUrlDefinition = function() {
            return this.value.indexOf('url(') == 0
        }

        svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
            var def = this.getDefinition();

            // gradient
            if (def != null && def.createGradient) {
                return def.createGradient(svg.ctx, e, opacityProp);
            }

            // pattern
            if (def != null && def.createPattern) {
                if (def.getHrefAttribute().hasValue()) {
                    var pt = def.attribute('patternTransform');
                    def = def.getHrefAttribute().getDefinition();
                    if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
                }
                return def.createPattern(svg.ctx, e);
            }

            return null;
        }

        // length extensions
        svg.Property.prototype.getDPI = function(viewPort) {
            return 96.0; // TODO: compute?
        }

        svg.Property.prototype.getEM = function(viewPort) {
            var em = 12;

            var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
            if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

            return em;
        }

        svg.Property.prototype.getUnits = function() {
            var s = this.value+'';
            return s.replace(/[0-9\.\-]/g,'');
        }

        // get the length as pixels
        svg.Property.prototype.toPixels = function(viewPort, processPercent) {
            if (!this.hasValue()) return 0;
            var s = this.value+'';
            if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
            if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
            if (s.match(/px$/)) return this.numValue();
            if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
            if (s.match(/pc$/)) return this.numValue() * 15;
            if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
            if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
            if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
            if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
            var n = this.numValue();
            if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
            return n;
        }

        // time extensions
        // get the time as milliseconds
        svg.Property.prototype.toMilliseconds = function() {
            if (!this.hasValue()) return 0;
            var s = this.value+'';
            if (s.match(/s$/)) return this.numValue() * 1000;
            if (s.match(/ms$/)) return this.numValue();
            return this.numValue();
        }

        // angle extensions
        // get the angle as radians
        svg.Property.prototype.toRadians = function() {
            if (!this.hasValue()) return 0;
            var s = this.value+'';
            if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
            if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
            if (s.match(/rad$/)) return this.numValue();
            return this.numValue() * (Math.PI / 180.0);
        }

        // text extensions
        // get the text baseline
        var textBaselineMapping = {
            'baseline': 'alphabetic',
            'before-edge': 'top',
            'text-before-edge': 'top',
            'middle': 'middle',
            'central': 'middle',
            'after-edge': 'bottom',
            'text-after-edge': 'bottom',
            'ideographic': 'ideographic',
            'alphabetic': 'alphabetic',
            'hanging': 'hanging',
            'mathematical': 'alphabetic'
        };
        svg.Property.prototype.toTextBaseline = function () {
            if (!this.hasValue()) return null;
            return textBaselineMapping[this.value];
        }

        // fonts
        svg.Font = new (function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return {
                    fontFamily: fontFamily || f.fontFamily,
                    fontSize: fontSize || f.fontSize,
                    fontStyle: fontStyle || f.fontStyle,
                    fontWeight: fontWeight || f.fontWeight,
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
                }
            }

            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
                var ff = '';
                for (var i=0; i<d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
                    else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
                    else { if (d[i] != 'inherit') ff += d[i]; }
                } if (ff != '') f.fontFamily = ff;
                return f;
            }
        });

        // points and paths
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i=0; i<a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        }
        svg.Point.prototype.angleTo = function(p) {
            return Math.atan2(p.y - this.y, p.x - this.x);
        }

        svg.Point.prototype.applyTransform = function(v) {
            var xp = this.x * v[0] + this.y * v[2] + v[4];
            var yp = this.x * v[1] + this.y * v[3] + v[5];
            this.x = xp;
            this.y = yp;
        }

        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i=0; i<a.length; i+=2) {
                path.push(new svg.Point(a[i], a[i+1]));
            }
            return path;
        }

        // bounding box
        svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;

            this.x = function() { return this.x1; }
            this.y = function() { return this.y1; }
            this.width = function() { return this.x2 - this.x1; }
            this.height = function() { return this.y2 - this.y1; }

            this.addPoint = function(x, y) {
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) this.x1 = x;
                    if (x > this.x2) this.x2 = x;
                }

                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) this.y1 = y;
                    if (y > this.y2) this.y2 = y;
                }
            }
            this.addX = function(x) { this.addPoint(x, null); }
            this.addY = function(y) { this.addPoint(null, y); }

            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }

            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
                var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
                var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
            }

            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
                var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);

                for (i=0; i<=1; i++) {
                    var f = function(t) {
                        return Math.pow(1-t, 3) * p0[i]
                            + 3 * Math.pow(1-t, 2) * t * p1[i]
                            + 3 * (1-t) * Math.pow(t, 2) * p2[i]
                            + Math.pow(t, 3) * p3[i];
                    }

                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];

                    if (a == 0) {
                        if (b == 0) continue;
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) this.addX(f(t));
                            if (i == 1) this.addY(f(t));
                        }
                        continue;
                    }

                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) this.addX(f(t1));
                        if (i == 1) this.addY(f(t1));
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) this.addX(f(t2));
                        if (i == 1) this.addY(f(t2));
                    }
                }
            }

            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }

            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }

        // transforms
        svg.Transform = function(v) {
            var that = this;
            this.Type = {}

            // translate
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }

            // rotate
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }
            }

            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }
            }

            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.unapply = function(ctx) {
                    var a = this.m[0];
                    var b = this.m[2];
                    var c = this.m[4];
                    var d = this.m[1];
                    var e = this.m[3];
                    var f = this.m[5];
                    var g = 0.0;
                    var h = 0.0;
                    var i = 1.0;
                    var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
                    ctx.transform(
                        det*(e*i-f*h),
                        det*(f*g-d*i),
                        det*(c*h-b*i),
                        det*(a*i-c*g),
                        det*(b*f-c*e),
                        det*(c*d-a*f)
                    );
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }
            }

            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;

            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;

            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;

            this.transforms = [];

            this.apply = function(ctx) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }

            this.unapply = function(ctx) {
                for (var i=this.transforms.length-1; i>=0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            }

            this.applyToPoint = function(p) {
                for (var i=0; i<this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }

            var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
            for (var i=0; i<data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')','');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        }

        // aspect ratio
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

            // calculate scale
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
            if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            }
            else {
                // align
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
            }

            // scale
            if (align == 'none') ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
            else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

            // translate
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
        }

        // elements
        svg.Element = {}

        svg.EmptyProperty = new svg.Property('EMPTY', '');

        svg.Element.ElementBase = function(node) {
            this.attributes = {};
            this.styles = {};
            this.stylesSpecificity = {};
            this.children = [];

            // get or create attribute
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) return a;

                if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
                return a || svg.EmptyProperty;
            }

            this.getHrefAttribute = function() {
                for (var a in this.attributes) {
                    if (a == 'href' || a.match(/:href$/)) {
                        return this.attributes[a];
                    }
                }
                return svg.EmptyProperty;
            }

            // get or create style, crawls up node tree
            this.style = function(name, createIfNotExists, skipAncestors) {
                var s = this.styles[name];
                if (s != null) return s;

                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a; // move up to me to cache
                    return a;
                }

                if (skipAncestors != true) {
                    var p = this.parent;
                    if (p != null) {
                        var ps = p.style(name);
                        if (ps != null && ps.hasValue()) {
                            return ps;
                        }
                    }
                }

                if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
                return s || svg.EmptyProperty;
            }

            // base render
            this.render = function(ctx) {
                // don't render display=none
                if (this.style('display').value == 'none') return;

                // don't render visibility=hidden
                if (this.style('visibility').value == 'hidden') return;

                ctx.save();
                if (this.style('mask').hasValue()) { // mask
                    var mask = this.style('mask').getDefinition();
                    if (mask != null) mask.apply(ctx, this);
                }
                else if (this.style('filter').hasValue()) { // filter
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) filter.apply(ctx, this);
                }
                else {
                    this.setContext(ctx);
                    this.renderChildren(ctx);
                    this.clearContext(ctx);
                }
                ctx.restore();
            }

            // base set context
            this.setContext = function(ctx) {
                // OVERRIDE ME!
            }

            // base clear context
            this.clearContext = function(ctx) {
                // OVERRIDE ME!
            }

            // base render children
            this.renderChildren = function(ctx) {
                for (var i=0; i<this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }

            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) child = svg.CreateElement(childNode);
                child.parent = this;
                if (child.type != 'title') { this.children.push(child);	}
            }

            this.addStylesFromStyleDefinition = function () {
                // add styles
                for (var selector in svg.Styles) {
                    if (selector[0] != '@' && matchesSelector(node, selector)) {
                        var styles = svg.Styles[selector];
                        var specificity = svg.StylesSpecificity[selector];
                        if (styles != null) {
                            for (var name in styles) {
                                var existingSpecificity = this.stylesSpecificity[name];
                                if (typeof(existingSpecificity) == 'undefined') {
                                    existingSpecificity = '000';
                                }
                                if (specificity > existingSpecificity) {
                                    this.styles[name] = styles[name];
                                    this.stylesSpecificity[name] = specificity;
                                }
                            }
                        }
                    }
                }
            };

            if (node != null && node.nodeType == 1) { //ELEMENT_NODE
                // add attributes
                for (var i=0; i<node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
                }

                this.addStylesFromStyleDefinition();

                // add inline styles
                if (this.attribute('style').hasValue()) {
                    // Freegroup Patch
                    // canvg.js can't handle data:image/gif;base64,123NJABBGFR... data URL's
                    //           var styles = this.attribute('style').value.split(';');
                    var styles = this.attribute('style').value.split(new RegExp(";(?![^\\(]*\\))"));
                    // END PATCH
//                    var styles = this.attribute('style').value.split(';');
                    for (var i=0; i<styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            // FreeGroup Patch
                            // a CSS style can contain more than one ":". e.g. "background-image:data:image/gif;base64,R0lGODlhFAAUAPAAAP///+Dg8CH5);"
                            if (style.length > 2) {
                                style[1] = style.slice(1).join(':');
                                style.length = 2;
                            }
                            // end patch

                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }

                // add id
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }

                // add children
                for (var i=0; i<node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
                    if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
                        var text = childNode.value || childNode.text || childNode.textContent || '';
                        if (svg.compressSpaces(text) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
                        }
                    }
                }
            }
        }

        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.setContext = function(ctx) {
                // fill
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) ctx.fillStyle = fs;
                }
                else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
                    if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
                    ctx.fillStyle = fillStyle.value;
                }

                // stroke
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) ctx.strokeStyle = fs;
                }
                else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
                    if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
                }
                if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
                    else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
                    else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
                    else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
                    else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
                }

                // font
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont(
                        this.style('font-style').value,
                        this.style('font-variant').value,
                        this.style('font-weight').value,
                        this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
                        this.style('font-family').value).toString();
                }

                // transform
                if (this.style('transform', false, true).hasValue()) {
                    var transform = new svg.Transform(this.style('transform', false, true).value);
                    transform.apply(ctx);
                }

                // clip
                if (this.style('clip-path', false, true).hasValue()) {
                    var clip = this.style('clip-path', false, true).getDefinition();
                    if (clip != null) clip.apply(ctx);
                }

                // opacity
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.path = function(ctx) {
                if (ctx != null) ctx.beginPath();
                return new svg.BoundingBox();
            }

            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
                    else { ctx.fill(); }
                }
                if (ctx.strokeStyle != '') ctx.stroke();

                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i=1;i<markers.length-1;i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
                    }
                }
            }

            this.getBoundingBox = function() {
                return this.path();
            }

            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

        // svg element
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }

            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                // initial values and defaults
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4;
                if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
                    ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
                }

                this.baseSetContext(ctx);

                // create new view port
                if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
                if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();

                if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
                if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');

                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }

                    if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(width, y);
                        ctx.lineTo(width, height);
                        ctx.lineTo(x, height);
                        ctx.closePath();
                        ctx.clip();
                    }
                }
                svg.ViewPort.SetCurrent(width, height);

                // viewbox
                if (this.attribute('viewBox').hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];

                    svg.AspectRatio(ctx,
                        this.attribute('preserveAspectRatio').value,
                        svg.ViewPort.width(),
                        width,
                        svg.ViewPort.height(),
                        height,
                        minX,
                        minY,
                        this.attribute('refX').value,
                        this.attribute('refY').value);

                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

        // rect element
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y)
                    ctx.closePath();
                }

                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;

        // circle element
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();

                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
                    ctx.closePath();
                }

                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase;

        // ellipse element
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');

                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }

                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

        // line element
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            this.getPoints = function() {
                return [
                    new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
                    new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            }

            this.path = function(ctx) {
                var points = this.getPoints();

                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }

                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }

            this.getMarkers = function() {
                var points = this.getPoints();
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;

        // polyline element
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i=1; i<this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                return bb;
            }

            this.getMarkers = function() {
                var markers = [];
                for (var i=0; i<this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
                }
                markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
                return markers;
            }
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;

        // polygon element
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);

            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;

        // path element
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);

            var d = this.attribute('d').value;
            // TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
            d = d.replace(/,/gm,' '); // get rid of all commas
            // As the end of a match can also be the start of the next match, we need to run this replace twice.
            for(var i=0; i<2; i++)
                d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
            d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
            // Again, we need to run this twice to find all occurances
            for(var i=0; i<2; i++)
                d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
            d = svg.compressSpaces(d); // compress multiple spaces
            d = svg.trim(d);
            this.PathParser = new (function(d) {
                this.tokens = d.split(' ');

                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }

                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }

                this.isCommandOrEnd = function() {
                    if (this.isEnd()) return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }

                this.isRelativeCommand = function() {
                    switch(this.command)
                    {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                }

                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                }

                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }

                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }

                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }

                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }

                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;
                }

                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' &&
                        this.previousCommand.toLowerCase() != 's' &&
                        this.previousCommand.toLowerCase() != 'q' &&
                        this.previousCommand.toLowerCase() != 't' ){
                        return this.current;
                    }

                    // reflect point
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                    return p;
                }

                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                }

                this.addMarker = function(p, from, priorTo) {
                    // if the last angle isn't filled in because we didn't have this point yet ...
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
                        this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }

                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }

                this.getMarkerPoints = function() { return this.points; }
                this.getMarkerAngles = function() {
                    for (var i=0; i<this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j=i+1; j<this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);

            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();

                var bb = new svg.BoundingBox();
                if (ctx != null) ctx.beginPath();
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                        case 'M':
                        case 'm':
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) ctx.moveTo(p.x, p.y);
                            pp.start = pp.current;
                            while (!pp.isCommandOrEnd()) {
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, pp.start);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null) ctx.lineTo(p.x, p.y);
                            }
                            break;
                        case 'L':
                        case 'l':
                            while (!pp.isCommandOrEnd()) {
                                var c = pp.current;
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, c);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null) ctx.lineTo(p.x, p.y);
                            }
                            break;
                        case 'H':
                        case 'h':
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                            }
                            break;
                        case 'V':
                        case 'v':
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
                            }
                            break;
                        case 'C':
                        case 'c':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                            break;
                        case 'S':
                        case 's':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getReflectedControlPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                            break;
                        case 'Q':
                        case 'q':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                            break;
                        case 'T':
                        case 't':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getReflectedControlPoint();
                                pp.control = cntrl;
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                            }
                            break;
                        case 'A':
                        case 'a':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var rx = pp.getScalar();
                                var ry = pp.getScalar();
                                var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                                var largeArcFlag = pp.getScalar();
                                var sweepFlag = pp.getScalar();
                                var cp = pp.getAsCurrentPoint();

                                // Conversion from endpoint to center parameterization
                                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
                                // x1', y1'
                                var currp = new svg.Point(
                                    Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
                                    -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
                                );
                                // adjust radii
                                var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
                                if (l > 1) {
                                    rx *= Math.sqrt(l);
                                    ry *= Math.sqrt(l);
                                }
                                // cx', cy'
                                var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
                                        ((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
                                        (Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
                                    );
                                if (isNaN(s)) s = 0;
                                var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                                // cx, cy
                                var centp = new svg.Point(
                                    (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
                                    (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
                                );
                                // vector magnitude
                                var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
                                // ratio between two vectors
                                var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
                                // angle between two vectors
                                var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
                                // initial angle
                                var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
                                // angle delta
                                var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
                                var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
                                var ad = a(u, v);
                                if (r(u,v) <= -1) ad = Math.PI;
                                if (r(u,v) >= 1) ad = 0;

                                // for markers
                                var dir = 1 - sweepFlag ? 1.0 : -1.0;
                                var ah = a1 + dir * (ad / 2.0);
                                var halfWay = new svg.Point(
                                    centp.x + rx * Math.cos(ah),
                                    centp.y + ry * Math.sin(ah)
                                );
                                pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                                pp.addMarkerAngle(cp, ah - dir * Math.PI);

                                bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
                                if (ctx != null) {
                                    var r = rx > ry ? rx : ry;
                                    var sx = rx > ry ? 1 : rx / ry;
                                    var sy = rx > ry ? ry / rx : 1;

                                    ctx.translate(centp.x, centp.y);
                                    ctx.rotate(xAxisRotation);
                                    ctx.scale(sx, sy);
                                    ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                    ctx.scale(1/sx, 1/sy);
                                    ctx.rotate(-xAxisRotation);
                                    ctx.translate(-centp.x, -centp.y);
                                }
                            }
                            break;
                        case 'Z':
                        case 'z':
                            if (ctx != null) ctx.closePath();
                            pp.current = pp.start;
                    }
                }

                return bb;
            }

            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();

                var markers = [];
                for (var i=0; i<points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;

        // pattern element
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);

                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;

                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                // render 3x3 grid so when we transform there's no white space on edges
                for (var x=-1; x<=1; x++) {
                    for (var y=-1; y<=1; y++) {
                        cctx.save();
                        tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
                        tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;

        // marker element
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();

                // render me using a temporary svg element
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);

                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;

        // definitions element
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NOOP
            }
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;

        // base for gradients
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.stops = [];
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') this.stops.push(child);
            }

            this.getGradient = function() {
                // OVERRIDE ME!
            }

            this.gradientUnits = function () {
                return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            }

            this.attributesToInherit = ['gradientUnits'];

            this.inheritStopContainer = function (stopsContainer) {
                for (var i=0; i<this.attributesToInherit.length; i++) {
                    var attributeToInherit = this.attributesToInherit[i];
                    if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
                        this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
                    }
                }
            }

            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                    this.inheritStopContainer(stopsContainer);
                }

                var addParentOpacity = function (color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp).value;
                    }
                    return color;
                };

                var g = this.getGradient(ctx, element);
                if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                for (var i=0; i<stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }

                if (this.attribute('gradientTransform').hasValue()) {
                    // render as transformed pattern on temporary canvas
                    var rootView = svg.ViewPort.viewPorts[0];

                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [ rect ];

                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [ group ];

                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);
                    return tempCtx.createPattern(c, 'no-repeat');
                }

                return g;
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

        // linear gradient element
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);

            this.attributesToInherit.push('x1');
            this.attributesToInherit.push('y1');
            this.attributesToInherit.push('x2');
            this.attributesToInherit.push('y2');

            this.getGradient = function(ctx, element) {
                var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

                if (!this.attribute('x1').hasValue()
                    && !this.attribute('y1').hasValue()
                    && !this.attribute('x2').hasValue()
                    && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                }

                var x1 = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.x() + bb.width() * this.attribute('x1').numValue()
                    : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.y() + bb.height() * this.attribute('y1').numValue()
                    : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.x() + bb.width() * this.attribute('x2').numValue()
                    : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.y() + bb.height() * this.attribute('y2').numValue()
                    : this.attribute('y2').toPixels('y'));

                if (x1 == x2 && y1 == y2) return null;
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

        // radial gradient element
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);

            this.attributesToInherit.push('cx');
            this.attributesToInherit.push('cy');
            this.attributesToInherit.push('r');
            this.attributesToInherit.push('fx');
            this.attributesToInherit.push('fy');

            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();

                if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
                if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
                if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

                var cx = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.x() + bb.width() * this.attribute('cx').numValue()
                    : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits() == 'objectBoundingBox'
                    ? bb.y() + bb.height() * this.attribute('cy').numValue()
                    : this.attribute('cy').toPixels('y'));

                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits() == 'objectBoundingBox'
                        ? bb.x() + bb.width() * this.attribute('fx').numValue()
                        : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits() == 'objectBoundingBox'
                        ? bb.y() + bb.height() * this.attribute('fy').numValue()
                        : this.attribute('fy').toPixels('y'));
                }

                var r = (this.gradientUnits() == 'objectBoundingBox'
                    ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
                    : this.attribute('r').toPixels());

                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

        // gradient stop element
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) this.offset = 0;
            if (this.offset > 1) this.offset = 1;

            var stopColor = this.style('stop-color', true);
            if (stopColor.value === '') stopColor.value = '#000';
            if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;

        // animation base element
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            svg.Animations.push(this);

            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;

                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);
            };

            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;

            this.calcValue = function() {
                // OVERRIDE ME!
                return '';
            }

            this.update = function(delta) {
                // set initial value
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }

                // if we're past the end time
                if (this.duration > this.maxDuration) {
                    // loop for indefinitely repeating animations
                    if (this.attribute('repeatCount').value == 'indefinite'
                        || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
                        this.frozen = true;
                        this.parent.animationFrozen = true;
                        this.parent.animationFrozenValue = this.getProperty().value;
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
                        return true;
                    }
                    return false;
                }
                this.duration = this.duration + delta;

                // if we're past the begin time
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue(); // tween

                    if (this.attribute('type').hasValue()) {
                        // for transform, etc.
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }

                    this.getProperty().value = newValue;
                    updated = true;
                }

                return updated;
            }

            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) this.values.value = this.values.value.split(';');

            // fraction of duration we've covered
            this.progress = function() {
                var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p), ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                }
                else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }
        }
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

        // animate element
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();

                // tween value linearly
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
                return newValue + this.initialUnits;
            };
        }
        svg.Element.animate.prototype = new svg.Element.AnimateBase;

        // animate color element
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);

                if (from.ok && to.ok) {
                    // tween color linearly
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
                }
                return this.attribute('from').value;
            };
        }
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

        // animate transform element
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);

            this.calcValue = function() {
                var p = this.progress();

                // tween value linearly
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i=0; i<from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        }
        svg.Element.animateTransform.prototype = new svg.Element.animate;

        // font element
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();

            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];
            for (var i=0; i<this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                }
                else if (child.type == 'missing-glyph') this.missingGlyph = child;
                else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    }
                    else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;

        // font-face element
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;

        // missing-glyph element
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);

            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;

        // glyph element
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);

            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;

        // text element
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);

                var textBaseline = this.style('dominant-baseline').toTextBaseline();
                if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
                if (textBaseline != null) ctx.textBaseline = textBaseline;
            }

            this.getBoundingBox = function () {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
            }

            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
                if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i=0; i<this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            }

            this.getAnchorDelta = function (ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i=startI; i<parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) break; // new group
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            }

            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);
                    if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
                }
                else {
                    if (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');
                    child.x = parent.x;
                }
                parent.x = child.x + child.measureText(ctx);

                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                    if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
                }
                else {
                    if (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');
                    child.y = parent.y;
                }
                parent.y = child.y;

                child.render(ctx);

                for (var i=0; i<child.children.length; i++) {
                    parent.renderChild(ctx, child, i);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;

        // text base
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
                    if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
                    if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
                    }
                }
                else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) glyph = font.missingGlyph;
                return glyph;
            }

            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");

                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1/scale, -1/scale);
                        ctx.translate(-this.x, -this.y);

                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }

                if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
            }

            this.getText = function() {
                // OVERRIDE ME
            }

            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i=0; i<this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            }

            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i=0; i<text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }

                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) return textToMeasure.length * 10;

                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

        // tspan
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);

            this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
            this.getText = function() {
                // if this node has children, then they own the text
                if (this.children.length > 0) { return ''; }
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;

        // tref
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);

            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) return element.children[0].getText();
            }
        }
        svg.Element.tref.prototype = new svg.Element.TextElementBase;

        // a element
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);

            this.hasText = node.childNodes.length > 0;
            for (var i=0; i<node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) this.hasText = false;
            }

            // this might contain text
            this.text = this.hasText ? node.childNodes[0].value : '';
            this.getText = function() {
                return this.text;
            }

            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    // render as text element
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
                }
                else if (this.children.length > 0) {
                    // render as temporary group
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            }

            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            }

            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        }
        svg.Element.a.prototype = new svg.Element.TextElementBase;

        // image element
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            var href = this.getHrefAttribute().value;
            if (href == '') { return; }
            var isSvg = href.match(/\.svg$/)

            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
                var self = this;
                this.img.onload = function() { self.loaded = true; }
                this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
                this.img.src = href;
            }
            else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }

            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');

                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                if (width == 0 || height == 0) return;

                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                }
                else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx,
                        this.attribute('preserveAspectRatio').value,
                        width,
                        this.img.width,
                        height,
                        this.img.height,
                        0,
                        0);
                    ctx.drawImage(this.img, 0, 0);
                }
                ctx.restore();
            }

            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;

        // group element
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i=0; i<this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;

        // symbol element
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.render = function(ctx) {
                // NO RENDER
            };
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

        // style element
        svg.Element.style = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            // text, or spaces then CDATA
            var css = ''
            for (var i=0; i<node.childNodes.length; i++) {
                css += node.childNodes[i].data;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
            css = svg.compressSpaces(css); // replace whitespace
            var cssDefs = css.split('}');
            for (var i=0; i<cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j=0; j<cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = svg.Styles[cssClass] || {};
                            for (var k=0; k<cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g,'');
                                var srcs = props['src'].value.split(',');
                                for (var s=0; s<srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")') > 0) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f=0; f<fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;

        // use element
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);

            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
                if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
            }

            var element = this.getHrefAttribute().getDefinition();

            this.path = function(ctx) {
                if (element != null) element.path(ctx);
            }

            this.getBoundingBox = function() {
                if (element != null) return element.getBoundingBox();
            }

            this.renderChildren = function(ctx) {
                if (element != null) {
                    var tempSvg = element;
                    if (element.type == 'symbol') {
                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
                        tempSvg = new svg.Element.svg();
                        tempSvg.type = 'svg';
                        tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
                        tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
                        tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
                        tempSvg.children = element.children;
                    }
                    if (tempSvg.type == 'svg') {
                        // if symbol or svg, inherit width/height from me
                        if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                        if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                    }
                    var oldParent = tempSvg.parent;
                    tempSvg.parent = null;
                    tempSvg.render(ctx);
                    tempSvg.parent = oldParent;
                }
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;

        // mask element
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.apply = function(ctx, element) {
                // render as temp svg
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');

                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i=0; i<this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var	height = Math.floor(bb.height());
                }

                // temporarily remove mask to avoid recursion
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';

                var cMask = document.createElement('canvas');
                cMask.width = x + width;
                cMask.height = y + height;
                var maskCtx = cMask.getContext('2d');
                this.renderChildren(maskCtx);

                var c = document.createElement('canvas');
                c.width = x + width;
                c.height = y + height;
                var tempCtx = c.getContext('2d');
                element.render(tempCtx);
                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                tempCtx.fillRect(0, 0, x + width, y + height);

                ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                ctx.fillRect(0, 0, x + width, y + height);

                // reassign mask
                element.attribute('mask').value = mask;
            }

            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;

        // clip element
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.apply = function(ctx) {
                var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
                CanvasRenderingContext2D.prototype.beginPath = function () { };

                var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
                CanvasRenderingContext2D.prototype.closePath = function () { };

                oldBeginPath.call(ctx);
                for (var i=0; i<this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.style('transform', false, true).hasValue()) {
                            transform = new svg.Transform(child.style('transform', false, true).value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        CanvasRenderingContext2D.prototype.closePath = oldClosePath;
                        if (transform) { transform.unapply(ctx); }
                    }
                }
                oldClosePath.call(ctx);
                ctx.clip();

                CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
                CanvasRenderingContext2D.prototype.closePath = oldClosePath;
            }

            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;

        // filters
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.apply = function(ctx, element) {
                // render as temp svg
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var	height = Math.floor(bb.height());

                // temporarily remove filter to avoid recursion
                var filter = element.style('filter').value;
                element.style('filter').value = '';

                var px = 0, py = 0;
                for (var i=0; i<this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }

                var c = document.createElement('canvas');
                c.width = width + 2*px;
                c.height = height + 2*py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);

                // apply filters
                for (var i=0; i<this.children.length; i++) {
                    if (typeof(this.children[i].apply) === 'function') {
                        this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
                    }
                }

                // render on me
                ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

                // reassign filter
                element.style('filter', true).value = filter;
            }

            this.render = function(ctx) {
                // NO RENDER
            }
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;

        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

        svg.Element.feComposite = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.apply = function(ctx, x, y, width, height) {
                // TODO: implement
            }
        }
        svg.Element.feComposite.prototype = new svg.Element.ElementBase;

        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            var matrix = svg.ToNumberArray(this.attribute('values').value);
            switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
                case 'saturate':
                    var s = matrix[0];
                    matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
                        0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
                        0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
                        0,0,0,1,0,
                        0,0,0,0,1];
                    break;
                case 'hueRotate':
                    var a = matrix[0] * Math.PI / 180.0;
                    var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
                    matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
                        c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
                        c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
                        0,0,0,1,0,
                        0,0,0,0,1];
                    break;
                case 'luminanceToAlpha':
                    matrix = [0,0,0,0,0,
                        0,0,0,0,0,
                        0,0,0,0,0,
                        0.2125,0.7154,0.0721,0,0,
                        0,0,0,0,1];
                    break;
            }

            function imGet(img, x, y, width, height, rgba) {
                return img[y*width*4 + x*4 + rgba];
            }

            function imSet(img, x, y, width, height, rgba, val) {
                img[y*width*4 + x*4 + rgba] = val;
            }

            function m(i, v) {
                var mi = matrix[i];
                return mi * (mi < 0 ? v - 255 : v);
            }

            this.apply = function(ctx, x, y, width, height) {
                // assuming x==0 && y==0 for now
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var a = imGet(srcData.data, x, y, width, height, 3);
                        imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
                        imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
                        imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
                        imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        }
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;

            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlur.canvasRGBA) == 'undefined') {
                    svg.log('ERROR: StackBlur.js must be included for blur to work');
                    return;
                }

                // StackBlur requires canvas be on document
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        }
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

        // title element, do nothing
        svg.Element.title = function(node) {
        }
        svg.Element.title.prototype = new svg.Element.ElementBase;

        // desc element, do nothing
        svg.Element.desc = function(node) {
        }
        svg.Element.desc.prototype = new svg.Element.ElementBase;

        svg.Element.MISSING = function(node) {
            svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;

        // element factory
        svg.CreateElement = function(node) {
            var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
            className = className.replace(/\-/g,''); // remove dashes
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            }
            else {
                e = new svg.Element.MISSING(node);
            }

            e.type = node.nodeName;
            return e;
        }

        // load from url
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }

        // load from xml
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        }

        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);

            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) p.x += window.scrollX;
                if (window.scrollY) p.y += window.scrollY;
                return p;
            }

            // bind mouse
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }

            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
            e.addStylesFromStyleDefinition();

            // render loop
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

                if (svg.opts['ignoreDimensions'] != true) {
                    // set canvas size
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);

                if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
                if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
                if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
                    var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

                    if (svg.opts['scaleWidth'] != null) {
                        if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                        else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    }

                    if (svg.opts['scaleHeight'] != null) {
                        if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                        else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    }

                    if (xRatio == null) { xRatio = yRatio; }
                    if (yRatio == null) { yRatio = xRatio; }

                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];
                    e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
                }

                // clear and render
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
                }
            }

            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() {
                var needUpdate = false;

                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }

                // need update from mouse events?
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }

                // need update from animations?
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i=0; i<svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }

                // need update from redraw?
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) needUpdate = true;
                }

                // render if needed
                if (needUpdate) {
                    draw();
                    svg.Mouse.runEvents(); // run and clear our events
                }

                // FREEGROUP Patch
                // canvg didn't stop the interval is we didn't need the animation. In this case
                // the DOM tree isn't cleanup correct. Memory Leak
                // Reported by Michael Norgate 16.04.2015
                //
                if (svg.opts['ignoreAnimation']===true || isFirstRender===false && waitingForImages===false) {
                    svg.stop();
                }
            }, 1000 / svg.FRAMERATE);
        }

        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        }

        svg.Mouse = new (function() {
            this.events = [];
            this.hasEvents = function() { return this.events.length != 0; }

            this.onclick = function(x, y) {
                this.events.push({ type: 'onclick', x: x, y: y,
                    run: function(e) { if (e.onclick) e.onclick(); }
                });
            }

            this.onmousemove = function(x, y) {
                this.events.push({ type: 'onmousemove', x: x, y: y,
                    run: function(e) { if (e.onmousemove) e.onmousemove(); }
                });
            }

            this.eventElements = [];

            this.checkPath = function(element, ctx) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
                }
            }

            this.checkBoundingBox = function(element, bb) {
                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
                }
            }

            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';

                for (var i=0; i<this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }

                // done running, clear
                this.events = [];
                this.eventElements = [];
            }
        });

        return svg;
    };

    if (typeof(CanvasRenderingContext2D) != 'undefined') {
        CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
            canvg(this.canvas, s, {
                ignoreMouse: true,
                ignoreAnimation: true,
                ignoreDimensions: true,
                ignoreClear: true,
                offsetX: dx,
                offsetY: dy,
                scaleWidth: dw,
                scaleHeight: dh
            });
        }
    }

    return canvg;

}));
;
/* 
 * Simple JavaScript Inheritance 
 * By John Resig http://ejohn.org/ 
 * MIT Licensed. 
 * 
 ****************************************************** 
 * Example Usage 
 ****************************************************** 
 var Person = Class.extend({ 
  init: function(isDancing){ 
    this.dancing = isDancing; 
  }, 
  dance: function(){ 
    return this.dancing; 
  } 
}); 

var Ninja = Person.extend({ 
  init: function(){ 
    this._super( false ); 
  }, 
  dance: function(){ 
    // Call the inherited version of dance() 
    return this._super(); 
  }, 
  swingSword: function(){ 
    return true; 
  } 
}); 

var p = new Person(true); 
p.dance(); // => true 

var n = new Ninja(); 
n.dance(); // => false 
n.swingSword(); // => true 

// Should all be true 
p instanceof Person && p instanceof Class && 
n instanceof Ninja && n instanceof Person && n instanceof Class 

 ****************************************************** 
 */ 
  
// Inspired by base2 and Prototype 
(function(){ 
  var fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/; 

  // The base Class implementation (does nothing) 
  this.Class = function(){}; 
  

  // Create a new Class that inherits from this class 
  Class.extend = function(prop) { 
    var _super = this.prototype; 
    
    // Instantiate a base class (but only create the instance, 
    // don't run the init constructor) 
    initializing = true; 
    var prototype = new this(); 
    initializing = false; 
    
     
    // Copy the properties over onto the new prototype 
    for (var name in prop) { 
      // Check if we're overwriting an existing function 
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ? 
        (function(name, fn){ 
          return function() { 
            var tmp = this._super; 
            
            // Add a new ._super() method that is the same method 
            // but on the super-class 
            this._super = _super[name]; 
            
            // The method only need to be bound temporarily, so we 
            // remove it when we're done executing 
            var ret = fn.apply(this, arguments);        
            this._super = tmp; 
            
            return ret; 
          }; 
        })(name, prop[name]) : 
        prop[name]; 
    } 
    
    // The dummy class constructor 
    function Class() { 
      // All construction is actually done in the init method 
      if ( !initializing && this.init ) 
        this.init.apply(this, arguments); 
    } 
    
    // Populate our constructed prototype object 
    Class.prototype = prototype; 
    
    // Enforce the constructor to be what we expect 
    Class.prototype.constructor = Class; 

    // And make this class extendable 
    Class.extend = arguments.callee; 
    
    // EXTENSION BY Draw2D.org to inject methods into an existing class to provide plugins or 
    // bugfixes for further releases 
    // 
    Class.inject = function (prop) { 
        var proto = this.prototype; 
        var parent = {}; 
        for (var name in prop) { 
            if (typeof (prop[name]) == "function" && typeof (proto[name]) == "function" && fnTest.test(prop[name])) { 
                parent[name] = proto[name]; 
                proto[name] = (function (name, fn) { 
                    return function () { 
                        var tmp = this.parent; 
                        this.parent = parent[name]; 
                        var ret = fn.apply(this, arguments); 
                        this.parent = tmp; 
                        return ret; 
                    }; 
                })(name, prop[name]); 
            } else { 
                proto[name] = prop[name]; 
            } 
        } 
    }; 
     
    return Class; 
  }; 
})();
 
 
;
/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

;
var PF=function(){var e=function(t,n){var r=e.resolve(t,n||"/"),i=e.modules[r];if(!i)throw new Error("Failed to resolve module "+t+", tried "+r);var s=i._cached?i._cached:i();return s};return e.paths=[],e.modules={},e.extensions=[".js",".coffee"],e._core={assert:!0,events:!0,fs:!0,path:!0,vm:!0},e.resolve=function(){return function(t,n){function u(t){if(e.modules[t])return t;for(var n=0;n<e.extensions.length;n++){var r=e.extensions[n];if(e.modules[t+r])return t+r}}function a(t){t=t.replace(/\/+$/,"");var n=t+"/package.json";if(e.modules[n]){var i=e.modules[n](),s=i.browserify;if(typeof s=="object"&&s.main){var o=u(r.resolve(t,s.main));if(o)return o}else if(typeof s=="string"){var o=u(r.resolve(t,s));if(o)return o}else if(i.main){var o=u(r.resolve(t,i.main));if(o)return o}}return u(t+"/index")}function f(e,t){var n=l(t);for(var r=0;r<n.length;r++){var i=n[r],s=u(i+"/"+e);if(s)return s;var o=a(i+"/"+e);if(o)return o}var s=u(e);if(s)return s}function l(e){var t;e==="/"?t=[""]:t=r.normalize(e).split("/");var n=[];for(var i=t.length-1;i>=0;i--){if(t[i]==="node_modules")continue;var s=t.slice(0,i+1).join("/")+"/node_modules";n.push(s)}return n}n||(n="/");if(e._core[t])return t;var r=e.modules.path();n=r.resolve("/",n);var i=n||"/";if(t.match(/^(?:\.\.?\/|\/)/)){var s=u(r.resolve(i,t))||a(r.resolve(i,t));if(s)return s}var o=f(t,i);if(o)return o;throw new Error("Cannot find module '"+t+"'")}}(),e.alias=function(t,n){var r=e.modules.path(),i=null;try{i=e.resolve(t+"/package.json","/")}catch(s){i=e.resolve(t,"/")}var o=r.dirname(i),u=(Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t})(e.modules);for(var a=0;a<u.length;a++){var f=u[a];if(f.slice(0,o.length+1)===o+"/"){var l=f.slice(o.length);e.modules[n+l]=e.modules[o+l]}else f===o&&(e.modules[n]=e.modules[o])}},e.define=function(t,n){var r=e._core[t]?"":e.modules.path().dirname(t),i=function(t){return e(t,r)};i.resolve=function(t){return e.resolve(t,r)},i.modules=e.modules,i.define=e.define;var s={exports:{}};e.modules[t]=function(){return e.modules[t]._cached=s.exports,n.call(s.exports,i,s,s.exports,r,t),e.modules[t]._cached=s.exports,s.exports}},typeof process=="undefined"&&(process={}),process.nextTick||(process.nextTick=function(){var e=[],t=typeof window!="undefined"&&window.postMessage&&window.addEventListener;return t&&window.addEventListener("message",function(t){if(t.source===window&&t.data==="browserify-tick"){t.stopPropagation();if(e.length>0){var n=e.shift();n()}}},!0),function(n){t?(e.push(n),window.postMessage("browserify-tick","*")):setTimeout(n,0)}}()),process.title||(process.title="browser"),process.binding||(process.binding=function(t){if(t==="evals")return e("vm");throw new Error("No such module")}),process.cwd||(process.cwd=function(){return"."}),process.env||(process.env={}),process.argv||(process.argv=[]),e.define("path",function(e,t,n,r,i){function s(e,t){var n=[];for(var r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}function o(e,t){var n=0;for(var r=e.length;r>=0;r--){var i=e[r];i=="."?e.splice(r,1):i===".."?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n--;n)e.unshift("..");return e}var u=/^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;n.resolve=function(){var e="",t=!1;for(var n=arguments.length;n>=-1&&!t;n--){var r=n>=0?arguments[n]:process.cwd();if(typeof r!="string"||!r)continue;e=r+"/"+e,t=r.charAt(0)==="/"}return e=o(s(e.split("/"),function(e){return!!e}),!t).join("/"),(t?"/":"")+e||"."},n.normalize=function(e){var t=e.charAt(0)==="/",n=e.slice(-1)==="/";return e=o(s(e.split("/"),function(e){return!!e}),!t).join("/"),!e&&!t&&(e="."),e&&n&&(e+="/"),(t?"/":"")+e},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(s(e,function(e,t){return e&&typeof e=="string"}).join("/"))},n.dirname=function(e){var t=u.exec(e)[1]||"",n=!1;return t?t.length===1||n&&t.length<=3&&t.charAt(1)===":"?t:t.substring(0,t.length-1):"."},n.basename=function(e,t){var n=u.exec(e)[2]||"";return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n},n.extname=function(e){return u.exec(e)[3]||""}}),e.define("/core/Node.js",function(e,t,n,r,i){function s(e,t,n){this.x=e,this.y=t,this.walkable=n===undefined?!0:n}t.exports=s}),e.define("/core/Grid.js",function(e,t,n,r,i){function o(e,t,n){this.width=e,this.height=t,this.nodes=this._buildNodes(e,t,n)}var s=e("./Node");o.prototype._buildNodes=function(e,t,n){var r,i,o=new Array(t),u;for(r=0;r<t;++r){o[r]=new Array(e);for(i=0;i<e;++i)o[r][i]=new s(i,r)}if(n===undefined)return o;if(n.length!==t||n[0].length!==e)throw new Error("Matrix size does not fit");for(r=0;r<t;++r)for(i=0;i<e;++i)n[r][i]&&(o[r][i].walkable=!1);return o},o.prototype.getNodeAt=function(e,t){return this.nodes[t][e]},o.prototype.isWalkableAt=function(e,t){return this.isInside(e,t)&&this.nodes[t][e].walkable},o.prototype.isInside=function(e,t){return e>=0&&e<this.width&&t>=0&&t<this.height},o.prototype.setWalkableAt=function(e,t,n){this.nodes[t][e].walkable=n},o.prototype.getNeighbors=function(e,t,n){var r=e.x,i=e.y,s=[],o=!1,u=!1,a=!1,f=!1,l=!1,c=!1,h=!1,p=!1,d=this.nodes;return this.isWalkableAt(r,i-1)&&(s.push(d[i-1][r]),o=!0),this.isWalkableAt(r+1,i)&&(s.push(d[i][r+1]),a=!0),this.isWalkableAt(r,i+1)&&(s.push(d[i+1][r]),l=!0),this.isWalkableAt(r-1,i)&&(s.push(d[i][r-1]),h=!0),t?(n?(u=h&&o,f=o&&a,c=a&&l,p=l&&h):(u=h||o,f=o||a,c=a||l,p=l||h),u&&this.isWalkableAt(r-1,i-1)&&s.push(d[i-1][r-1]),f&&this.isWalkableAt(r+1,i-1)&&s.push(d[i-1][r+1]),c&&this.isWalkableAt(r+1,i+1)&&s.push(d[i+1][r+1]),p&&this.isWalkableAt(r-1,i+1)&&s.push(d[i+1][r-1]),s):s},o.prototype.clone=function(){var e,t,n=this.width,r=this.height,i=this.nodes,u=new o(n,r),a=new Array(r),f;for(e=0;e<r;++e){a[e]=new Array(n);for(t=0;t<n;++t)a[e][t]=new s(t,e,i[e][t].walkable)}return u.nodes=a,u},t.exports=o}),e.define("/core/Heap.js",function(e,t,n,r,i){(function(){var e,n,r,i,s,o,u,a,f,l,c,h,p,d,v;r=Math.floor,l=Math.min,n=function(e,t){return e<t?-1:e>t?1:0},f=function(e,t,i,s,o){var u;i==null&&(i=0),o==null&&(o=n);if(i<0)throw new Error("lo must be non-negative");s==null&&(s=e.length);while(o(i,s)<0)u=r((i+s)/2),o(t,e[u])<0?s=u:i=u+1;return[].splice.apply(e,[i,i-i].concat(t)),t},o=function(e,t,r){return r==null&&(r=n),e.push(t),d(e,0,e.length-1,r)},s=function(e,t){var r,i;return t==null&&(t=n),r=e.pop(),e.length?(i=e[0],e[0]=r,v(e,0,t)):i=r,i},a=function(e,t,r){var i;return r==null&&(r=n),i=e[0],e[0]=t,v(e,0,r),i},u=function(e,t,r){var i;return r==null&&(r=n),e.length&&r(e[0],t)<0&&(i=[e[0],t],t=i[0],e[0]=i[1],v(e,0,r)),t},i=function(e,t){var i,s,o,u,a,f,l,c;t==null&&(t=n),f=function(){c=[];for(var t=0,n=r(e.length/2);0<=n?t<n:t>n;0<=n?t++:t--)c.push(t);return c}.apply(this).reverse(),l=[];for(s=0,u=f.length;s<u;s++)i=f[s],l.push(v(e,i,t));return l},p=function(e,t,r){var i;return r==null&&(r=n),i=e.indexOf(t),d(e,0,i,r),v(e,i,r)},c=function(e,t,r){var s,o,a,f,l;r==null&&(r=n),o=e.slice(0,t);if(!o.length)return o;i(o,r),l=e.slice(t);for(a=0,f=l.length;a<f;a++)s=l[a],u(o,s,r);return o.sort(r).reverse()},h=function(e,t,r){var o,u,a,c,h,p,d,v,m,g;r==null&&(r=n);if(t*10<=e.length){c=e.slice(0,t).sort(r);if(!c.length)return c;a=c[c.length-1],v=e.slice(t);for(h=0,d=v.length;h<d;h++)o=v[h],r(o,a)<0&&(f(c,o,0,null,r),c.pop(),a=c[c.length-1]);return c}i(e,r),g=[];for(u=p=0,m=l(t,e.length);0<=m?p<m:p>m;u=0<=m?++p:--p)g.push(s(e,r));return g},d=function(e,t,r,i){var s,o,u;i==null&&(i=n),s=e[r];while(r>t){u=r-1>>1,o=e[u];if(i(s,o)<0){e[r]=o,r=u;continue}break}return e[r]=s},v=function(e,t,r){var i,s,o,u,a;r==null&&(r=n),s=e.length,a=t,o=e[t],i=2*t+1;while(i<s)u=i+1,u<s&&!(r(e[i],e[u])<0)&&(i=u),e[t]=e[i],t=i,i=2*t+1;return e[t]=o,d(e,a,t,r)},e=function(){function e(e){this.cmp=e!=null?e:n,this.nodes=[]}return e.name="Heap",e.push=o,e.pop=s,e.replace=a,e.pushpop=u,e.heapify=i,e.nlargest=c,e.nsmallest=h,e.prototype.push=function(e){return o(this.nodes,e,this.cmp)},e.prototype.pop=function(){return s(this.nodes,this.cmp)},e.prototype.peek=function(){return this.nodes[0]},e.prototype.contains=function(e){return this.nodes.indexOf(e)!==-1},e.prototype.replace=function(e){return a(this.nodes,e,this.cmp)},e.prototype.pushpop=function(e){return u(this.nodes,e,this.cmp)},e.prototype.heapify=function(){return i(this.nodes,this.cmp)},e.prototype.updateItem=function(e){return p(this.nodes,e,this.cmp)},e.prototype.clear=function(){return this.nodes=[]},e.prototype.empty=function(){return this.nodes.length===0},e.prototype.size=function(){return this.nodes.length},e.prototype.clone=function(){var t;return t=new e,t.nodes=this.nodes.slice(0),t},e.prototype.toArray=function(){return this.nodes.slice(0)},e.prototype.insert=e.prototype.push,e.prototype.remove=e.prototype.pop,e.prototype.top=e.prototype.peek,e.prototype.front=e.prototype.peek,e.prototype.has=e.prototype.contains,e.prototype.copy=e.prototype.clone,e}(),(typeof t!="undefined"&&t!==null?t.exports:void 0)?t.exports=e:window.Heap=e}).call(this)}),e.define("/core/Util.js",function(e,t,n,r,i){function s(e){var t=[[e.x,e.y]];while(e.parent)e=e.parent,t.push([e.x,e.y]);return t.reverse()}function o(e,t){var n=s(e),r=s(t);return n.concat(r.reverse())}function u(e){var t,n=0,r,i,s,o;for(t=1;t<e.length;++t)r=e[t-1],i=e[t],s=r[0]-i[0],o=r[1]-i[1],n+=Math.sqrt(s*s+o*o);return n}function a(e,t,n,r){var i=Math.abs,s=[],o,u,a,f,l,c;a=i(n-e),f=i(r-t),o=e<n?1:-1,u=t<r?1:-1,l=a-f;for(;;){s.push([e,t]);if(e===n&&t===r)break;c=2*l,c>-f&&(l-=f,e+=o),c<a&&(l+=a,t+=u)}return s}function f(e,t){var n=t.length,r=t[0][0],i=t[0][1],s=t[n-1][0],o=t[n-1][1],u,f,l,c,h,p,d,v,m,g,y,b,w;u=r,f=i,h=t[1][0],p=t[1][1],d=[[u,f]];for(v=2;v<n;++v){g=t[v],l=g[0],c=g[1],y=a(u,f,l,c),w=!1;for(m=1;m<y.length;++m){b=y[m];if(!e.isWalkableAt(b[0],b[1])){w=!0,d.push([h,p]),u=h,f=p;break}}w||(h=l,p=c)}return d.push([s,o]),d}n.backtrace=s,n.biBacktrace=o,n.pathLength=u,n.getLine=a,n.smoothenPath=f}),e.define("/core/Heuristic.js",function(e,t,n,r,i){t.exports={manhattan:function(e,t){return e+t},euclidean:function(e,t){return Math.sqrt(e*e+t*t)},chebyshev:function(e,t){return Math.max(e,t)}}}),e.define("/finders/AStarFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=new s(function(e,t){return e.f-t.f}),a=i.getNodeAt(e,t),f=i.getNodeAt(n,r),l=this.heuristic,c=this.allowDiagonal,h=this.dontCrossCorners,p=Math.abs,d=Math.SQRT2,v,m,g,y,b,w,E,S;a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){v=u.pop(),v.closed=!0;if(v===f)return o.backtrace(f);m=i.getNeighbors(v,c,h);for(y=0,b=m.length;y<b;++y){g=m[y];if(g.closed)continue;w=g.x,E=g.y,S=v.g+(w-v.x===0||E-v.y===0?1:d);if(!g.opened||S<g.g)g.g=S,g.h=g.h||l(p(w-n),p(E-r)),g.f=g.g+g.h,g.parent=v,g.opened?u.updateItem(g):(u.push(g),g.opened=!0)}}return[]},t.exports=a}),e.define("/finders/BestFirstFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e("./AStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BreadthFirstFinder.js",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e("../core/Util");o.prototype.findPath=function(e,t,n,r,i){var o=[],u=this.allowDiagonal,a=this.dontCrossCorners,f=i.getNodeAt(e,t),l=i.getNodeAt(n,r),c,h,p,d,v;o.push(f),f.opened=!0;while(o.length){p=o.shift(),p.closed=!0;if(p===l)return s.backtrace(l);c=i.getNeighbors(p,u,a);for(d=0,v=c.length;d<v;++d){h=c[d];if(h.closed||h.opened)continue;o.push(h),h.opened=!0,h.parent=p}}return[]},t.exports=o}),e.define("/finders/DijkstraFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e("./AStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BiAStarFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=function(e,t){return e.f-t.f},a=new s(u),f=new s(u),l=i.getNodeAt(e,t),c=i.getNodeAt(n,r),h=this.heuristic,p=this.allowDiagonal,d=this.dontCrossCorners,v=Math.abs,m=Math.SQRT2,g,y,b,w,E,S,x,T,N=1,C=2;l.g=0,l.f=0,a.push(l),l.opened=N,c.g=0,c.f=0,f.push(c),c.opened=C;while(!a.empty()&&!f.empty()){g=a.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===C)return o.biBacktrace(g,b);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-n),v(x-r)),b.f=b.g+b.h,b.parent=g,b.opened?a.updateItem(b):(a.push(b),b.opened=N)}g=f.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===N)return o.biBacktrace(b,g);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-e),v(x-t)),b.f=b.g+b.h,b.parent=g,b.opened?f.updateItem(b):(f.push(b),b.opened=C)}}return[]},t.exports=a}),e.define("/finders/BiBestFirstFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e("./BiAStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/BiBreadthFirstFinder.js",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e("../core/Util");o.prototype.findPath=function(e,t,n,r,i){var o=i.getNodeAt(e,t),u=i.getNodeAt(n,r),a=[],f=[],l,c,h,p=this.allowDiagonal,d=this.dontCrossCorners,v=0,m=1,g,y;a.push(o),o.opened=!0,o.by=v,f.push(u),u.opened=!0,u.by=m;while(a.length&&f.length){h=a.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===m)return s.biBacktrace(h,c);continue}a.push(c),c.parent=h,c.opened=!0,c.by=v}h=f.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===v)return s.biBacktrace(c,h);continue}f.push(c),c.parent=h,c.opened=!0,c.by=m}}return[]},t.exports=o}),e.define("/finders/BiDijkstraFinder.js",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e("./BiAStarFinder");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define("/finders/JumpPointFinder.js",function(e,t,n,r,i){function a(e){e=e||{},this.heuristic=e.heuristic||u.manhattan}var s=e("../core/Heap"),o=e("../core/Util"),u=e("../core/Heuristic");a.prototype.findPath=function(e,t,n,r,i){var u=this.openList=new s(function(e,t){return e.f-t.f}),a=this.startNode=i.getNodeAt(e,t),f=this.endNode=i.getNodeAt(n,r),l;this.grid=i,a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){l=u.pop(),l.closed=!0;if(l===f)return o.backtrace(f);this._identifySuccessors(l)}return[]},a.prototype._identifySuccessors=function(e){var t=this.grid,n=this.heuristic,r=this.openList,i=this.endNode.x,s=this.endNode.y,o,a,f,l,c,h=e.x,p=e.y,d,v,m,g,y,b,w,E=Math.abs,S=Math.max;o=this._findNeighbors(e);for(l=0,c=o.length;l<c;++l){a=o[l],f=this._jump(a[0],a[1],h,p);if(f){d=f[0],v=f[1],w=t.getNodeAt(d,v);if(w.closed)continue;y=u.euclidean(E(d-h),E(v-p)),b=e.g+y;if(!w.opened||b<w.g)w.g=b,w.h=w.h||n(E(d-i),E(v-s)),w.f=w.g+w.h,w.parent=e,w.opened?r.updateItem(w):(r.push(w),w.opened=!0)}}},a.prototype._jump=function(e,t,n,r){var i=this.grid,s=e-n,o=t-r,u,a;if(!i.isWalkableAt(e,t))return null;if(i.getNodeAt(e,t)===this.endNode)return[e,t];if(s!==0&&o!==0){if(i.isWalkableAt(e-s,t+o)&&!i.isWalkableAt(e-s,t)||i.isWalkableAt(e+s,t-o)&&!i.isWalkableAt(e,t-o))return[e,t]}else if(s!==0){if(i.isWalkableAt(e+s,t+1)&&!i.isWalkableAt(e,t+1)||i.isWalkableAt(e+s,t-1)&&!i.isWalkableAt(e,t-1))return[e,t]}else if(i.isWalkableAt(e+1,t+o)&&!i.isWalkableAt(e+1,t)||i.isWalkableAt(e-1,t+o)&&!i.isWalkableAt(e-1,t))return[e,t];if(s!==0&&o!==0){u=this._jump(e+s,t,e,t),a=this._jump(e,t+o,e,t);if(u||a)return[e,t]}return i.isWalkableAt(e+s,t)||i.isWalkableAt(e,t+o)?this._jump(e+s,t+o,e,t):null},a.prototype._findNeighbors=function(e){var t=e.parent,n=e.x,r=e.y,i=this.grid,s,o,u,a,f,l,c=[],h,p,d,v;if(t)s=t.x,o=t.y,f=(n-s)/Math.max(Math.abs(n-s),1),l=(r-o)/Math.max(Math.abs(r-o),1),f!==0&&l!==0?(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+f,r)&&c.push([n+f,r]),(i.isWalkableAt(n,r+l)||i.isWalkableAt(n+f,r))&&c.push([n+f,r+l]),!i.isWalkableAt(n-f,r)&&i.isWalkableAt(n,r+l)&&c.push([n-f,r+l]),!i.isWalkableAt(n,r-l)&&i.isWalkableAt(n+f,r)&&c.push([n+f,r-l])):f===0?i.isWalkableAt(n,r+l)&&(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+1,r)||c.push([n+1,r+l]),i.isWalkableAt(n-1,r)||c.push([n-1,r+l])):i.isWalkableAt(n+f,r)&&(i.isWalkableAt(n+f,r)&&c.push([n+f,r]),i.isWalkableAt(n,r+1)||c.push([n+f,r+1]),i.isWalkableAt(n,r-1)||c.push([n+f,r-1]));else{h=i.getNeighbors(e,!0);for(d=0,v=h.length;d<v;++d)p=h[d],c.push([p.x,p.y])}return c},t.exports=a}),e.define("/PathFinding.js",function(e,t,n,r,i){t.exports={Node:e("./core/Node"),Grid:e("./core/Grid"),Heap:e("./core/Heap"),Util:e("./core/Util"),Heuristic:e("./core/Heuristic"),AStarFinder:e("./finders/AStarFinder"),BestFirstFinder:e("./finders/BestFirstFinder"),BreadthFirstFinder:e("./finders/BreadthFirstFinder"),DijkstraFinder:e("./finders/DijkstraFinder"),BiAStarFinder:e("./finders/BiAStarFinder"),BiBestFirstFinder:e("./finders/BiBestFirstFinder"),BiBreadthFirstFinder:e("./finders/BiBreadthFirstFinder"),BiDijkstraFinder:e("./finders/BiDijkstraFinder"),JumpPointFinder:e("./finders/JumpPointFinder")}}),e("/PathFinding.js"),e("/PathFinding")}()
;

/**
 * @class draw2d
 * global namespace declarations
 * 
 * @private
 */
var draw2d = 
{
    geo: {
    },

    io:{
        json:{},
        png:{},
        svg:{}  
    },
    
       
    storage:{
    },
    
    util : {
    	spline: {}
    },

    shape : {
    	basic:{},
        composite:{},
        arrow:{},
        node: {},
        note: {},
        diagram:{},
        flowchart:{},
        analog:{},
        icon:{},
        layout:{},
        pert:{},
        state:{},
        widget:{}
    },
    
    policy : {
        canvas:{},
        connection:{},
        line:{},
        port:{},
        figure:{}
    },
    
    command : {
    },

    decoration:{
    	connection:{}
    }, 
    
    layout: {
        connection :{},
	    anchor :{},
	    mesh :{},
	    locator: {}
    },
    
    
    ui :{
    	
    },
    
    isTouchDevice : (
            //Detect iPhone
            (navigator.platform.indexOf("iPhone") != -1) ||
            //Detect iPod
            (navigator.platform.indexOf("iPod") != -1)||
            //Detect iPad
            (navigator.platform.indexOf("iPad") != -1)
        )
    
};


if (!Array.prototype.reduce) {
  Array.prototype.reduce = function(callback ) {
    'use strict';
    if (this == null) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this), len = t.length >>> 0, k = 0, value;
    if (arguments.length == 2) {
      value = arguments[1];
    } else {
      while (k < len && ! k in t) {
        k++; 
      }
      if (k >= len) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k++];
    }
    for (; k < len; k++) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    var T, k;
    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }
    var O = Object(this);
    var len = O.length >>> 0;
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }
    if (arguments.length > 1) {
      T = thisArg;
    }
    k = 0;
    while (k < len) {
      var kValue;
      if (k in O) {
        kValue = O[k];
        callback.call(T, kValue, k, O);
      }
      k++;
    }
  };
}
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {
    var k;
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }
    var O = Object(this);
    var len = O.length >>> 0;
    if (len === 0) {
      return -1;
    }
    var n = +fromIndex || 0;
    if (Math.abs(n) === Infinity) {
      n = 0;
    }
    if (n >= len) {
      return -1;
    }
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
    while (k < len) {
      if (k in O && O[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}
if (!String.prototype.includes) {
  String.prototype.includes = function() {'use strict';
    return String.prototype.indexOf.apply(this, arguments) !== -1;
  };
}
if(!Number.MAX_SAFE_INTEGER){
  Number.MAX_SAFE_INTEGER = 9007199254740991; 
}
if (!Object.prototype.watch) {
  Object.defineProperty(Object.prototype, "watch", {
    enumerable: false
    , configurable: true
    , writable: false
    , value: function (prop, handler) {
      var
          oldval = this[prop]
          , newval = oldval
          , getter = function () {
            return newval;
          }
          , setter = function (val) {
            oldval = newval;
            return newval = handler.call(this, prop, oldval, val);
          }
          ;
      if (delete this[prop]) { 
        Object.defineProperty(this, prop, {
          get: getter
          , set: setter
          , enumerable: true
          , configurable: true
        });
      }
    }
  });
}
if (!Object.prototype.unwatch) {
  Object.defineProperty(Object.prototype, "unwatch", {
    enumerable: false
    , configurable: true
    , writable: false
    , value: function (prop) {
      var val = this[prop];
      delete this[prop]; 
      this[prop] = val;
    }
  });
}
draw2d.util.Base64 = {
    byteToCharMap_ :null,
    charToByteMap_: null,
    byteToCharMapWebSafe_ : null,
    charToByteMapWebSafe_ : null,
    ENCODED_VALS_BASE : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    ENCODED_VALS : 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '+/=',
    ENCODED_VALS_WEBSAFE :'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '-_.',
    encodeByteArray: function(input, opt_webSafe) {
        draw2d.util.Base64.init();
        var byteToCharMap = opt_webSafe ?  draw2d.util.Base64.byteToCharMapWebSafe_ : draw2d.util.Base64.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
          var byte1 = input[i];
          var haveByte2 = i + 1 < input.length;
          var byte2 = haveByte2 ? input[i + 1] : 0;
          var haveByte3 = i + 2 < input.length;
          var byte3 = haveByte3 ? input[i + 2] : 0;
          var outByte1 = byte1 >> 2;
          var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
          var outByte3 = ((byte2 & 0x0F) << 2) | (byte3 >> 6);
          var outByte4 = byte3 & 0x3F;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1],
                      byteToCharMap[outByte2],
                      byteToCharMap[outByte3],
                      byteToCharMap[outByte4]);
        }
        return output.join('');
      },
     encode: function(input, opt_webSafe) {
        return draw2d.util.Base64.encodeByteArray( draw2d.util.Base64.stringToByteArray(input), opt_webSafe);
      },
      decode: function(input, opt_webSafe) {
        draw2d.util.Base64.init();
        var charToByteMap = opt_webSafe ?draw2d.util.Base64.charToByteMapWebSafe_ : draw2d.util.Base64.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length; ) {
          var byte1 = charToByteMap[input.charAt(i++)];
          var haveByte2 = i < input.length;
          var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          var haveByte3 = i < input.length;
          var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          var haveByte4 = i < input.length;
          var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          if (byte1 == null || byte2 == null ||
              byte3 == null || byte4 == null) {
            throw Error();
          }
          var outByte1 = (byte1 << 2) | (byte2 >> 4);
          output.push(outByte1);
          if (byte3 != 64) {
            var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);
            output.push(outByte2);
            if (byte4 != 64) {
              var outByte3 = ((byte3 << 6) & 0xC0) | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
     },
    stringToByteArray: function(str) {
      var output = [], p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        while (c > 0xff) {
          output[p++] = c & 0xff;
          c >>= 8;
        }
        output[p++] = c;
      }
      return output;
    },
    init: function() {
        if (!draw2d.util.Base64.byteToCharMap_) {
            draw2d.util.Base64.byteToCharMap_ = {};
            draw2d.util.Base64.charToByteMap_ = {};
            draw2d.util.Base64.byteToCharMapWebSafe_ = {};
            draw2d.util.Base64.charToByteMapWebSafe_ = {};
          for (var i = 0; i < draw2d.util.Base64.ENCODED_VALS.length; i++) {
              draw2d.util.Base64.byteToCharMap_[i] = draw2d.util.Base64.ENCODED_VALS.charAt(i);
              draw2d.util.Base64.charToByteMap_[draw2d.util.Base64.byteToCharMap_[i]] = i;
              draw2d.util.Base64.byteToCharMapWebSafe_[i] = draw2d.util.Base64.ENCODED_VALS_WEBSAFE.charAt(i);
              draw2d.util.Base64.charToByteMapWebSafe_[draw2d.util.Base64.byteToCharMapWebSafe_[i]] = i;
          }
        }
    }
};
window.debug = (function(){
  var window = this,
    aps = Array.prototype.slice,
    con = window.console,
    that = {},
    callback_func,
    callback_force,
    log_level = 9,
    log_methods = [ 'error', 'warn', 'info', 'debug', 'log' ],
    pass_methods = 'assert clear count dir dirxml exception group groupCollapsed groupEnd profile profileEnd table time timeEnd trace'.split(' '),
    idx = pass_methods.length,
    logs = [];
  while ( --idx >= 0 ) {
    (function( method ){
      that[ method ] = function() {
        log_level !== 0 && con && con[ method ]
          && con[ method ].apply( con, arguments );
      };
    })( pass_methods[idx] );
  }
  idx = log_methods.length;
  while ( --idx >= 0 ) {
    (function( idx, level ){
      that[ level ] = function() {
        var args = aps.call( arguments ),
          log_arr = [ level ].concat( args );
        logs.push( log_arr );
        exec_callback( log_arr );
        if ( !con || !is_level( idx ) ) { return; }
        con.firebug ? con[ level ].apply( window, args )
          : con[ level ] ? con[ level ]( args )
          : con.log( args );
      };
    })( idx, log_methods[idx] );
  }
  function exec_callback( args ) {
    if ( callback_func && (callback_force || !con || !con.log) ) {
      callback_func.apply( window, args );
    }
  };
  that.setLevel = function( level ) {
    log_level = typeof level === 'number' ? level : 9;
  };
  function is_level( level ) {
    return log_level > 0
      ? log_level > level
      : log_methods.length + log_level <= level;
  };
  that.setCallback = function() {
    var args = aps.call( arguments ),
      max = logs.length,
      i = max;
    callback_func = args.shift() || null;
    callback_force = typeof args[0] === 'boolean' ? args.shift() : false;
    i -= typeof args[0] === 'number' ? args.shift() : max;
    while ( i < max ) {
      exec_callback( logs[i++] );
    }
  };
  return that;
})();
draw2d.util.Color = Class.extend({
    init: function( red, green, blue) {
      this.hashString = null;
      if(typeof red === "undefined" || red===null){
          this.hashString = "none";
      }
      else if(red instanceof draw2d.util.Color){
          if(red.hashString==="none"){
              this.hashString = "none";
          }
          else{
              this.red = red.red;
              this.green = red.green;
              this.blue = red.blue;
          }
      }
      else if(typeof red === "string")
      {
           if (red === "none") {
              this.hashString = "none";
           }
           else {
              var rgb = this.hex2rgb(red);
              this.red = rgb[0];
              this.green = rgb[1];
              this.blue = rgb[2];
          }
      }
      else if(typeof red === "object" && typeof red.red==="number")
      {
        this.red= red.red;
        this.green = red.green;
        this.blue = red.blue;
      }
      else if(red instanceof Array && red.length===3)
      {
        this.red= red[0];
        this.green = red[1];
        this.blue = red[2];
      }
      else if(typeof red === "object" && typeof red.length ==="number" && red.length===3)
      {
        this.red= red[0];
        this.green = red[1];
        this.blue = red[2];
      }
      else
      {
        this.red= parseInt(red);
        this.green = parseInt(green);
        this.blue = parseInt(blue);
      }
    },
    getHTMLStyle: function()
    {
      return "rgb("+this.red+","+this.green+","+this.blue+")";
    },
    getRed: function()
    {
      return this.red;
    },
    getGreen: function()
    {
      return this.green;
    },
    getBlue: function()
    {
      return this.blue;
    },
    getIdealTextColor: function()
    {
       var nThreshold = 105;
       var bgDelta = (this.red * 0.299) + (this.green * 0.587) + (this.blue * 0.114);
       return (255 - bgDelta < nThreshold) ? new  draw2d.util.Color(0,0,0) : new  draw2d.util.Color(255,255,255);
    },
    hex2rgb: function(hexcolor)
    {
      hexcolor = hexcolor.replace("#","");
      return(
             {0:parseInt(hexcolor.substr(0,2),16),
              1:parseInt(hexcolor.substr(2,2),16),
              2:parseInt(hexcolor.substr(4,2),16)}
             );
    },
    hex: function()
    { 
      return(this.int2hex(this.red)+this.int2hex(this.green)+this.int2hex(this.blue)); 
    },
    hash: function()
    {
        if(this.hashString===null){
            this.hashString= "#"+this.hex();
        }
        return this.hashString;
    },
    int2hex: function(v)
    {
      v=Math.round(Math.min(Math.max(0,v),255));
      return("0123456789ABCDEF".charAt((v-v%16)/16)+"0123456789ABCDEF".charAt(v%16));
    },
    darker: function(fraction)
    {
       if(this.hashString==="none")
           return this;
       var red   = parseInt(Math.round (this.getRed()   * (1.0 - fraction)));
       var green = parseInt(Math.round (this.getGreen() * (1.0 - fraction)));
       var blue  = parseInt(Math.round (this.getBlue()  * (1.0 - fraction)));
       if (red   < 0) red   = 0; else if (red   > 255) red   = 255;
       if (green < 0) green = 0; else if (green > 255) green = 255;
       if (blue  < 0) blue  = 0; else if (blue  > 255) blue  = 255;
       return new draw2d.util.Color(red, green, blue);
    },
    lighter: function( fraction)
    {
        if(this.hashString==="none")
            return this;
        var red   = parseInt(Math.round (this.getRed()   * (1.0 + fraction)));
        var green = parseInt(Math.round (this.getGreen() * (1.0 + fraction)));
        var blue  = parseInt(Math.round (this.getBlue()  * (1.0 + fraction)));
        if (red   < 0) red   = 0; else if (red   > 255) red   = 255;
        if (green < 0) green = 0; else if (green > 255) green = 255;
        if (blue  < 0) blue  = 0; else if (blue  > 255) blue  = 255;
        return new draw2d.util.Color(red, green, blue);
    },
    fadeTo: function(color, pc){
        var r= Math.floor(this.red+(pc*(color.red-this.red)) + .5);
        var g= Math.floor(this.green+(pc*(color.green-this.green)) + .5);
        var b= Math.floor(this.blue+(pc*(color.blue-this.blue)) + .5);
        return new draw2d.util.Color(r,g,b);   
    },
	equals: function( o)
	{
		if(!(o instanceof draw2d.util.Color)){
			return false;
		}
		return this.hash()==o.hash();
	}
});
draw2d.util.ArrayList = Class.extend({
    init: function( a) {
        if($.isArray(a)){
            this.data = a;
        }
        else{
        	this.data = [];
        }
    },
    clear: function()
    {
        this.data = [];
        return this;
    },
     reverse: function()
     {
        this.data.reverse();
        return this;
     },
     getSize: function()
     {
        return this.data.length;
     },
     isEmpty: function()
     {
        return this.getSize() === 0;
     },
     last: function()
     {
         return this.data[this.data.length - 1];
     },
     getLastElement: function(){return this.last();},
     asArray: function()
     {
       return this.data;
     },
     first: function()
     {
        if (this.data.length>0){
           return this.data[0];
        }
        return null;
     },
     getFirstElement: function(){return this.first();},
     get: function(i)
     {
        return this.data[i];
     },
     add: function(obj)
     {
        this.data.push(obj);
        return this;
     },
     grep: function(func){
         this.data = $.grep(this.data, func);
         return this;
     },
     find: function(func){
        var result= $.grep(this.data, func);
        if(result.length===0){
            return null;
        }
        return result[0];
     },
     map: function(func){
         this.data = $.map(this.data, func);
         return this;
     },
     unique: function(){
         this.data = $.unique(this.data);
         return this;
     },
     addAll: function(list, avoidDuplicates)
     {
        if(!(list instanceof draw2d.util.ArrayList)){
          throw "Unable to handle unknown object type in ArrayList.addAll";
        }
        this.data = this.data.concat(list.data);
        if(avoidDuplicates){
        	this.unique();
        }
        return this;
     },
     pop: function() {
         return this.removeElementAt(this.data.length - 1);
     },
     push: function( value) {
         this.add(value);
     },
     remove: function( obj)
     {
        var index = this.indexOf(obj);
        if(index>=0){
           return this.removeElementAt(index);
        }
        return null;
     },
     insertElementAt: function(obj, index)
     {
        this.data.splice(index,0,obj);
        return this;
     },
     removeElementAt: function(index)
     {
        var element = this.data[index];
        this.data.splice(index,1);
        return element;
     },
     removeAll: function(elements)
    {
        if (elements instanceof draw2d.util.ArrayList) {
            elements = elements.data;
        }
        if($.isArray(elements)){
            $.each(elements, $.proxy(function (i, e) {
                this.remove(e);
            }, this));
        }
        return this;
     },
     indexOf: function(obj)
     {
        return this.data.indexOf(obj);
     },
     contains: function(obj)
     {
        return this.indexOf(obj)!==-1;
     },
     sort: function(f)
     {
         if(typeof f ==="function"){
             this.data.sort(f);
         }
         else{
             this.data.sort(function(a,b) {
            	  if (a[f] < b[f])
            	    return -1;
            	  if (a[f] > b[f])
            	    return 1;
            	  return 0;
            });
        }
        return this;
     },
     clone: function(deep)
     {
        var newVector = new draw2d.util.ArrayList();
        if (deep) {
            for ( var i = 0; i < this.data.length; i++) {
                newVector.data.push(this.data[i].clone());
            }
        }
        else {
            newVector.data = this.data.slice(0);
        }
        return newVector;
     },
      each: function(func, reverse)
      {
         if(typeof reverse !=="undefined" && reverse===true){
             for (var i=this.data.length-1; i>=0; i--) {
                 if(func(i, this.data[i])===false)
                     break;
             }
          }
         else{
             for (var i=0; i<this.data.length; i++) {
                if(func(i, this.data[i])===false)
                    break;
             }
         }
          return this;
      },
     overwriteElementAt: function(obj, index)
     {
        this.data[index] = obj;
        return this;
     },
     getPersistentAttributes: function()
     {
        return {data: this.data};
     },
     setPersistentAttributes: function(memento)
     {
         this.data = memento.data;
     }
});
draw2d.util.ArrayList.EMPTY_LIST = new draw2d.util.ArrayList();
Raphael.fn.polygon = function(pointString) {
  var poly  = ['M'];
  var point = pointString.split(' ');
  for(var i=0; i < point.length; i++) {
     var c = point[i].split(',');
     for(var j=0; j < c.length; j++) {
        var d = parseFloat(c[j]);
        if (!isNaN(d))
          poly.push(d);
     };
     if (i == 0)
      poly.push('L');
  }
  poly.push('Z');
  return this.path(poly);
};
draw2d.util.JSON = {
        set: function(data, path, value) {
          if(!path || path===''){ 
              return;
          }
          var re = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
          var pathList = path.match(re);
          var parent = data;
          var parentKey;
          var grandParent = null;
          var grandParentKey = null;
          var addObj = function(obj, key, data) {
            if(key === '[]') {
              obj.push(data);
            } else {
              obj[key] = data;
            }
          };
          while(pathList.length > 0) {
            parentKey = pathList.shift().replace(/["']/g, '');
            // Number, treat it as an array
            if (!isNaN(+parentKey) || parentKey === "[]") {
              if($.type(parent)!=="array" ) {
                parent = [];
                addObj(grandParent, grandParentKey, parent);
              }
            // String, treat it as a key
            } 
            else if ($.type(parentKey)==="string") {
              if(!$.isPlainObject(parent)) {
                parent = {};
                addObj(grandParent, grandParentKey, parent);
              }
            }
            // Next
            grandParent = parent;
            grandParentKey = parentKey;
            parent = parent[parentKey];
          }
          addObj(grandParent, grandParentKey, value);
        },
        /**
         * @method
         * Returns the value defined by the path passed in
         *
         * @param  {Object} data the JSON data object
         * @param  {String} path string leading to a desired value
         */
        get: function(data, path) {
          var regex = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
          //check if path is truthy
          if (!path){
              return undefined;
          }
          //parse path on dots and brackets
          var paths = path.match(regex);
          //step through data object until all keys in path have been processed
          while (data !== null && paths.length > 0) {
            if(data.propertyIsEnumerable(paths[0].replace(/"/g, ''))){
              data = data[paths.shift().replace(/"/g, '')];
            }
            else{
              return undefined;
            }
          }
          return data;
        },
        diff: function(obj1, obj2) {
            var result = {};
            for(key in obj1) {
            	var v1 = obj1[key];
            	var v2 = obj2[key];
                if(v1 !== v2) {
                	if(v1.equals ){
                		if(!v1.equals(v2)){
                			result[key] = obj1[key];
                		}
                	}
                	else{
            			result[key] = obj1[key];
                	}
                }
            }
            return result;
        },
        flatDiff: function(obj1, obj2) {
            var result = {};
            for(key in obj1) {
                if(obj1[key] !== obj2[key]) {
                    result[key] = obj1[key];
                }
            }
            return result;
        },
        ensureDefault:function( json, attribute, value)
        {
            if (!json.hasOwnProperty(attribute)) {
                json[attribute] = value;
            }
        }
};
draw2d.util.UUID=function()
{
};
draw2d.util.UUID.create=function()
{
  var segment=function() 
  {
     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  };
  return (segment()+segment()+"-"+segment()+"-"+segment()+"-"+segment()+"-"+segment()+segment()+segment());
};
draw2d.util.spline.Spline = Class.extend({
    NAME : "draw2d.util.spline.Spline",
    init: function()
    {
    },
    generate: function(controlPoints, parts){
        throw "inherit classes must implement the method 'draw2d.util.spline.Spline.generate()'";
    }
});
draw2d.util.spline.CubicSpline = draw2d.util.spline.Spline.extend(
{
    NAME : "draw2d.util.spline.CubicSpline",
    init: function()
    {
        this._super();
    },
    generate: function(controlPoints, parts)
    {
        var cp = new draw2d.util.ArrayList();
        cp.add(controlPoints.get(0));
        cp.addAll(controlPoints);
        cp.add(controlPoints.get(controlPoints.getSize()-1));
      var n = cp.getSize();
      var spline = new draw2d.util.ArrayList();
      spline.add(controlPoints.get(0));
      spline.add( this.p(1, 0, cp) );
      for (var i = 1; i < n - 2; i++) {
        for (var j = 1; j <= parts; j++) {
          spline.add( this.p(i, j / parts, cp));
        }
      }
      spline.add(controlPoints.get(controlPoints.getSize()-1));
      return spline;      
    },
      p: function( i,  t,  cp)
      {
        var x = 0.0;
        var y = 0.0;
        var k = i-1;
        for (var j = -2; j <= 1; j++) {
          var b = this.blend (j, t);
          var p = cp.get(k++);
          x += b * p.x;
          y += b * p.y;
        }
       return new draw2d.geo.Point(x, y);
      },
      blend: function(i, t)
      {
        if (i === -2)
            return (((-t + 3) * t - 3) * t + 1) / 6;
        else if (i === -1)
            return (((3 * t - 6) * t) * t + 4) / 6;
        else if (i === 0)
            return (((-3 * t + 3) * t + 3) * t + 1) / 6;
        return (t * t * t) / 6;
      }
});
draw2d.util.spline.CatmullRomSpline = draw2d.util.spline.CubicSpline.extend(
{
    NAME : "draw2d.util.spline.CatmullRomSpline",
    init: function()
    {
        this._super();
    },
    blend: function(i, t) {
        if (i == -2)
            return ((-t + 2) * t - 1) * t / 2;
        else if (i == -1)
            return (((3 * t - 5) * t) * t + 2) / 2;
        else if (i == 0)
            return ((-3 * t + 4) * t + 1) * t / 2;
        else
            return ((t - 1) * t * t) / 2;
    }
});
draw2d.util.spline.BezierSpline = draw2d.util.spline.Spline.extend(
{
    NAME : "draw2d.util.spline.BezierSpline",
    init: function()
    {
        this._super();
    },
    generate: function(controlPoints, parts)
    {
      var n = controlPoints.getSize();
      var spline = new draw2d.util.ArrayList();
      spline.add(this.p(0, 0, controlPoints));
      for (var i = 0; i < n - 3; i += 3) {
        for (var j = 1; j <= parts; j++) {
           spline.add(this.p (i, j /  parts, controlPoints));
        }
      }
      return spline;      
    },
    p: function( i,  t,  cp)
    {
      var x = 0.0;
      var y = 0.0;
      var k = i;
      for (var j = 0; j <= 3; j++) {
        var b = this.blend (j, t);
        var p = cp.get(k++);
        x += b * p.x;
        y += b * p.y;
     }
      return new draw2d.geo.Point( x, y);
    },
    blend: function ( i,  t)
    {
      if      (i == 0) return (1 - t) * (1 - t) * (1 - t);
      else if (i == 1) return 3 * t * (1 - t) * (1 - t);
      else if (i == 2) return 3 * t * t * (1 - t);
      else             return t * t * t;
    }
});
draw2d.geo.PositionConstants=function()
{
};
draw2d.geo.PositionConstants.NORTH =  1;
draw2d.geo.PositionConstants.SOUTH =  4;
draw2d.geo.PositionConstants.WEST  =  8;
draw2d.geo.PositionConstants.EAST  = 16;
draw2d.geo.Point = Class.extend({
    NAME : "draw2d.geo.Point",
    init: function(x, y)
    {
        if(x instanceof draw2d.geo.Point){
            this.x = x.x;
            this.y = x.y;
        }
        else if($.isNumeric(x.x) && $.isNumeric(x.y)){
            this.x = x.x;
            this.y = x.y;
        }
        else{
            this.x = x;
            this.y = y;
        }
        this.bx = null;
        this.by = null;
        this.bw = null;
        this.bh = null;
    },
    setBoundary: function(bx, by, bw, bh)
    {
        if(bx instanceof draw2d.geo.Rectangle){
            this.bx = bx.x;
            this.by = bx.y;
            this.bw = bx.w;
            this.bh = bx.h;
        }else
        {
            this.bx = bx;
            this.by = by;
            this.bw = bw;
            this.bh = bh;
        }
        this.adjustBoundary();
        return this;
    },
    adjustBoundary: function()
    {
        if(this.bx===null){
            return;
        }
        this.x = Math.min(Math.max(this.bx, this.x), this.bw);
        this.y = Math.min(Math.max(this.by, this.y), this.bh);
        return this;
    },
    translate: function( dx,  dy)
    {
      this.x +=dx;
      this.y +=dy;
      this.adjustBoundary();
      return this;
    },
    getX: function()
    {
        return this.x;
    },
    getY: function()
    {
        return this.y;
    },
    setX: function(x)
    {
        this.x = x;
        this.adjustBoundary();
        return this;
    },
    setY: function(y)
    {
        this.y = y;
        this.adjustBoundary();
        return this;
    },
    setPosition: function(x,y)
    {
        if(x instanceof draw2d.geo.Point){
     	   this.x=x.x;
    	   this.y=x.y;
    	}
    	else{
    	   this.x=x;
    	   this.y=y;
    	}
        this.adjustBoundary();
        return this;
    },
    getPosition: function(p)
    {
        var dx = p.x - this.x;
        var dy = p.y - this.y;
        if (Math.abs(dx) > Math.abs(dy))
        {
            if (dx < 0)
                return draw2d.geo.PositionConstants.WEST;
            return draw2d.geo.PositionConstants.EAST;
        }
        if (dy < 0)
            return draw2d.geo.PositionConstants.NORTH;
        return draw2d.geo.PositionConstants.SOUTH;
    },
    equals: function(p)
    {
        return this.x === p.x && this.y === p.y;
    },
    distance: function(other)
    {
        return Math.sqrt((this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y));
    },
    getDistance: function(other){return this.distance(other);},
    length: function()
    {
        return Math.sqrt(this.x  * this.x  + this.y * this.y);
    },
    translated: function(x,y)
    {
        var other = new draw2d.geo.Point(x,y);
        return new draw2d.geo.Point(this.x + other.x, this.y + other.y);
    },
    scale: function(factor)
    {
        this.x *= factor;
        this.y *= factor;
        this.adjustBoundary();
        return this;
    },
    scaled: function(factor)
    {
        return new draw2d.geo.Point(this.x * factor, this.y * factor);
    },
    getScaled: function(factor){ return this.scaled(factor);},
    getPersistentAttributes: function()
    {
        return {
            x : this.x,
            y : this.y
        };
    },
    setPersistentAttributes: function(memento)
    {
        this.x    = memento.x;
        this.y    = memento.y;
    },
    subtract: function(that)
    {
    	return new draw2d.geo.Point(this.x-that.x,this.y-that.y);
    },
    dot: function(that)
    {
    	return this.x*that.x+this.y*that.y;
    },
    cross: function(that)
    {
    	return this.x*that.y-this.y*that.x;
    },
    lerp: function(that,t)
    {
    	return new draw2d.geo.Point(this.x+(that.x-this.x)*t,this.y+(that.y-this.y)*t);
    },
    clone: function()
    {
       return new draw2d.geo.Point(this.x,this.y);
    }
});
draw2d.geo.Rectangle = draw2d.geo.Point.extend({
    NAME : "draw2d.geo.Rectangle",
    init: function( x, y,  w, h)
    {
    	if(x instanceof draw2d.geo.Rectangle){
    		y= x.y;
    		w = x.w;
    		h = x.h;
    		x = x.x;
    	}
    	else if(typeof x.x ==="number" && typeof x.y ==="number"){
    		y= x.y;
    		w = x.w | x.width;
    		h = x.h | x.height;
    		x = x.x;
    	}
		else if(typeof x.top ==="number" && typeof x.left ==="number"){
			y=  x.top;
			w = x.w | x.width;
			h = x.h | x.height;
			x = x.left;
		}
    	this._super(x,y);
        this.w = w;
        this.h = h;
    },
    adjustBoundary: function()
    {
        if(this.bx===null){
            return;
        }
        this.x = Math.min(Math.max(this.bx, this.x), this.bw-this.w);
        this.y = Math.min(Math.max(this.by, this.y), this.bh-this.h);
        this.w = Math.min(this.w, this.bw);
        this.h = Math.min(this.h, this.bh);
    },
	resize: function(dw,  dh)
	{
	  this.w +=dw;
	  this.h +=dh;
      this.adjustBoundary();
	  return this;
	},
    scale: function( dw, dh)
    {
      this.w +=(dw);
      this.h +=(dh);
      this.x -=(dw/2);
      this.y -=(dh/2);
      this.adjustBoundary();
      return this;
    },
	translate: function(x,y)
	{
		var other = new draw2d.geo.Point(x,y);
		this.x += other.x;
		this.y += other.y;
		this.adjustBoundary();
		return this;
	},
	translated: function(x,y)
	{
		var other = new draw2d.geo.Point(x,y);
		return new draw2d.geo.Rectangle(this.x + other.x, this.y + other.y, this.w, this.h);
	},
	setBounds: function( rect)
	{
	    this.setPosition(rect.x,rect.y);
	    this.w = rect.w;
	    this.h = rect.h;
  	   return this;
	},
	isEmpty: function()
	{
	  return this.w <= 0 || this.h <= 0;
	},
	getWidth: function()
	{
	  return this.w;
	},
	setWidth: function(w)
    {
      this.w = w;
      this.adjustBoundary();
      return this;
	},
	getHeight: function()
	{
	  return this.h;
	},
    setHeight: function(h)
    {
      this.h = h;
      this.adjustBoundary();
      return this;
    },	
    getLeft: function()
    {
      return this.x;
    },
	getRight: function()
	{
	  return this.x+this.w;
	},
    getTop: function()
    {
      return this.y;
    },
	getBottom: function()
	{
	  return this.y+this.h;
	},
	getTopLeft: function()
	{
	  return new draw2d.geo.Point(this.x,this.y);
	},
    getTopCenter: function()
    {
      return new draw2d.geo.Point(this.x+(this.w/2),this.y);
    },
	getTopRight: function()
	{
	  return new draw2d.geo.Point(this.x+this.w,this.y);
	},
	getCenterLeft: function()
	{
		return new draw2d.geo.Point(this.x,this.y+(this.h/2));
	},
	getBottomLeft: function()
	{
	  return new draw2d.geo.Point(this.x,this.y+this.h);
	},
    getBottomCenter: function()
    {
      return new draw2d.geo.Point(this.x+(this.w/2),this.y+this.h);
    },
	getCenter: function()
	{
	  return new draw2d.geo.Point(this.x+this.w/2,this.y+this.h/2);
	},
	getBottomRight: function()
	{
	  return new draw2d.geo.Point(this.x+this.w,this.y+this.h);
	},
	getVertices: function()
	{
	    var result = new draw2d.util.ArrayList();
        result.add(this.getTopLeft());
        result.add(this.getTopRight());
        result.add(this.getBottomRight());
        result.add(this.getBottomLeft());
        return result;
	},
	moveInside: function(rect)
    {
	    var newRect = new draw2d.geo.Rectangle(rect.x,rect.y,rect.w,rect.h);
	    newRect.x= Math.max(newRect.x,this.x);
	    newRect.y= Math.max(newRect.y,this.y);
	    if(newRect.w<this.w){
	        newRect.x = Math.min(newRect.x+newRect.w, this.x+this.w)-newRect.w; 
	    }
	    else{
	        newRect.x = this.x;
	    }
        if(newRect.h<this.h){
            newRect.y = Math.min(newRect.y+newRect.h, this.y+this.h)-newRect.h; 
        }
        else{
            newRect.y = this.y;
        }
        return newRect;
	},
	getDistance: function (pointOrRectangle)
    {
		var cx = this.x;
		var cy = this.y;
		var cw = this.w;
		var ch = this.h;
		var ox = pointOrRectangle.getX();
		var oy = pointOrRectangle.getY();
		var ow = 1;
		var oh = 1;
		if(pointOrRectangle instanceof draw2d.geo.Rectangle){
			ow = pointOrRectangle.getWidth();
			oh = pointOrRectangle.getHeight();
		}
		var oct=9;
		if(cx + cw <= ox){
			if((cy + ch) <= oy){
				oct = 0;
			}
			else if(cy >= (oy + oh)){
				oct = 6;
			}
			else{
				oct = 7;
			}
	    }
		else if(cx >= ox + ow){
			if(cy + ch <= oy){
				oct = 2;
			}
			else if(cy >= oy + oh){
				oct = 4;
			}
			else{
				oct = 3;
			}
		}
		else if(cy + ch <= oy){
			oct = 1;
		}
		else if(cy >= oy + oh){
			oct = 5;
		}
		else{
			return 0;
		}
		switch( oct){
			case 0:
				cx = (cx + cw) - ox;
				cy = (cy + ch) - oy;
				return -(cx + cy) ;
			case 1:
				return -((cy + ch) - oy);
			case 2:
				cx = (ox + ow) - cx;
				cy = (cy + ch) - oy;
				return -(cx + cy);
			case 3:
				return -((ox + ow) - cx);
			case 4:
				cx = (ox + ow) - cx;
				cy = (oy + oh) - cy;
				return -(cx + cy);
			case 5:
				return -((oy + oh) - cy);
			case 6:
				cx = (cx + cw) - ox;
				cy = (oy + oh) - cy;
				return -(cx + cy);
			case 7:
				return -((cx + cw) - ox);
		}
		throw "Unknown data type of parameter for distance calculation in draw2d.geo.Rectangle.getDistance(..)";
	},
    determineOctant: function( r2)
    {
        var HISTERESE= 3; 
        var ox = this.x+HISTERESE;
        var oy = this.y+HISTERESE;
        var ow = this.w-(HISTERESE*2);
        var oh = this.h-(HISTERESE*2);
        var cx = r2.x;
        var cy = r2.y;
        var cw = 2;
        var ch = 2;
        if(r2 instanceof draw2d.geo.Rectangle){
            cw = r2.w;
            ch = r2.h;
        }
        var oct =0;
        if(cx + cw <= ox){
            if((cy + ch) <= oy){
                oct = 0;
            }
            else if(cy >= (oy + oh)){
                oct = 6;
            }
            else{
                oct = 7;
            }
        }
        else if(cx >= ox + ow){
            if(cy + ch <= oy){
                oct = 2;
            }
            else if(cy >= oy + oh){
                oct = 4;
            }
            else{
                oct = 3;
            }
        }
        else if(cy + ch <= oy){
            oct = 1;
        }
        else if(cy >= oy + oh){
            oct = 5;
        }
        else{
            oct= 8;
        }
        return oct;
    },
    getDirection: function(other)
    {
        var current = this.getTopLeft();
        switch(this.determineOctant(other)){
            case 0:
                if((current.x-other.x)<(current.y-other.y))
                    return draw2d.geo.Rectangle.DIRECTION_UP;
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 1:
                return draw2d.geo.Rectangle.DIRECTION_UP;
            case 2:
                current = this.getTopRight();
                if((other.x-current.x)<(current.y-other.y))
                    return draw2d.geo.Rectangle.DIRECTION_UP;
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 3:
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 4:
                current = this.getBottomRight();
                if((other.x-current.x)<(other.y-current.y))
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                return draw2d.geo.Rectangle.DIRECTION_RIGHT;
            case 5:
                return draw2d.geo.Rectangle.DIRECTION_DOWN;
            case 6:
                current = this.getBottomLeft();
                if((current.x-other.x)<(other.y-current.y))
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 7:
                return draw2d.geo.Rectangle.DIRECTION_LEFT;
            case 8: 
                if(other.y>this.y){
                    return draw2d.geo.Rectangle.DIRECTION_DOWN;
                }
                return draw2d.geo.Rectangle.DIRECTION_UP;
        }
        return draw2d.geo.Rectangle.DIRECTION_UP;
    },
	equals: function( o)
	{
	  return this.x==o.x && this.y==o.y && this.w==o.w && this.h==o.h;
	},
    hitTest : function ( iX , iY)
    {
    	if(iX instanceof draw2d.geo.Point){
    		iY = iX.y;
    		iX = iX.x;
    	}
        var iX2 = this.x + this.getWidth();
        var iY2 = this.y + this.getHeight();
        return (iX >= this.x && iX <= iX2 && iY >= this.y && iY <= iY2);
    },
    isInside : function ( rect)
    {
       	return    rect.hitTest(this.getTopLeft()) 
    	       && rect.hitTest(this.getTopRight())
    	       && rect.hitTest(this.getBottomLeft()) 
    	       && rect.hitTest(this.getBottomRight());
    },
    contains : function ( rect)
    {
        return    this.hitTest(rect.getTopLeft()) 
               && this.hitTest(rect.getTopRight())
               && this.hitTest(rect.getBottomLeft()) 
               && this.hitTest(rect.getBottomRight());
    },
    intersects: function (rect)
    {
        var x11 = rect.x,
            y11 = rect.y,
            x12 = rect.x + rect.w,
            y12 = rect.y + rect.h,
            x21 = this.x,
            y21 = this.y,
            x22 = this.x + this.w,
            y22 = this.y + this.h;
        var x_overlap = Math.max(0, Math.min(x12,x22) - Math.max(x11,x21));
        var y_overlap = Math.max(0, Math.min(y12,y22) - Math.max(y11,y21));
        return x_overlap*y_overlap!==0;
    },
    merge: function(rect)
    {
        var r= Math.max(rect.getRight(), this.getRight());
        var b = Math.max(rect.getBottom(), this.getBottom());
        this.setPosition(Math.min(this.x,rect.x),Math.min(this.y,rect.y));
        this.w =r-this.x;
        this.h = b-this.y;
        return this;
    },
    intersectionWithLine: function(start, end)
    {
        var result = new draw2d.util.ArrayList();
        var v = this.getVertices();
        v.add(v.first());
        var p1 = v.first();
        var p2 = null;
        for(var i=1; i<5;i++){
            p2 = v.get(i);
            p1 = draw2d.shape.basic.Line.intersection(start,end,p1,p2);
            if(p1!==null){
                result.add(p1);
            }
            p1 = p2;
        }
        return result;
    },
	clone: function()
	{
		return new draw2d.geo.Rectangle(this.x, this.y, this.w, this.h);
	},
    toJSON: function()
    {
        return  { 
              width : this.w,
              height: this.h,
              x     : this.x,
              y     : this.y
          };
      }
});
draw2d.geo.Rectangle.DIRECTION_UP    =0;
draw2d.geo.Rectangle.DIRECTION_RIGHT =1;
draw2d.geo.Rectangle.DIRECTION_DOWN  =2;
draw2d.geo.Rectangle.DIRECTION_LEFT  =3;
draw2d.geo.Util=
{
    insetPoint: function(start, end, distanceFromStart){
        if(start.equals(end)){
            return start;
        }
        var vx = start.x-end.x;
        var vy = start.y-end.y;
        var length = Math.sqrt(vx*vx + vy*vy);
        var localDistance = Math.min(length/2,distanceFromStart);
        return {x: end.x + vx/length * (length - localDistance),
                y: end.y + vy/length * (length - localDistance)};
    }
};
draw2d.geo.Ray = draw2d.geo.Point.extend({
    NAME : "draw2d.geo.Ray",
    init: function( x, y)
    {
        this._super(x,y);
    },
    isHorizontal: function()
    {
       return this.x != 0;
    },
    similarity: function( otherRay)
    {
       return Math.abs(this.dot(otherRay));
    },
    getAveraged: function( otherRay)
    {
        return new draw2d.geo.Ray((this.x + otherRay.x) / 2, (this.y + otherRay.y) / 2);
    }
});
draw2d.geo.Line = {
    inverseLerp: function( X1, Y1,  X2,  Y2, px, py)
    {
        var nenner = Math.abs(X2-X1);
        var zaehler= Math.abs(X2-px);
        if(nenner===0){
            nenner = Math.abs(Y2-Y1);
            zaehler= Math.abs(Y2-py);
            if(nenner==0){
                return 1;
            }
        }
        return zaehler/nenner;
    },
    pointProjection: function( X1, Y1,  X2,  Y2, px, py)
    {
        var r = new draw2d.geo.Point(0,0);
        if (X1 == X2 && Y1 == Y2) X1 -= 0.00001;
        var U = ((px - X1) * (X2 - X1)) + ((py - Y1) * (Y2 - Y1));
        var Udenom = Math.pow(X2 - X1, 2) + Math.pow(Y2 - Y1, 2);
        U /= Udenom;
        r.x = X1 + (U * (X2 - X1));
        r.y = Y1 + (U * (Y2 - Y1));
        var minx, maxx, miny, maxy;
        minx = Math.min(X1, X2);
        maxx = Math.max(X1, X2);
        miny = Math.min(Y1, Y2);
        maxy = Math.max(Y1, Y2);
        var isValid = (r.x >= minx && r.x <= maxx) && (r.y >= miny && r.y <= maxy);
        return isValid ? r : null;
    },
    distance : function( X1, Y1,  X2,  Y2, px, py)
    {
        X2 -= X1;
        Y2 -= Y1;
        px -= X1;
        py -= Y1;
        var dotprod = px * X2 + py * Y2;
        var projlenSq;
        if (dotprod <= 0.0) {
            projlenSq = 0.0;
        } else {
            px = X2 - px;
            py = Y2 - py;
            dotprod = px * X2 + py * Y2;
            if (dotprod <= 0.0) {
                projlenSq = 0.0;
            } else {
                projlenSq = dotprod * dotprod / (X2 * X2 + Y2 * Y2);
            }
        }
        var lenSq = px * px + py * py - projlenSq;
        if (lenSq < 0) {
            lenSq = 0;
        }
        return Math.sqrt(lenSq);
    }
};
draw2d.command.CommandType = Class.extend({
    NAME : "draw2d.command.CommandType",
    init: function( policy)
    {
       this.policy = policy;
    },
    getPolicy: function()
    {
       return this.policy;
    }
});
draw2d.command.CommandType.DELETE               = "DELETE";
draw2d.command.CommandType.MOVE                 = "MOVE";
draw2d.command.CommandType.CONNECT              = "CONNECT";
draw2d.command.CommandType.MOVE_BASEPOINT       = "MOVE_BASEPOINT";
draw2d.command.CommandType.MOVE_VERTEX          = "MOVE_VERTEX";
draw2d.command.CommandType.MOVE_VERTICES        = "MOVE_VERTICES";
draw2d.command.CommandType.MOVE_GHOST_VERTEX    = "MOVE_GHOST_VERTEX";
draw2d.command.CommandType.RESIZE               = "RESIZE";
draw2d.command.CommandType.RESET                = "RESET";
draw2d.command.CommandType.ROTATE               = "ROTATE";
draw2d.command.Command = Class.extend({
    NAME : "draw2d.command.Command", 
    init: function( label)
    {
        this.label = label;
    },
    getLabel: function()
    {
       return this.label;
    },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
    },
    cancel: function()
    {
    },
    undo: function()
    {
    },
    redo: function()
    {
    }
});
draw2d.command.CommandCollection = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandCollection", 
    init: function(commandLabel)
     {
       this._super((typeof commandLabel === 'undefined') ? draw2d.Configuration.i18n.command.collection : commandLabel);
       this.commands = new draw2d.util.ArrayList();
    },
    getLabel: function()
    {
        if(this.commands.getSize()===1){
           return this.commands.first().getLabel();
        }
        if(this.commands.getSize()>1){
            var labels = this.commands.clone().map(function(e){
                return e.getLabel();
            });
            labels.unique();
            if(labels.getSize()===1){
                return labels.first();
            }
        }
        return this._super();
    },
    add: function(command)
    {
    	this.commands.add(command);
    },
    canExecute: function()
    {
        var canExec = false;
        this.commands.each(function(i,cmd){
            canExec = canExec|| cmd.canExecute();
        });
        return canExec;
    },
    execute: function()
    {
    	this.commands.each(function(i,cmd){
    	    cmd.execute();
    	});
    },
    redo: function()
    {
        this.commands.each(function(i,cmd){
            cmd.redo();
        });
    },
    undo: function()
    {
        this.commands.reverse();
        this.commands.each(function(i,cmd){
            cmd.undo();
        });
        this.commands.reverse();
    }
});
draw2d.command.CommandStack = Class.extend({
    NAME : "draw2d.command.CommandStack", 
    init: function( )
    {
       this.undostack = [];
       this.redostack = [];
       this.maxundo = 50;
       this.transactionCommand = null;
       this.eventListeners = new draw2d.util.ArrayList();
    },
    setUndoLimit: function( count)
    {
      this.maxundo = count;
      return this;
    },
    markSaveLocation: function()
    {
       this.undostack = [];
       this.redostack = [];
       this.notifyListeners(new draw2d.command.Command(), draw2d.command.CommandStack.POST_EXECUTE);
       return this;
    },
    execute: function(command)
    {
        if(typeof command === "undefined")
            throw "Missing parameter [command] for method call CommandStack.execute";
       if(command===null)
          return; 
       if(command.canExecute()===false)
          return;
       if(this.transactionCommand!==null){
           this.transactionCommand.add(command);
           return;
       }
       this.notifyListeners(command, draw2d.command.CommandStack.PRE_EXECUTE);
       this.undostack.push(command);
       command.execute();
       this.redostack = [];
       if(this.undostack.length > this.maxundo)
       {
          this.undostack = this.undostack.slice(this.undostack.length-this.maxundo);
       }
       this.notifyListeners(command, draw2d.command.CommandStack.POST_EXECUTE);
       return this;
    },
    startTransaction: function(commandLabel)
    {
        this.transactionCommand = new draw2d.command.CommandCollection(commandLabel);
        return this;
    },
    commitTransaction: function()
    {
        if(this.transactionCommand===null){
            return;
        }
        var cmd = this.transactionCommand;
        this.transactionCommand =null;
        if(cmd.commands.getSize()===1){
        	this.execute(cmd.commands.first());
        }
        else{
        	this.execute(cmd);
        }
        return this;
    },
    undo: function()
    {
       var command = this.undostack.pop();
       if(command)
       {
          this.notifyListeners(command, draw2d.command.CommandStack.PRE_UNDO);
          this.redostack.push(command);
          command.undo();
          this.notifyListeners(command, draw2d.command.CommandStack.POST_UNDO);
       }
       return this;
    },
    redo: function()
    {
       var command = this.redostack.pop();
       if(command){
          this.notifyListeners(command, draw2d.command.CommandStack.PRE_REDO);
          this.undostack.push(command);
          command.redo();
          this.notifyListeners(command, draw2d.command.CommandStack.POST_REDO);
       }
       return this;
    },
    getRedoLabel: function()
    {
       if(this.redostack.length===0)
         return "";
       var command = this.redostack[this.redostack.length-1];
       if(command){
          return command.getLabel();
       }
       return "";
    },
    getUndoLabel: function()
    {
       if(this.undostack.length===0)
         return "";
       var command = this.undostack[this.undostack.length-1];
       if(command){
          return command.getLabel();
       }
       return "";
    },
    canRedo: function()
    {
       return this.redostack.length>0;
    },
    canUndo: function()
    {
       return this.undostack.length>0;
    },
    addEventListener: function( listener)
    {
        if(listener instanceof draw2d.command.CommandStackEventListener){
          this.eventListeners.add(listener);
        }
        else if(typeof listener.stackChanged ==="function"){
          this.eventListeners.add(listener);
        }
        else if(typeof listener === "function"){
          this.eventListeners.add( {  stackChanged : listener });
        }
        else{
          throw "Object doesn't implement required callback interface [draw2d.command.CommandStackListener]";
        }
        return this;
    },
    removeEventListener: function(listener)
    {
        var size = this.eventListeners.getSize();
        for (var i = 0; i < size; i++){
            var entry = this.eventListeners.get(i);
            if(entry ===listener || entry.stackChanged === listener){
                this.eventListeners.remove(entry);
                return;
            }
         }
        return this;
    },
    notifyListeners: function(command,  state)
    {
      var event = new draw2d.command.CommandStackEvent(this, command, state);
      var size = this.eventListeners.getSize();
      for (var i = 0; i < size; i++){
         this.eventListeners.get(i).stackChanged(event);
      }
    }
});
draw2d.command.CommandStack.PRE_EXECUTE=1;
draw2d.command.CommandStack.PRE_REDO=2;
draw2d.command.CommandStack.PRE_UNDO=4;
draw2d.command.CommandStack.POST_EXECUTE=8;
draw2d.command.CommandStack.POST_REDO=16;
draw2d.command.CommandStack.POST_UNDO=32;
draw2d.command.CommandStack.POST_INIT=64;
draw2d.command.CommandStack.POST_MASK = draw2d.command.CommandStack.POST_EXECUTE | draw2d.command.CommandStack.POST_UNDO | draw2d.command.CommandStack.POST_REDO;
draw2d.command.CommandStack.PRE_MASK  = draw2d.command.CommandStack.PRE_EXECUTE  | draw2d.command.CommandStack.PRE_UNDO  |draw2d.command.CommandStack.PRE_REDO;
draw2d.command.CommandStackEvent = Class.extend({
    NAME : "draw2d.command.CommandStackEvent", 
    init: function(stack, command, details)
    {
    	this.stack = stack;
        this.command = command;
        this.details = details;
    },
    getStack: function()
    {
       return this.stack;
    },
    getCommand: function()
    {
       return this.command;
    },
    getDetails: function()
    {
       return this.details;
    },
    isPostChangeEvent: function()
    {
       return 0 != (this.getDetails() & draw2d.command.CommandStack.POST_MASK);
    },
    isPreChangeEvent: function()
    {
       return 0 != (this.getDetails() & draw2d.command.CommandStack.PRE_MASK);
    }
});
draw2d.command.CommandStackEventListener = Class.extend({
    NAME : "draw2d.command.CommandStackEventListener", 
    init: function()
    {
    },
    stackChanged: function(event)
    {
    }
});
draw2d.command.CommandMove = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandMove", 
    init: function(figure, x, y)
    {
        this._super(draw2d.Configuration.i18n.command.moveShape);
        this.figure = figure;
        if (typeof x === "undefined")
        {
            this.oldX = figure.getX();
            this.oldY = figure.getY();
        }
        else
        {
            this.oldX = x;
            this.oldY = y;
        }
   },
    setStartPosition: function( x,  y)
    {
       this.oldX = x;
       this.oldY = y;
    },
    setPosition: function( x,  y)
    {
       this.newX = x;
       this.newY = y;
    },
    canExecute: function()
    {
      return this.newX!=this.oldX || this.newY!=this.oldY;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
       this.figure.setPosition(this.oldX, this.oldY);
    },
    redo: function()
    {
       this.figure.setPosition(this.newX, this.newY);
    }
});
draw2d.command.CommandAttr = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandAttr",
    init: function(figure, newAttributes)
    {
        var _this = this;
        this._super(draw2d.Configuration.i18n.command.changeAttributes);
        this.figure = figure;
        this.newAttributes = newAttributes;
        this.oldAttributes = {};
        $.each(newAttributes, function(key, value){
            _this.oldAttributes[key] = figure.attr(key);
        });
    },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.figure.attr(this.oldAttributes);
    },
    redo: function()
    {
        this.figure.attr(this.newAttributes);
    }
});
draw2d.command.CommandMoveLine = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandMoveLine", 
    init: function(figure)
    {
        this._super(draw2d.Configuration.i18n.command.moveLine);
        this.line = figure;
        this.dx = 0;
        this.dy = 0;
    },
    setTranslation: function(dx, dy)
    {
        this.dx = dx;
        this.dy = dy;
    },
   canExecute: function()
   {
     return this.dx !==0 && this.dy !==0;
   },
   execute: function()
   {
      this.redo();
   },
   undo: function()
   {
       var _this = this;
       this.line.getVertices().each(function(i,e){
           e.translate(-_this.dx, -_this.dy);
       });
       this.line.svgPathString = null;
       this.line.setPosition(this.line.getStartPoint());
   },
   redo: function()
   {
       var _this = this;
       this.line.getVertices().each(function(i,e){
           e.translate(_this.dx, _this.dy);
       });
       this.line.svgPathString = null;       
       this.line.setPosition(this.line.getStartPoint());
   }
});
draw2d.command.CommandMoveConnection = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandMoveConnection",
    init: function(figure)
    {
        this._super(draw2d.Configuration.i18n.command.moveLine);
        this.line = figure;
        this.dx = 0;
        this.dy = 0;
    },
    setTranslation: function(dx, dy)
    {
        this.dx = dx;
        this.dy = dy;
    },
   canExecute: function()
   {
     return this.dx !==0 && this.dy !==0;
   },
   execute: function()
   {
      this.redo();
   },
   undo: function()
   {
       var _this = this;
       this.line.getVertices().each(function(i,e){
           e.translate(-_this.dx, -_this.dy);
       });
       this.line.svgPathString = null;
       this.line.setPosition(this.line.getStartPoint());
   },
   redo: function()
   {
       var _this = this;
       this.line.getVertices().each(function(i,e){
           e.translate(_this.dx, _this.dy);
       });
       this.line.svgPathString = null;       
       this.line.setPosition(this.line.getStartPoint());
   }
});
draw2d.command.CommandMoveVertex = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandMoveVertex", 
    init: function(line)
    {
        this._super(draw2d.Configuration.i18n.command.moveVertex);
        this.line = line;
        this.index = -1;
        this.newPoint = null;
    },
    setIndex: function( index)
    {
       this.index = index;
       this.origPoint = this.line.getVertices().get(this.index).clone();
    },
    updatePosition: function(x,y)
    {
        this.newPoint = new draw2d.geo.Point(x,y);
    },
    canExecute: function()
    {
      return this.index!==-1 && this.newPoint!==null;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.line.setVertex(this.index, this.origPoint.x, this.origPoint.y);
    },
    redo: function()
    {
        this.line.setVertex(this.index, this.newPoint.x, this.newPoint.y);
    }
});
draw2d.command.CommandMoveVertices = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandMoveVertices", 
    init: function(line)
    {
        this._super(draw2d.Configuration.i18n.command.moveVertices);
        this.line = line;
        this.oldVertices = line.getVertices().clone(true);
        this.newVertices = null;
    },
    updateVertices: function(newVertices)
    {
       this.newVertices = newVertices;
    },
    canExecute: function()
    {
      return this.newVertices!==null;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.line.setVertices(this.oldVertices);
    },
    redo: function()
    {
        this.line.setVertices(this.newVertices);
    }
});
draw2d.command.CommandResize = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandResize", 
    init: function(figure, width, height)
    {
        this._super(draw2d.Configuration.i18n.command.resizeShape);
        this.figure = figure;
        if (typeof width === "undefined")
        {
            this.oldWidth = figure.getWidth();
            this.oldHeight = figure.getHeight();
        }
        else
        {
            this.oldWidth = width;
            this.oldHeight = height;
        }
    },
    setDimension: function( width, height)
    {
       this.newWidth  = width|0;
       this.newHeight = height|0;
    },
    canExecute: function()
    {
      return this.newWidth!=this.oldWidth || this.newHeight!=this.oldHeight;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
       this.figure.setDimension(this.oldWidth, this.oldHeight);
    },
    redo: function()
    {
       this.figure.setDimension(this.newWidth, this.newHeight);
    }
});
draw2d.command.CommandRotate = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandRotate", 
    init: function(figure, angle)
    {
        this._super(draw2d.Configuration.i18n.command.rotateShape);
        this.figure = figure;
        this.oldAngle = figure.getRotationAngle();
        this.newAngle = angle;
    },
    canExecute: function()
    {
      return this.oldAngle!=this.newAngle;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.rotate(this.oldAngle);
    },
    redo: function()
    {
        this.rotate(this.newAngle)
    },
    rotate: function(angle){
        var w = this.figure.getWidth();
        var h = this.figure.getHeight();
        this.figure.setRotationAngle(angle);
        this.figure.setDimension(h,w);
        this.figure.portRelayoutRequired=true;
    }
});
draw2d.command.CommandConnect = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandConnect", 
    init: function(source, target, dropTarget)
     {
       this._super(draw2d.Configuration.i18n.command.connectPorts);
       this.canvas     = target.getCanvas();
       this.source     = source;
       this.target     = target;
       this.connection = null;
       this.dropTarget = dropTarget; 
    },
    setConnection: function(connection)
    {
       this.connection=connection;
    },
    getConnection: function()
    {
        return this.connection;
    },
    execute: function()
    {
        var optionalCallback = $.proxy(function(conn){
            this.connection = conn;
            this.connection.setSource(this.source);
            this.connection.setTarget(this.target);
            this.canvas.add(this.connection);
        },this);
        if(this.connection===null){
          var result = draw2d.Configuration.factory.createConnection(this.source, this.target, optionalCallback, this.dropTarget);
          debugger;
          if(typeof result==="undefined"){
              return;
          }
          this.connection = result;
        }
        optionalCallback(this.connection);
    },
    redo: function()
    {
       this.canvas.add(this.connection);
       this.connection.reconnect();
    },
    undo: function()
    {
        this.canvas.remove(this.connection);
    }
});
draw2d.command.CommandReconnect = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandReconnect", 
    init: function(con)
    {
       this._super(draw2d.Configuration.i18n.command.connectPorts);
       this.con      = con;
       this.oldSourcePort  = con.getSource();
       this.oldTargetPort  = con.getTarget();
   },
    canExecute: function()
    {
      return true;
    },
    setNewPorts: function(source,  target)
    {
      this.newSourcePort = source;
      this.newTargetPort = target;
    },
    setIndex: function( index)
    {
    },
    updatePosition: function(x,y)
    {
    },
    execute: function()
    {
       this.redo();
    },
    cancel: function()
    {
        this.con.setSource(this.oldSourcePort);
        this.con.setTarget(this.oldTargetPort);
        this.con.routingRequired =true;
        this.con.repaint();
    },
    undo: function()
    {
      this.con.setSource(this.oldSourcePort);
      this.con.setTarget(this.oldTargetPort);
      this.con.routingRequired =true;
      this.con.repaint();
    },
    redo: function()
    {
      this.con.setSource(this.newSourcePort);
      this.con.setTarget(this.newTargetPort);
      this.con.routingRequired =true;
      this.con.repaint();
    }
});
draw2d.command.CommandDelete = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandDelete",
    init: function( figure)
    {
       this._super(draw2d.Configuration.i18n.command.deleteShape);
       this.parent   = figure.getParent();
       this.figure   = figure;
       this.canvas   = figure.getCanvas();
       this.connections = null;
       this.removedParentEntry = null; 
       this.indexOfChild = -1;
    },
    canExecute: function()
    {
        return this.figure.getCanvas()!==null;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        if(this.parent!==null){
            this.parent.add(this.removedParentEntry.figure, this.removedParentEntry.locator, this.indexOfChild);
            this.canvas.setCurrentSelection(this.parent);
        }
        else{
            this.canvas.add(this.figure);
            this.canvas.setCurrentSelection(this.figure);
        }
        if(this.figure instanceof draw2d.Connection){
           this.figure.reconnect();
        }
        for (var i = 0; i < this.connections.getSize(); ++i){
           this.canvas.add(this.connections.get(i));
           this.connections.get(i).reconnect();
        }
    },
    redo: function()
    {
       this.canvas.setCurrentSelection(null);
       if(this.connections===null)
       {
          if(this.figure instanceof draw2d.shape.node.Node){
              this.connections = this.figure.getConnections();
          }
          else{
              this.connections = new draw2d.util.ArrayList();
          }
       }
       for (var i = 0; i < this.connections.getSize(); ++i){
           this.canvas.remove(this.connections.get(i));
       }
       if(this.parent!==null){
          this.indexOfChild = this.parent.getChildren().indexOf(this.figure);
          this.removedParentEntry= this.parent.remove(this.figure);
       }
       else{
           this.canvas.remove(this.figure);
       }
    }
});
draw2d.command.CommandDeleteGroup = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandDeleteGroup",
    init: function( group)
    {
       this._super(draw2d.Configuration.i18n.command.deleteShape);
       this.parent   = group.getParent();
       this.group    = group;
       this.canvas   = group.getCanvas();
       this.removedParentEntry = null; 
       this.indexOfChild = -1;
       this.batchDelete = null;
    },
    canExecute: function()
    {
        var children = this.group.getAssignedFigures();
        for(var i=0; i<children.getSize();i++){
            if(children.get(i).isDeleteable()===false){
                return false;
            }
        }
        return this.group.getCanvas()!==null;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.batchDelete.undo();
        this.canvas.setCurrentSelection(this.group);
    },
    redo: function()
    {
        if(this.batchDelete ===null){
            this.batchDelete = new  draw2d.command.CommandCollection();
            this.batchDelete.add(new  draw2d.command.CommandUngroup(this.canvas, this.group));
            var children = this.group.getAssignedFigures();
            for(var i=0; i<children.getSize();i++){
                var child = children.get(i);
                var cmd = child.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE));
                this.batchDelete.add(cmd);
            }
        }
        this.batchDelete.execute();
    }
});
draw2d.command.CommandAdd = draw2d.command.Command.extend({
    NAME: "draw2d.command.CommandAdd",
    init: function(canvas, figure, x,y)
    {
       this._super(draw2d.Configuration.i18n.command.addShape);
       this.figure = figure;
       this.canvas = canvas;
       this.pos = new draw2d.geo.Point(x,y);
    },
    canExecute: function()
    {
        return this.figure.getCanvas()===null;
    },
    execute: function()
    {
       this.canvas.add(this.figure, this.pos.x, this.pos.y);
    },
    redo: function()
    {
        this.execute();
    },
    undo: function()
    {
        this.canvas.remove(this.figure);
    }
});
draw2d.command.CommandGroup = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandGroup", 
    init: function(canvas,  figures)
    {
       this._super(draw2d.Configuration.i18n.command.groupShapes);
       if(figures instanceof draw2d.Selection){
           this.figures = figures.getAll();
       }
       else{
           this.figures = figures;
       }
       this.figures.grep(function(figure){
           return figure.getComposite()===null;
       });
       this.canvas = canvas;
       this.group = new draw2d.shape.composite.Group();
    },
    canExecute: function()
    {
      return !this.figures.isEmpty();
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        var _this=this;
        this.figures.each(function(i,figure){
            _this.group.unassignFigure(figure);
        });
        this.canvas.remove(this.group);
        this.canvas.setCurrentSelection(this.figures);
    },
    redo: function()
    {
        var _this = this;
        this.figures.each(function(i,figure){
            _this.group.assignFigure(figure);
        });
        this.canvas.add(this.group);
        this.canvas.setCurrentSelection(this.group);
    }
});
draw2d.command.CommandUngroup = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandUngroup", 
    init: function(canvas,  group)
    {
       this._super(draw2d.Configuration.i18n.command.ungroupShapes);
       if(group instanceof draw2d.Selection){
           this.group = group.getAll().first();
       }
       else{
           this.group   = group;
       }
       this.canvas = canvas;
       this.figures = this.group.getAssignedFigures().clone();
    },
    canExecute: function()
    {
      return !this.figures.isEmpty();
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        var _this = this;
        this.figures.each(function(i,figure){
            _this.group.assignFigure(figure);
        });
        this.canvas.add(this.group);
        this.canvas.setCurrentSelection(this.group);
    },
    redo: function()
    {
        var _this = this;
        this.figures.each(function(i,figure){
            _this.group.unassignFigure(figure);
        });
        this.canvas.setCurrentSelection(this.figures);
        this.canvas.remove(this.group);
    }
});
draw2d.command.CommandAddVertex = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandAddVertex", 
    init: function(line, index, x ,y)
    {
        this._super(draw2d.Configuration.i18n.command.addVertex);
        this.line = line;
        this.index = index;
        this.newPoint = new draw2d.geo.Point(x,y);
    },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.line.removeVertexAt(this.index);
    },
    redo: function()
    {
        this.line.insertVertexAt(this.index, this.newPoint.x, this.newPoint.y);
    }
});
draw2d.command.CommandAssignFigure = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandAssignFigure", 
    init: function(figure, composite)
    {
        this._super(draw2d.Configuration.i18n.command.assignShape);
        this.figure    = figure;
        this.composite = composite;
        this.assignedConnections = new draw2d.util.ArrayList();
        this.isNode = this.figure instanceof draw2d.shape.node.Node;
        this.oldBoundingBox = composite.getBoundingBox();
        this.newBoundingBox = null; 
   },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
        this.composite.assignFigure(this.figure);
        this.newBoundingBox = this.composite.getBoundingBox();
        if(this.isNode===true){
            var connections = this.figure.getConnections();
            var _this = this;
            connections.each(function(i, connection){
                if(connection.getSource().getParent().getComposite()===_this.composite && connection.getTarget().getParent().getComposite()===_this.composite){
                    if(connection.getComposite()!==_this.composite){
                        _this.assignedConnections.add({oldComposite:connection.getComposite(), connection:connection});
                        _this.composite.assignFigure(connection);
                    }
                }
            });
        }
    },
    undo: function()
    {
       this.composite.unassignFigure(this.figure);
       this.assignedConnections.each(function(i, entry){
           if(entry.oldComposite!==null){
               entry.oldComposite.assignFigure(entry.connection);
           }
           else{
               entry.connection.getComposite().unassignFigure(entry.connection);
           }
       });
       this.composite.stickFigures=true;
       this.composite.setBoundingBox(this.oldBoundingBox);
       this.composite.stickFigures=false;
    },
    redo: function()
    {
       this.composite.setBoundingBox(this.oldBoundingBox);
       this.composite.assignFigure(this.figure);
       var _this=this;
       this.assignedConnections.each(function(i, entry){
           _this.composite.assignFigure(entry.connection);
       });
    }
});
draw2d.command.CommandBoundingBox = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandResize", 
    init: function(figure, boundingBox)
    {
        this._super(draw2d.Configuration.i18n.command.resizeShape);
        this.figure = figure;
        this.oldBoundingBox = this.figure.getBoundingBox();
        this.newBoundingBox = boundingBox;
    },
    canExecute: function()
    {
      return !this.oldBoundingBox.equals(this.newBoundingBox);
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
       this.figure.setBoundingBox(this.oldBoundingBox);
    },
    redo: function()
    {
        this.figure.setBoundingBox(this.newBoundingBox);
    }
});
draw2d.command.CommandRemoveVertex = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandRemoveVertex", 
    init: function(line, index)
    {
        this._super(draw2d.Configuration.i18n.command.deleteVertex);
        this.line = line;
        this.index = index;
        this.oldPoint = line.getVertices().get(index).clone();
    },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
    	this.line.insertVertexAt(this.index, this.oldPoint.x, this.oldPoint.y);
    },
    redo: function()
    {
    	this.line.removeVertexAt(this.index);
    }
});
draw2d.command.CommandReplaceVertices = draw2d.command.Command.extend({
    NAME : "draw2d.command.CommandReplaceVertices", 
    init: function(line, originalVertices, newVertices)
    {
        this._super(draw2d.Configuration.i18n.command.addSegment);
        this.line = line;
        this.originalVertices = originalVertices;
        this.newVertices = newVertices;
    },
    canExecute: function()
    {
      return true;
    },
    execute: function()
    {
       this.redo();
    },
    undo: function()
    {
        this.line.setVertices(this.originalVertices);
    },
    redo: function()
    {
        this.line.setVertices(this.newVertices);
    }
});
draw2d.layout.connection.ConnectionRouter = Class.extend({
    NAME : "draw2d.layout.connection.ConnectionRouter",
    init: function()
    {
    },
    route: function( connection, routingHints)
    {
    	throw "subclasses must implement the method [ConnectionRouter.route]";
    },
    _paint: function(conn)
    {
        var ps = conn.getVertices();
        var p = ps.get(0);
        var radius = conn.getRadius();
        var path = ["M",(p.x|0)+0.5," ",(p.y|0)+0.5];
        var i=1;
        var length,inset, p2;
        if(radius>0){
            var lastP = p;
            length = (ps.getSize()-1);
            for(  ;i<length;i++){
                  p = ps.get(i);
                  inset = draw2d.geo.Util.insetPoint(p,lastP, radius);
                  path.push("L", (inset.x|0)+0.5, ",", (inset.y|0)+0.5);
                  p2 = ps.get(i+1);
                  inset = draw2d.geo.Util.insetPoint(p,p2,radius);
                  path.push("Q",p.x,",",p.y," ", (inset.x|0)+0.5, ", ", (inset.y|0)+0.5);
                  lastP = p;
            }
            p = ps.get(i);
            path.push("L", (p.x|0)+0.5, ",", (p.y|0)+0.5);
       }
        else{
            length = ps.getSize();
            for( ;i<length;i++){
                p = ps.get(i);
                path.push("L", (p.x|0)+0.5, ",", (p.y|0)+0.5);
          }
        }
         conn.svgPathString = path.join("");
     },
    onInstall: function(connection)
    {
    },
    onUninstall: function(connection)
    {
    },
    canRemoveVertexAt: function(index)
    {
        return false;
    },
    canRemoveSegmentAt: function(index)
    {
        return false;
    },
    getPersistentAttributes: function(line, memento)
    {   
        return memento;
    },
    setPersistentAttributes: function(line, memento)
    {
    },
    onDrag: function(line, dx, dy, dx2, dy2)
    {
    },
    verticesSet: function(line)
    {
    }
});
draw2d.layout.connection.DirectRouter = draw2d.layout.connection.ConnectionRouter.extend({
    NAME : "draw2d.layout.connection.DirectRouter",
    init: function()
    {
        this._super();
    },
    onInstall: function(connection)
    {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
    },
    invalidate: function()
    {
    },
    route: function( connection, routingHints)
    {
       var start =connection.getStartPoint();
       var end = connection.getEndPoint();
       connection.addPoint(start);
       connection.addPoint(end);
       var path = ["M",start.x," ",start.y];
       path.push("L", end.x, " ", end.y);
       connection.svgPathString = path.join("");
    }
});
draw2d.layout.connection.VertexRouter = draw2d.layout.connection.ConnectionRouter.extend({
    NAME : "draw2d.layout.connection.VertexRouter",
    init: function()
    {
        this._super();
    },
    onInstall: function(connection)
    {
        connection.installEditPolicy(new draw2d.policy.line.VertexSelectionFeedbackPolicy());
    },
    invalidate: function()
    {
    },
    route: function( connection, routingHints)
    {
       var count = routingHints.oldVertices.getSize();
       for(var i=0; i<count;i++){
           connection.addPoint(routingHints.oldVertices.get(i));
       }
       var ps = connection.getVertices();
       var startAnchor = connection.getStartPoint(ps.get(1));
       var endAnchor   = connection.getEndPoint(ps.get(ps.getSize()-2));
       ps.first().setPosition(startAnchor);
       ps.last().setPosition(endAnchor);
       this._paint(connection);
    },
    canRemoveVertexAt: function(conn, index)
    {
        return false;
    },
    canRemoveSegmentAt: function(conn, index)
    {
       var segmentCount= conn.getVertices().getSize()-1; 
       if( (index<=0) || (index>= segmentCount)){
          return false;
       }
       if(segmentCount<2){
          return false;
       }
       return true;
    },
    getPersistentAttributes: function(line, memento)
    {   
        memento.vertex = [];
        line.getVertices().each(function(i,e){
            memento.vertex.push({x:e.x, y:e.y});
        });
        return memento;
    },
    setPersistentAttributes: function(line, memento)
    {
        if($.isArray(memento.vertex) && memento.vertex.length>1){
            line.oldPoint=null;
            line.lineSegments = new draw2d.util.ArrayList();
            line.setVertices(memento.vertex);
        }
    },
    onDrag: function(line, dx, dy, dx2, dy2)
    {
       var count = line.getVertices().getSize() - 1;
        for (var i = 1; i < count; i++) {
            line.getVertex(i).translate(dx2, dy2);
        }
    }
});
draw2d.layout.connection.ManhattanConnectionRouter = draw2d.layout.connection.ConnectionRouter.extend({
    NAME : "draw2d.layout.connection.ManhattanConnectionRouter",
	MINDIST : 20,
	TOL     : 0.1,
	TOLxTOL : 0.01,
    TOGGLE_DIST : 20,
    init: function()
	{
        this._super();
    },
    onInstall: function(connection)
    {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
    },
	route: function( conn, routingHints)
	{
	   var fromPt  = conn.getStartPoint();
	   var fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
       var toPt    = conn.getEndPoint();
	   var toDir   = conn.getTarget().getConnectionDirection( conn.getSource());
	   this._route(conn,toPt, toDir, fromPt, fromDir);
	   this._paint(conn);
	},
	_route: function( conn, fromPt, fromDir, toPt, toDir)
	{
	   var UP   = draw2d.geo.Rectangle.DIRECTION_UP;
	   var RIGHT= draw2d.geo.Rectangle.DIRECTION_RIGHT;
	   var DOWN = draw2d.geo.Rectangle.DIRECTION_DOWN;
	   var LEFT = draw2d.geo.Rectangle.DIRECTION_LEFT;
	   var xDiff = fromPt.x - toPt.x;
	   var yDiff = fromPt.y - toPt.y;
	   var point;
	   var dir;
       var pos;
	   if (((xDiff * xDiff) < (this.TOLxTOL)) && ((yDiff * yDiff) < (this.TOLxTOL))){
          conn.addPoint(new draw2d.geo.Point(toPt.x, toPt.y));
	      return;
	   }
	   if (fromDir === LEFT) {
	      if ((xDiff > 0) && ((yDiff * yDiff) < this.TOL) && (toDir === RIGHT)) {
	         point = toPt;
	         dir = toDir;
	      } 
	      else {
	         if (xDiff < 0) {
	            point = new draw2d.geo.Point(fromPt.x - this.MINDIST, fromPt.y);
	         }
	         else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) {
	            point = new draw2d.geo.Point(toPt.x, fromPt.y);
	         }
	         else if (fromDir == toDir) {
	            pos = Math.min(fromPt.x, toPt.x) - this.MINDIST;
	            point = new draw2d.geo.Point(pos, fromPt.y);
	         }
	         else{
	            point = new draw2d.geo.Point(fromPt.x - (xDiff / 2), fromPt.y);
	         }
	         if (yDiff > 0) {
	            dir = UP;
	         }
	         else{
	            dir = DOWN;
	         }
	      }
	   }
	   else if (fromDir === RIGHT)  {
	      if ((xDiff < 0) && ((yDiff * yDiff) < this.TOL)&& (toDir === LEFT)) 
	      {
	         point = toPt;
	         dir = toDir;
	      } 
	      else 
	      {
	         if (xDiff > 0) 
	         {
	           point = new draw2d.geo.Point(fromPt.x + this.MINDIST, fromPt.y);
	         } 
	         else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) 
	         {
	            point = new draw2d.geo.Point(toPt.x, fromPt.y);
	         } 
	         else if (fromDir === toDir) 
	         {
                pos = Math.max(fromPt.x, toPt.x) + this.MINDIST;
	            point = new draw2d.geo.Point(pos, fromPt.y);
	         } 
	         else 
	         {
	               point = new draw2d.geo.Point(fromPt.x - (xDiff / 2), fromPt.y);
	         }
	         if (yDiff > 0)
	         {
	            dir = UP;
	         }
	         else
	         {
	            dir = DOWN;
	         }
	      }
	   } 
	   else if (fromDir === DOWN) 
	   {
	      if (((xDiff * xDiff) < this.TOL) && (yDiff < 0)&& (toDir === UP)) 
	      {
	         point = toPt;
	         dir = toDir;
	      } 
	      else 
	      {
	         if (yDiff > 0) 
	         {
	            point = new draw2d.geo.Point(fromPt.x, fromPt.y + this.MINDIST);
	         } 
	         else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) 
	         {
	           point = new draw2d.geo.Point(fromPt.x, toPt.y);
	         } 
	         else if (fromDir === toDir) 
	         {
	            pos = Math.max(fromPt.y, toPt.y) + this.MINDIST;
	            point = new draw2d.geo.Point(fromPt.x, pos);
	         } 
	         else 
	         {
	            point = new draw2d.geo.Point(fromPt.x, fromPt.y - (yDiff / 2));
	         }
	         if (xDiff > 0) 
	         {
	            dir = LEFT;
	         }
	         else 
	         {
	            dir = RIGHT;
	         }
	      }
	   } 
	   else if (fromDir === UP) 
	   {
	      if (((xDiff * xDiff) < this.TOL) && (yDiff > 0) && (toDir === DOWN))
	      {
	         point = toPt;
	         dir = toDir;
	      } 
	      else 
	      {
	         if (yDiff < 0) 
	         {
	            point = new draw2d.geo.Point(fromPt.x, fromPt.y - this.MINDIST);
	         } 
	         else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) 
	         {
	            point = new draw2d.geo.Point(fromPt.x, toPt.y);
	         } 
	         else if (fromDir === toDir) 
	         {
                pos = Math.min(fromPt.y, toPt.y) - this.MINDIST;
	            point = new draw2d.geo.Point(fromPt.x, pos);
	         } 
	         else 
	         {
	            point = new draw2d.geo.Point(fromPt.x, fromPt.y - (yDiff / 2));
	         }
	         if (xDiff > 0)
	         {
	            dir = LEFT;
	         }
	         else
	         {
	            dir = RIGHT;
	         }
	      }
	   }
	   this._route(conn,point, dir, toPt, toDir);
	   conn.addPoint(fromPt);
	}
});
draw2d.layout.connection.ManhattanBridgedConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME : "draw2d.layout.connection.ManhattanBridgedConnectionRouter",
	BRIDGE_HORIZONTAL_LR : " r 0 0 3 -4 7 -4 10 0 13 0 ", 
    BRIDGE_HORIZONTAL_RL : " r 0 0 -3 -4 -7 -4 -10 0 -13 0 ", 
    init: function()
	{
        this._super();
    },
    onInstall: function(connection)
	{
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
    },
	route: function(conn, routingHints)
	{
		var fromPt  = conn.getStartPoint();
		var fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
		var toPt  = conn.getEndPoint();
		var toDir = conn.getTarget().getConnectionDirection( conn.getSource());
		this._route(conn, toPt, toDir, fromPt, fromDir);
        var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
        var intersectionsDESC= intersectionsASC.clone().reverse();
        var intersectionForCalc = intersectionsASC;
		var i = 0;
		var ps = conn.getVertices();
		var p = ps.get(0);
		var path = [ "M", (p.x|0)+0.5, " ", (p.y|0)+0.5 ];
		var oldP = p;
		for (i = 1; i < ps.getSize(); i++) {
			p = ps.get(i);
			var bridgeWidth = 5;
			var bridgeCode = this.BRIDGE_HORIZONTAL_LR;
			if (oldP.x > p.x) {
				intersectionForCalc=intersectionsDESC;
				bridgeCode = this.BRIDGE_HORIZONTAL_RL;
				bridgeWidth = -bridgeWidth;
			}
			intersectionForCalc.each(function(ii, interP) {
				if (interP.justTouching ==false && draw2d.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {
					if (p.y === interP.y) {
						path.push(" L", ((interP.x - bridgeWidth)|0)+0.5, " ", (interP.y|0)+0.5);
						path.push(bridgeCode);
					}
				}
			});
			path.push(" L", (p.x|0)+0.5, " ", (p.y|0)+0.5);
			oldP = p;
		}
		conn.svgPathString = path.join("");
	}
});
draw2d.layout.connection.InteractiveManhattanConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME : "draw2d.layout.connection.InteractiveManhattanConnectionRouter",
    init: function()
    {
        this._super();
    },
    onInstall: function(conn)
    {
        conn.installEditPolicy(new draw2d.policy.line.OrthogonalSelectionFeedbackPolicy());
        if(!conn._routingMetaData){
            conn._routingMetaData = {
                routedByUserInteraction:false,
                fromDir:-1,
                toDir:-1
            };
        }
    },
    onUninstall: function(conn)
    {
        delete conn._routingMetaData;
    },
    route: function(conn, routingHints)
    {
        if (!routingHints.oldVertices) {
            debugger
        }
        if(routingHints.oldVertices.getSize()===0 || conn._routingMetaData.routedByUserInteraction===false){
            this._super(conn, routingHints);
            conn._routingMetaData.fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
            conn._routingMetaData.toDir   = conn.getTarget().getConnectionDirection( conn.getSource());
        }
        else{
            this.halfRoute(conn, routingHints);
            this._paint(conn);
        }
    },
    halfRoute: function(conn, routingHints)
    {
        var MINDIST = this.MINDIST;
        var max = Math.max;
        var min = Math.min;
        routingHints = routingHints||{};
        var oldVertices = routingHints.oldVertices;
        var vertexCount  = oldVertices.getSize();
        var fromPt  = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
        var toPt    = conn.getEndPoint();
        var toDir   = conn.getTarget().getConnectionDirection( conn.getSource());
        if(conn._routingMetaData.fromDir !== fromDir || conn._routingMetaData.toDir !== toDir){
            conn._routingMetaData.routedByUserInteraction = false;
            this.route(conn, oldVertices);
        }
        if(    (fromDir===draw2d.geo.Rectangle.DIRECTION_RIGHT ) && (toDir === draw2d.geo.Rectangle.DIRECTION_LEFT)
            && (fromPt.x > toPt.x) && (vertexCount<=4)){
            conn._routingMetaData.routedByUserInteraction = false;
            this.route(conn, {oldVertices:oldVertices});
        }
        oldVertices.each(function(i,vertex){
            conn.addPoint(vertex);
        });
        if(conn.isInDragDrop){
            return;
        }
        if(routingHints.startMoved || !fromPt.equals(oldVertices.get(0))){
            var p1 = oldVertices.get(1);
            var p2 = oldVertices.get(2);
            conn.setVertex(0,fromPt);
            switch(fromDir){
                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                    conn.setVertex(1,max(fromPt.x+MINDIST,p1.x),fromPt.y);
                    conn.setVertex(2,max(fromPt.x+MINDIST,p1.x),p2.y);    
                    break;
                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                    conn.setVertex(1,min(fromPt.x-MINDIST,p1.x),fromPt.y);
                    conn.setVertex(2,min(fromPt.x-MINDIST,p1.x),p2.y);    
                    break;
                case draw2d.geo.Rectangle.DIRECTION_UP:
                    conn.setVertex(1,fromPt.x, min(fromPt.y-MINDIST,p1.y)); 
                    conn.setVertex(2,p2.x    , min(fromPt.y-MINDIST,p1.y)); 
                    break;
                case draw2d.geo.Rectangle.DIRECTION_DOWN:
                    conn.setVertex(1,fromPt.x, max(fromPt.y+MINDIST,p1.y)); 
                    conn.setVertex(2,p2.x    , max(fromPt.y+MINDIST,p1.y));     
                    break;
            }
        }
        if(routingHints.endMoved || !toPt.equals(oldVertices.get(vertexCount-1))){
            var p1 = oldVertices.get(vertexCount-2);
            var p2 = oldVertices.get(vertexCount-3);
            conn.setVertex(vertexCount-1,toPt);                        
            switch(toDir){
                case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                    conn.setVertex(vertexCount-2,max(toPt.x+MINDIST,p1.x),toPt.y);  
                    conn.setVertex(vertexCount-3,max(toPt.x+MINDIST,p1.x),p2.y);    
                    break;
                case draw2d.geo.Rectangle.DIRECTION_LEFT:
                    conn.setVertex(vertexCount-2,min(toPt.x-MINDIST,p1.x),toPt.y);  
                    conn.setVertex(vertexCount-3,min(toPt.x-MINDIST,p1.x),p2.y);    
                    break;
                case draw2d.geo.Rectangle.DIRECTION_UP:
                    conn.setVertex(vertexCount-2, toPt.x,min(toPt.y-MINDIST,p1.y));  
                    conn.setVertex(vertexCount-3, p2.x  ,min(toPt.y-MINDIST,p1.y));  
                    break;
                case draw2d.geo.Rectangle.DIRECTION_DOWN:
                    conn.setVertex(vertexCount-2,toPt.x,max(toPt.y+MINDIST,p1.y));  
                    conn.setVertex(vertexCount-3,p2.x  ,max(toPt.y+MINDIST,p1.y));  
                    break;
            }
        }
    },
    canRemoveSegmentAt: function(conn, index){
        var segmentCount= conn.getVertices().getSize()-1; 
        if( (index<=0) || ((index+1)>= segmentCount)){
            return false;
        }
        if(segmentCount<4){
            return false;
        }
        var fromPt  = conn.getStartPoint();
        var fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
        var toPt    = conn.getEndPoint();
        var toDir   = conn.getTarget().getConnectionDirection( conn.getSource());
        if(segmentCount<=5){
            if( (fromDir === draw2d.geo.Rectangle.DIRECTION_RIGHT) && ( toDir === draw2d.geo.Rectangle.DIRECTION_LEFT) && (fromPt.x >= toPt.x)){
                return false;
            }
            if( (fromDir == draw2d.geo.Rectangle.DIRECTION_LEFT) & ( toDir == draw2d.geo.Rectangle.DIRECTION_RIGHT) && (fromPt.x <= toPt.x)){
                return false;
            }
            if( (fromDir == draw2d.geo.Rectangle.DIRECTION_UP) & ( toDir == draw2d.geo.Rectangle.DIRECTION_DOWN) && (fromPt.y <= toPt.y)){
                return false;
            }
            if( (fromDir == draw2d.geo.Rectangle.DIRECTION_DOWN) & ( toDir == draw2d.geo.Rectangle.DIRECTION_UP) && (fromPt.y >= toPt.y)){
                return false;
            }
            var tmpConn = new draw2d.Connection();
            tmpConn.lineSegments = new draw2d.util.ArrayList();
            tmpConn.vertices   = new draw2d.util.ArrayList();
            tmpConn.sourcePort = conn.sourcePort;
            tmpConn.targetPort = conn.targetPort;
            tmpConn._routingMetaData = {routedByUserInteraction:false,fromDir:-1,toDir:-1};
            this.route(tmpConn, {oldVertices:new draw2d.util.ArrayList()});
            var curSegmentCount = conn.getVertices().getSize()-1;
            var minSegmentCount = tmpConn.getVertices().getSize()-1;
            if(curSegmentCount<=minSegmentCount){
                return false;
            }
        }
        return true;
    },
    onDrag: function(line, dx, dy, dx2, dy2)
    {
        var i=0;
        if(line.draggedSegment===null){
            var count = line.getVertices().getSize()-1;
            for( i=1; i<count;i++){
                line.getVertex(i).translate(dx2, dy2);
            }
            return;
        }
        if(line.draggedSegment.index===0 || line.draggedSegment.index === (line.getSegments().getSize()-1)){
            return;
        }
        line._routingMetaData.routedByUserInteraction = true;
        var p0  = line.draggedSegment.start;
        var p1  = line.draggedSegment.end;
            i   = line.draggedSegment.index;
        var lp0 = line.getVertices().first();
        var lp1 = line.getVertices().last();
        var distance=0;
        if(p0.y === p1.y) {
            if(i === 1) distance =p0.y - lp0.y;
            if(i === line.getSegments().getSize()-2)  distance =p1.y - lp1.y;
            if(distance<0 && dy2>0) {
                dy2 = Math.min(dy2, (-distance)-this.MINDIST);
            }
            else if(distance>0 && dy2<0) {
                dy2 = -Math.min(-dy2, (distance)-this.MINDIST);
            }
            line.getVertex(i).translate(0, dy2);
            line.getVertex(i+1).translate(0, dy2);
        }
        else if(p0.x === p1.x){
            if (i === 1) {
                distance =p0.x - lp0.x;
                if(distance<0 && dx2>0) {
                    dx2 = Math.min(dx2, (-distance)-this.MINDIST);
                }
                else if(distance>0 && dx2<0) {
                    dx2 = -Math.min(-dx2, (distance)-this.MINDIST);
                }
            }
            if(i === line.getSegments().getSize()-2)  {
                distance =p1.x - lp1.x;
                if(distance<0 && dx2>0) {
                    dx2 = Math.min(dx2, (-distance)-this.MINDIST);
                }
                else if(distance>0 && dx2<0) {
                    dx2 = -Math.min(-dx2, (distance)-this.MINDIST);
                }
            }
            line.getVertex(i).translate(dx2, 0);
            line.getVertex(i+1).translate(dx2, 0);
        }
    },
    verticesSet: function(conn)
    {
        conn._routingMetaData.routedByUserInteraction = true;
        if(conn.getSource()!==null && conn.getTarget()!==null) {
            conn._routingMetaData.fromDir = conn.getSource().getConnectionDirection(conn.getTarget());
            conn._routingMetaData.toDir = conn.getTarget().getConnectionDirection(conn.getSource());
        }
    },
    getPersistentAttributes: function(line, memento)
    {
        memento.vertex = [];
        line.getVertices().each(function(i,e){
            memento.vertex.push({x:e.x, y:e.y});
        });
        memento.routingMetaData = $.extend({},line._routingMetaData);
        return memento;
    },
    setPersistentAttributes: function(line, memento)
    {
        if($.isArray(memento.vertex)){
            line.oldPoint=null;
            line.lineSegments = new draw2d.util.ArrayList();
            line.setVertices(memento.vertex);
        }
        if(typeof memento.routingMetaData !== "undefined"){
            line._routingMetaData = $.extend({},memento.routingMetaData);
        }
    }
});
draw2d.layout.connection.CircuitConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME : "draw2d.layout.connection.CircuitConnectionRouter",
    init: function()
    {
        this._super();
        this.setBridgeRadius(4);
        this.setVertexRadius(2);
        this.abortRoutingOnFirstVertexNode=false;
    },
    onInstall: function(connection)
    {
        connection.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
    },
    onUninstall: function(connection)
    {
        if(typeof connection.vertexNodes!=="undefined" && connection.vertexNodes!==null){
            connection.vertexNodes.remove();
            connection.vertexNodes = null;
        }
    },
    setVertexRadius: function(radius)
    {
        this.vertexRadius=radius;
        return this;
    },
    setJunctionRadius: function(radius){ this.vertexRadius=radius;},
    setBridgeRadius: function(radius)
    {
        this.bridgeRadius=radius;
        this.bridge_LR = [" r", 0.5, -0.5, radius-(radius/2), -(radius-radius/4), radius, -radius,radius+(radius/2), -(radius-radius/4), radius*2, "0 "].join(" ");
        this.bridge_RL = [" r", -0.5, -0.5, -(radius-(radius/2)), -(radius-radius/4), -radius, -radius,-(radius+(radius/2)), -(radius-radius/4), -radius*2, "0 "].join(" ");
        return this;
    },
	route: function(conn, routingHints)
    {
		var fromPt  = conn.getStartPoint();
		var fromDir = conn.getSource().getConnectionDirection( conn.getTarget());
		var toPt  = conn.getEndPoint();
		var toDir = conn.getTarget().getConnectionDirection( conn.getSource());
		this._route(conn, toPt, toDir, fromPt, fromDir);
        var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
        var intersectionsDESC= intersectionsASC.clone().reverse();
        var intersectionForCalc = intersectionsASC;
        var i = 0;
        if(typeof conn.vertexNodes!=="undefined" && conn.vertexNodes!==null){
            conn.vertexNodes.remove();
        }
        conn.vertexNodes = conn.canvas.paper.set();
		var ps = conn.getVertices();
		var p = ps.get(0);
        var path = [ "M", (p.x|0)+0.5, " ", (p.y|0)+0.5 ];
        var oldP = p;
        var bridgeWidth = null;
        var bridgeCode  = null;
        var lastVertexNode=null;
        for (i = 1; i < ps.getSize(); i++) {
			p = ps.get(i);
            if (oldP.x > p.x) {
                intersectionForCalc=intersectionsDESC;
                bridgeCode = this.bridge_RL;
                bridgeWidth = -this.bridgeRadius;
            }
            else{
                intersectionForCalc=intersectionsASC;
                bridgeCode = this.bridge_LR;
                bridgeWidth = this.bridgeRadius;
            }
            intersectionForCalc.each($.proxy(function(ii, interP) {
                if (draw2d.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {
    			    if(conn.sharingPorts(interP.other)){
    			        var other = interP.other;
                        var otherZ = other.getZOrder();
                        var connZ = conn.getZOrder();
                        if(connZ<otherZ){
                            var vertexNode=conn.canvas.paper.ellipse(interP.x,interP.y, this.vertexRadius, this.vertexRadius).attr({fill:conn.lineColor.hash()});
        			        conn.vertexNodes.push(vertexNode);
        			        if(this.abortRoutingOnFirstVertexNode===true){
            				    if(conn.getSource()==other.getSource()|| conn.getSource()==other.getTarget()){
            				        path = [ "M", (interP.x|0)+0.5, " ", (interP.y|0)+0.5 ];
            				        if(lastVertexNode!==null){
                                        lastVertexNode.remove();
            				            conn.vertexNodes.exclude(lastVerteNode);
            				        }
            				    }
                                lastVertexNode = vertexNode;
        			        }
                        }
    			    }
    			    else if (p.y === interP.y) {
                        path.push(" L", ((interP.x - bridgeWidth)|0)+0.5, " ", (interP.y|0)+0.5);
                        path.push(bridgeCode);
    			    }
                }
			},this));
			path.push(" L", (p.x|0)+0.5, " ", (p.y|0)+0.5);
			oldP = p;
		}
		conn.svgPathString = path.join("");
	}
});
draw2d.layout.connection.MuteableManhattanConnectionRouter = draw2d.layout.connection.ManhattanConnectionRouter.extend({
    NAME : "draw2d.layout.connection.MuteableManhattanConnectionRouter",
    UP      : new draw2d.geo.Ray(0, -1),
    DOWN    : new draw2d.geo.Ray(0, 1),
    LEFT    : new draw2d.geo.Ray(-1, 0),
    RIGHT   : new draw2d.geo.Ray(1, 0),
    init: function()
    {
        this._super();
        this.rowsUsed     = {};
        this.colsUsed     = {};
        this.constraints  = {};
        this.reservedInfo = {};
    },
    route: function( conn, routingHints)
    {
        this.rowsUsed     = {};
        this.colsUsed     = {};
        this.constraints  = {};
        this.reservedInfo = {};
        var canvas = conn.getCanvas();
        var i;
        var startPoint= conn.getStartPoint();
        var endPoint= conn.getEndPoint();
        var start   = new draw2d.geo.Ray(startPoint);
        var end     = new draw2d.geo.Ray(endPoint);
        var average = new draw2d.geo.Ray((start.x+end.x)/2,(start.y+end.y)/2);
        var direction   = new draw2d.geo.Ray(end.x-start.x, end.y-start.y);
        var startNormal = this.getStartDirection(conn);
        var endNormal   = this.getEndDirection(conn);
        var positions  = new draw2d.util.ArrayList();
        var horizontal = startNormal.isHorizontal();
        if (horizontal){
            positions.add(start.y);
        }
        else{
            positions.add(start.x);
        }
        horizontal = !horizontal;
        if (startNormal.dot(endNormal) === 0) {
            if ((startNormal.dot(direction) >= 0)  && (endNormal.dot(direction) <= 0)) {
            } else {
                if (startNormal.dot(direction) < 0)
                    i = startNormal.similarity(start.translated(startNormal.getScaled(10)));
                else {
                    if (horizontal) 
                        i = average.y;
                    else 
                        i = average.x;
                }
                positions.add(i);
                horizontal = !horizontal;
                if (endNormal.dot(direction) > 0){
                    i = endNormal.similarity(end.translated(endNormal.getScaled(10)));
                }
                else {
                    if (horizontal) {
                        i = average.y;
                    }
                    else {
                        i = average.x;
                    }
                }
                positions.add(i);
                horizontal = !horizontal;
            }
        } else {
            if (startNormal.dot(endNormal) > 0) {
                if (startNormal.dot(direction) >= 0)
                    i = startNormal.similarity(start.translated(startNormal.getScaled(10)));
                else
                    i = endNormal.similarity(end.translated(endNormal.getScaled(10)));
                positions.add( i);
                horizontal = !horizontal;
            } else {
                if (startNormal.dot(direction) < 0) {
                    i = startNormal.similarity(start.translated(startNormal.getScaled(10)));
                    positions.add(i);
                    horizontal = !horizontal;
                }
                if (this.isCycle(conn)) {
                    if (horizontal)
                        i = conn.getSource().getParent().getBoundingBox().getTop() - 10;
                    else
                        i = conn.getSource().getParent().getBoundingBox().getRight() + 10;
                } else {
                    if (horizontal) {
                        var j = average.y;
                        var next = endNormal.similarity(end.translated(endNormal.getScaled(10)));
                        var trial = new draw2d.geo.Ray((positions.get(positions.getSize() - 1)), j);
                        var figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, draw2d.util.ArrayList.EMPTY_LIST);
                        while (figure != null && figure.getBoundingBox().x + figure.getBoundingBox().width > next) {
                            j = figure.getBoundingBox().y + figure.getBoundingBox().height + 5;
                            trial.y = j;
                            figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, Collections.EMPTY_LIST);                        
                        }
                        i = j;
                    } else {
                        var figure = this.findFirstFigureAtStraightLine(canvas, start, this.RIGHT, this.getExcludingFigures(conn));
                        if (figure == null)
                            i = average.x;
                        else {
                            i = Math.min(average.x, start.translated(new draw2d.geo.Ray(3 * (figure.getBoundingBox().x - start.x) / 4, 0)).x);
                            i = Math.max(start.x, i);
                        }
                        i = this.adjust(conn, i);
                    }
                }
                positions.add(i);
                horizontal = !horizontal;
            }
        }
        if (horizontal) 
            positions.add(end.y);
        else 
            positions.add( end.x);
        this.processPositions(start, end, positions, startNormal.isHorizontal(), conn);
        this._paint(conn);
    },
    getColumnNear: function (connection, r, n, x)
    {
        var min = Math.min(n, x);
        var max = Math.max(n, x);
        if (min > r) {
            max = min;
            min = r - (min - r);
        }
        if (max < r) {
            min = max;
            max = r + (r - max);
        }
        var proximity = 0;
        var direction = -1;
        if (r % 6 != 0){
            r = r - ( r % 6);
        }
        var i;
        while (proximity < r) {
            i = parseInt(r + proximity * direction);
            if (! (i in this.colsUsed)) {
                this.colsUsed[i]= i;
                this.reserveColumn(connection, i);
                return i;
            }
            if (i <= min){
                return i + 6;
            }
            if (i >= max){
                return i - 6;
            }
            if (direction === 1){
                direction = -1;
            }
            else {
                direction = 1;
                proximity += 6;
            }
        }
        return r;
    },
    getRowNear: function(connection, r, n, x)
    {
        var min = Math.min(n, x);
        var max = Math.max(n, x);
        if (min > r) {
            max = min;
            min = r - (min - r);
        }
        if (max < r) {
            min = max;
            max = r + (r - max);
        }
        var proximity = 0;
        var direction = -1;
        if (r % 6 != 0){
            r = r - ( r % 6);
        }
        var i;
        while (proximity < r) {
            i = parseInt(r + proximity * direction);
            if (! (i in this.rowsUsed)) {
                this.rowsUsed[i]= i;
                this.reserveRow(connection, i);
                return i;
            }
            if (i <= min)
                return i + 6;
            if (i >= max)
                return i - 6;
            if (direction == 1)
                direction = -1;
            else {
                direction = 1;
                proximity += 6;
            }
        }
        return r;
    },
    getEndDirection: function( conn)
    {
        var p    = conn.getEndPoint();
        var rect= conn.getTarget().getParent().getBoundingBox();
        return this.getDirection(rect, p);
    },
    getStartDirection: function( conn)
    {
        var p    = conn.getStartPoint();
        var rect= conn.getSource().getParent().getBoundingBox();
        return this.getDirection(rect, p);
    },
    getDirection: function( r,  p)
    {
        var i=Math.abs(r.y - p.y);
        var distance = Math.abs(r.x - p.x);
        var direction = this.LEFT;
        if (i <= distance) {
            distance = i;
            direction = this.UP;
        }
        i = Math.abs(r.getBottom() - p.y);
        if (i <= distance) {
          distance = i;
          direction = this.DOWN;
        }
        i = Math.abs(r.getRight() - p.x);
        if (i < distance) {
            distance = i;
            direction = this.RIGHT;
        }
        return direction;
    },
    processPositions: function( start,  end,  positions,  horizontal,  conn)
    {
        this.removeReservedLines(conn);
        var pos =  [];
        if (horizontal)
            pos.push(start.x);
        else
            pos.oush(start.y);
        var i;
        for (i = 0; i < positions.getSize(); i++) {
            pos.push(positions.get(i));
        }
        if (horizontal == (positions.getSize() % 2 == 1)){
            pos.push(end.x);
        }
        else{
            pos.push(end.y);
        }
        conn.addPoint(new draw2d.geo.Point(start.x, start.y));
        var p;
        var current, prev, min, max;
        var adjust;
        for (i = 2; i < pos.length - 1; i++) {
            horizontal = !horizontal;
            prev = pos[i - 1];
            current = pos[i];
            adjust = (i !== pos.length - 2);
            if (horizontal) {
                if (adjust) {
                    min = pos[i - 2];
                    max = pos[i + 2];
                    pos[i] = current = this.getRowNear(conn, current, min, max);
                }
                p = new draw2d.geo.Point(prev, current);
            } else {
                if (adjust) {
                    min = pos[i - 2];
                    max = pos[i + 2];
                    pos[i] = current = this.getColumnNear(conn, current, min, max);
                }
                p = new draw2d.geo.Point(current, prev);
            }
            conn.addPoint(p);
        }
        conn.addPoint(new draw2d.geo.Point(end.x, end.y));
    },
   removeReservedLines: function( connection)
   {
        var rInfo = this.reservedInfo[connection];
        if ( typeof rInfo ==="undefined" || rInfo === null) 
            return;
        for (var i = 0; i < rInfo.reservedRows.getSize(); i++) {
            delete this.rowsUsed[rInfo.reservedRows.get(i)];
        }
        for (var i = 0; i < rInfo.reservedCols.getSize(); i++) {
            delete this.colsUsed[rInfo.reservedCols.get(i)];
        }
        delete this.reservedInfo[connection];
    },
    reserveColumn: function( connection,  column)
    {
        var info = this.reservedInfo[connection];
        if ( typeof info ==="undefined" || info === null) {
           info = {reservedCols: new draw2d.util.ArrayList(), reservedRows: new draw2d.util.ArrayList()};
           this.reservedInfo[connection] = info;
        }
        info.reservedCols.add(column);
    },
    reserveRow: function(connection, row)
    {
        var info = this.reservedInfo[connection];
        if ( typeof info ==="undefined" || info === null) {
            info = {reservedCols: new draw2d.util.ArrayList(), reservedRows: new draw2d.util.ArrayList()};
            this.reservedInfo[connection] = info;
        }
        info.reservedRows.add(row);
    },
    getConstraint: function( connection)
    {
        return this.constraints[connection];
    },
    setConstraint: function( connection,  constraint)
    {
        this.constraints[connection]= constraint;
    },
    isCycle: function( conn)
    {
        var source = conn.getSource().getParent();
        var target = conn.getTarget().getParent();
        return source.id===target.id;
    },
    getExcludingFigures: function( conn)
    {
        var excluding = new draw2d.util.ArrayList();
        excluding.add(conn.getSource().getParent());
        excluding.add(conn.getTarget().getParent());
        return excluding;
    },
    findFirstFigureAtStraightLine: function(canvas,  start,  direction,  excluding)
    {
        var figure = null;
        var figures = canvas.getFigures();
        var _this = this;
        figures.each(function(i,child) {
            try{
                if (!excluding.contains(child)) {
                    var rect = child.getBoundingBox();
                    if (_this.LEFT.equals(direction)) {
                        if (start.x > rect.x && start.y >= rect.y && start.y <= rect.y + rect.h) {                 
                            if (figure === null || rect.x > figure.getBoundingBox().x)
                                figure = child;
                        }
                    } else if (_this.RIGHT.equals(direction)) {
                        if (start.x < rect.x + rect.w && start.y >= rect.y && start.y <= rect.y + rect.h) {                    
                            if (figure == null || rect.x < figure.getBoundingBox().x)
                                figure = child;
                        } 
                    } else if (_this.UP.equals(direction)){
                        if (start.y > rect.y && start.x >= rect.x && start.x <= rect.x + rect.w) {
                            if (figure === null || rect.y > figure.getBoundingBox().y)
                                figure = child;
                        }           
                    } else if (_this.DOWN.equals(direction)){
                        if (start.y < rect.y + rect.h && start.x >= rect.x && start.x <= rect.x + rect.w) {
                            if (figure === null || rect.y < figure.getBoundingBox().y)
                                figure = child;
                        }                   
                    }
                }
            }
            catch(exc){
                console.log(exc);
                debugger;
            }
        });
        return figure;
    },
    adjust: function( connection,  col)
    {
        var column = col;
        var start = connection.getSource().getPosition();
        var connections = connection.getCanvas().getLines();
        connections.each(function(i,conn) {
            try{
                if (conn===connection)
                    return;
                var end = conn.getTarget().getPosition();
                if (start.x < end.x && start.y == end.y) {
                    if (conn.getVertices().getMidpoint().x <= col)
                        column = conn.getVertices().getMidpoint().x - 5;
                }
            }
            catch(exc){
                console.log(exc);
                debugger;
            }
        });
        return column;
    }
});
draw2d.layout.locator.Locator= Class.extend({
    NAME : "draw2d.layout.locator.Locator",
    init: function( )
    {
    },
    bind: function(figure, child)
    {
        child.setDraggable(false);
        child.setSelectable(false);
    },
    unbind: function(figure, child)
    {
    },
    relocate: function(index, figure)
    {
        figure.repaint();
    },
    clone: function()
    {
        return eval("new "+this.NAME+"()");
    }
});
draw2d.layout.locator.PortLocator = draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.PortLocator",
    init: function( )
    {
      this._super();
    },
    applyConsiderRotation: function(port, x, y)
    {
    	var parent = port.getParent();
        var halfW = parent.getWidth()/2;
        var halfH = parent.getHeight()/2;
    	var rotAngle = parent.getRotationAngle();
    	var m = Raphael.matrix();
    	m.rotate(rotAngle, halfW, halfH);
        if(rotAngle=== 90|| rotAngle===270){
            var ratio = parent.getHeight()/parent.getWidth();
            m.scale(ratio, 1/ratio, halfW, halfH);
        }
        port.setPosition( m.x(x,y), m.y(x,y));
    }
});
draw2d.layout.locator.DraggableLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.DraggableLocator",
    init: function( )
    {
        this._super();
    },
    bind: function(parent, child)
    {
        child.setSelectionAdapter( function(){
            return child;
        });
    },
    unbind: function(parent, child)
    {
        child.setSelectionAdapter(null);
    }
});
draw2d.layout.locator.SmartDraggableLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.SmartDraggableLocator",
    init: function( )
    {
        this._super();
        this.boundedCorners={
            init:false,
            parent:0,
            child:0,
            dist: Number.MAX_SAFE_INTEGER,
            xOffset: 0,
            yOffset: 0
        }
    },
    bind: function(parent, child)
    {
        var _this = this;
        var calcBoundingCorner=function() {
            _this.boundedCorners={
                init:false,
                parent:0,
                child:0,
                dist: Number.MAX_SAFE_INTEGER,
                xOffset: 0,
                yOffset: 0
            };
            var parentVertices = child.getParent().getBoundingBox().getVertices();
            var childVertices  = child.getBoundingBox().getVertices();
            var i_parent, i_child;
            var p1, p2, distance;
            for (i_parent = 0; i_parent < parentVertices.getSize(); i_parent++) {
                for (i_child = 0; i_child < childVertices.getSize(); i_child++) {
                    p1 = parentVertices.get(i_parent);
                    p2 = childVertices.get(i_child);
                    distance = Math.abs(p1.distance(p2));
                    if (distance < _this.boundedCorners.dist) {
                        _this.boundedCorners = {
                            parent: i_parent,
                            child: i_child,
                            dist: distance,
                            xOffset:p1.x-p2.x,
                            yOffset:p1.y-p2.y
                        }
                    }
                }
            }
            _this.boundedCorners.init=true;
        };
        child.setSelectionAdapter( function(){
            return child;
        });
        child.getParent().on("added",calcBoundingCorner);
        child.on("dragend",calcBoundingCorner);
    },
    unbind: function(parent, child)
    {
        child.setSelectionAdapter(null);
    },
    relocate: function(index, figure)
    {
        this._super(index, figure);
        if(this.boundedCorners.init===true) {
            var parentVertices = figure.getParent().getBoundingBox().getVertices();
            var childVertices = figure.getBoundingBox().getVertices();
            var p1 = parentVertices.get(this.boundedCorners.parent);
            var p2 = childVertices.get(this.boundedCorners.child);
            var xOffset = p1.x - p2.x;
            var yOffset = p1.y - p2.y;
            figure.translate(xOffset - this.boundedCorners.xOffset, yOffset - this.boundedCorners.yOffset);
        }
    }
});
draw2d.layout.locator.XYAbsPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME : "draw2d.layout.locator.XYAbsPortLocator",
    init: function(x ,y )
    {
      this._super();
      this.x = x;
      this.y = y;
    },    
    relocate: function(index, figure)
   {
        this.applyConsiderRotation( figure, this.x, this.y);
    }
});
draw2d.layout.locator.XYRelPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME : "draw2d.layout.locator.XYRelPortLocator",
    init: function(xPercentage ,yPercentage )
    {
      this._super();
      this.x = xPercentage;
      this.y = yPercentage;
    },    
    relocate: function(index, figure)
    {
        var node = figure.getParent();
        var x = node.getWidth()/100 * this.x;
        var y = node.getHeight()/100  * this.y;
        this.applyConsiderRotation( figure, x, y);
    }
});
draw2d.layout.locator.InputPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME : "draw2d.layout.locator.InputPortLocator",
    init: function()
    {
      this._super();
    },    
    relocate: function(index, figure)
   {
        var node = figure.getParent();
        var dividerFactor = 1;
        var thisNAME = this.NAME;
        var portIndex =1;
        node.getPorts().each(function(i,p){
        	portIndex = (p===figure)?dividerFactor:portIndex;
        	dividerFactor += p.getLocator().NAME === thisNAME?1:0;
        });
        this.applyConsiderRotation( figure, 0, (node.getHeight()/dividerFactor)*portIndex);
    }
});
draw2d.layout.locator.OutputPortLocator = draw2d.layout.locator.PortLocator.extend({
    NAME : "draw2d.layout.locator.OutputPortLocator",
    init: function( )
    {
      this._super();
    },    
    relocate: function(index, figure)
   {
        var node = figure.getParent();
        var dividerFactor = 1;
        var thisNAME = this.NAME;
        var portIndex =1;
        node.getPorts().each(function(i,p){
        	portIndex = (p===figure)?dividerFactor:portIndex;
        	dividerFactor += p.getLocator().NAME === thisNAME?1:0;
        });
        this.applyConsiderRotation( figure, node.getWidth(), (node.getHeight()/dividerFactor)*portIndex);
    }
});
draw2d.layout.locator.ConnectionLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.ConnectionLocator",
    init: function()
    {
      this._super();
    }
});
draw2d.layout.locator.ManhattanMidpointLocator= draw2d.layout.locator.ConnectionLocator.extend({
    NAME : "draw2d.layout.locator.ManhattanMidpointLocator",
    init: function()
    {
      this._super();
    },
    relocate: function(index, target)
    {
       var conn = target.getParent();
       var points = conn.getVertices();
       var segmentIndex = Math.floor((points.getSize() -2) / 2);
       if (points.getSize() <= segmentIndex+1)
          return; 
       var p1 = points.get(segmentIndex);
       var p2 = points.get(segmentIndex + 1);
       var x = ((p2.x - p1.x) / 2 + p1.x - target.getWidth()/2)|0;
       var y = ((p2.y - p1.y) / 2 + p1.y - target.getHeight()/2)|0;
       target.setPosition(x,y);
    }
});
draw2d.layout.locator.PolylineMidpointLocator= draw2d.layout.locator.ManhattanMidpointLocator.extend({
    NAME : "draw2d.layout.locator.PolylineMidpointLocator",
    init: function()
    {
      this._super();
    },
    relocate: function(index, target)
    {
       var conn = target.getParent();
       var points = conn.getVertices();
       if(points.getSize()%2===0){
           this._super(index, target);
       }
       else{
           var index = Math.floor(points.getSize() / 2);
           var p1 = points.get(index);
           target.setPosition(p1.x- (target.getWidth()/2),p1.y-(target.getHeight()/2));
       }      
    }
});
draw2d.layout.locator.ParallelMidpointLocator= draw2d.layout.locator.ConnectionLocator.extend({
    NAME : "draw2d.layout.locator.ParallelMidpointLocator",
    init: function(distanceFromConnection)
    {
      this._super();
      if(typeof distanceFromConnection!=="undefined"){
          this.distanceFromConnection = parseFloat(distanceFromConnection);
      }
      else{
          this.distanceFromConnection = -5;
      }
    },
    relocate: function(index, target)
    {
       var conn = target.getParent();
       var points = conn.getVertices();
       var segmentIndex = Math.floor((points.getSize() -2) / 2);
       if (points.getSize() <= segmentIndex+1) {
           return;
       }
       var p1 = points.get(segmentIndex);
       var p2 = points.get(segmentIndex + 1);
       var distance = this.distanceFromConnection<=0?this.distanceFromConnection-target.getHeight():this.distanceFromConnection; 
       var nx =p1.x-p2.x;
       var ny =p1.y-p2.y;
       var length = Math.sqrt(nx*nx+ny*ny);
       var radian = -Math.asin(ny/length);
       var angle  = (180/Math.PI) * radian;
       if(radian<0)
       {
          if(p2.x<p1.x){
              radian = Math.abs(radian) + Math.PI;
              angle = 360-angle;
              distance = -distance-target.getHeight();
          }
          else{
              radian = Math.PI*2- Math.abs(radian);
              angle = 360+angle;
          }
       }
       else
       {
          if(p2.x<p1.x){
              radian = Math.PI-radian;
              angle = 360-angle;
              distance = -distance-target.getHeight();
          }
       }
       var rotAnchor = this.rotate(length/2-target.getWidth()/2, distance, 0, 0, radian);
       var rotCenterOfLabel = this.rotate(0,0,target.getWidth()/2, target.getHeight()/2, radian);
       target.setRotationAngle(angle);
       target.setPosition(rotAnchor.x-rotCenterOfLabel.x+p1.x,rotAnchor.y-rotCenterOfLabel.y+p1.y);
   },
    rotate: function(x, y, xm, ym, radian)
    {
        var cos = Math.cos,
            sin = Math.sin;
            return {x: (x - xm) * cos(radian) - (y - ym) * sin(radian)   + xm,
                    y: (x - xm) * sin(radian) + (y - ym) * cos(radian)   + ym};
    }
});
draw2d.layout.locator.TopLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.TopLocator",
    init: function()
    {
      this._super();
    },
    relocate: function(index, target)
    {
       var parent = target.getParent();
       var boundingBox = parent.getBoundingBox();
       var offset = (parent instanceof draw2d.Port)?boundingBox.w/2:0;
       var targetBoundingBox = target.getBoundingBox();
       if(target instanceof draw2d.Port){
           target.setPosition(boundingBox.w/2-offset,0);
       }
       else{
           target.setPosition(boundingBox.w/2-(targetBoundingBox.w/2)-offset,-(targetBoundingBox.h+2));
       }
    }
});
draw2d.layout.locator.BottomLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.BottomLocator",
    init: function()
    {
      this._super();
    },
    relocate: function(index, target)
    {
       var parent = target.getParent();
       var boundingBox = parent.getBoundingBox();
       var offset = (parent instanceof draw2d.Port)?boundingBox.w/2:0;
       var targetBoundingBox = target.getBoundingBox();
       if(target instanceof draw2d.Port){
           target.setPosition(boundingBox.w/2-offset,boundingBox.h);
       }
       else{
           target.setPosition(boundingBox.w/2-targetBoundingBox.w/2-offset,2+boundingBox.h);
       }
    }
});
draw2d.layout.locator.LeftLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.LeftLocator",
    init: function(attr)
    {
      this._super();
      this.margin = (attr && ( "margin" in attr))?attr.margin :5;
    },
    relocate: function(index, target)
    {
       var parent = target.getParent();
       var boundingBox = parent.getBoundingBox();
       var offset = (parent instanceof draw2d.Port)?boundingBox.h/2:0;
       if(target instanceof draw2d.Port){
           target.setPosition(0,(boundingBox.h/2)-offset);
       }
       else{
           var targetBoundingBox = target.getBoundingBox();
           target.setPosition(-targetBoundingBox.w-this.margin,(boundingBox.h/2)-(targetBoundingBox.h/2)-offset);
       }
    }
});
draw2d.layout.locator.RightLocator = draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.RightLocator",
    init: function(attr)
    {
      this._super();
      this.margin = (attr && ( "margin" in attr))?attr.margin :5;
    },
    relocate: function(index, target)
    {
       var parent = target.getParent();
       var boundingBox = parent.getBoundingBox();
       var offset = (parent instanceof draw2d.Port)?boundingBox.h/2:0;
       if(target instanceof draw2d.Port){
           target.setPosition(boundingBox.w,(boundingBox.h/2)-offset);
       }
       else{
           var targetBoundingBox = target.getBoundingBox();
           target.setPosition(boundingBox.w+this.margin,(boundingBox.h/2)-(targetBoundingBox.h/2)-offset);
       }
    }
});
draw2d.layout.locator.CenterLocator= draw2d.layout.locator.Locator.extend({
    NAME : "draw2d.layout.locator.CenterLocator",
    init: function()
    {
      this._super();
    },
    relocate: function(index, target)
    {
       var parent = target.getParent();
       var boundingBox = parent.getBoundingBox();
       if(target instanceof draw2d.Port){
           target.setPosition(boundingBox.w/2,boundingBox.h/2);
       }
       else{
           var targetBoundingBox = target.getBoundingBox();
           target.setPosition(((boundingBox.w/2-targetBoundingBox.w/2)|0)+0.5,((boundingBox.h/2-(targetBoundingBox.h/2))|0)+0.5);
       }
    }
});
draw2d.policy.EditPolicy = Class.extend({
    NAME : "draw2d.policy.EditPolicy",
    init: function( attr, setter, getter){
        this.setterWhitelist = $.extend({
        },setter);
        this.getterWhitelist = $.extend({
        },getter);
        this.attr(attr);
    },
    attr: function(name, value)
    {
        if($.isPlainObject(name)){
            for(key in name){
                var func=this.setterWhitelist[key];
                if(func){
                    func.call(this,name[key]); 
                }
                else if($.isFunction(name[key])){
                    this[key] = $.proxy(name[key],this);
                }
            }
        }
        else if(typeof name === "string"){
            if(typeof value ==="undefined"){
                var getter = this.getterWhitelist[name];
                if($.isFunction(getter)){
                    return getter.call(this);
                }
                return; 
            }
            if($.isFunction(value)){
                value = value();
            }
            var setter = this.setterWhitelist[name];
            if (setter){setter.call(this,value);}
        }
        else if(typeof name === "undefined"){
        	var result = {};
        	for(key in this.getterWhitelist){
         		result[key] = this.getterWhitelist[key].call(this);
        	}
        	return result;
        }
        return this;
    },
    onInstall: function( host)
    {
    },
    onUninstall: function( host)
    {
    }
});
draw2d.policy.canvas.CanvasPolicy = draw2d.policy.EditPolicy.extend({
    NAME : "draw2d.policy.canvas.CanvasPolicy",
    init: function( attr, setter, getter)
    {
        this.canvas = null;
        this._super( attr, setter, getter);
    },
    onInstall: function(canvas)
    {
        this.canvas = canvas;
    },
    onUninstall: function(canvas)
    {
        this.canvas = null;
    },
    onClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
    },
    onMouseMove: function(canvas, x, y, shiftKey, ctrlKey)
    {
    },
    onDoubleClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
    },
    onMouseDown: function(canvas, x, y, shiftKey, ctrlKey)
    {
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
    },
    onRightMouseDown: function(figure, x, y, shiftKey, ctrlKey)
    {
    },
    onMouseWheel: function(wheelDelta, x, y, shiftKey, ctrlKey)
    {
        return true;
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        return modifiedPos;
    },
    createMonochromGif: function(w,h,d,color)
    {
    	color = new draw2d.util.Color(color);
        var r = String.fromCharCode(w%256) + String.fromCharCode(w/256) + String.fromCharCode(h%256) + String.fromCharCode(h/256) ;
        var gif = "GIF89a" + r + "\xf0\0\0\xff\xff\xff" + String.fromCharCode(color.red) + String.fromCharCode(color.green) + String.fromCharCode(color.blue) + "\x21\xf9\4\1\0\0\0\0,\0\0\0\0" + r + "\0\2";
        var b = { 
                bit: 1,
                byte_: 0,
                data : "",
            writeBit: function(b) {
                if(b) this.byte_ |= this.bit;
                this.bit <<= 1;
                if(this.bit == 256) {
                    this.bit = 1;
                    this.data += String.fromCharCode(this.byte_);
                    this.byte_ = 0;
                }
            },
            get: function() {
                var result = "";
                var data = this.data;
                if(this.bit != 1) { data += String.fromCharCode(this.byte_); }
                for(var i=0; i<data.length + 1; i+=255) {
                    chunklen = data.length - i; if(chunklen < 0) chunklen = 0;
                    if(chunklen > 255) chunklen=255;
                    result += String.fromCharCode(chunklen) + data.substring(i,i+255);
                }
                return result + "\0";
            }
        };
        for(var y=0; y<h; y++) {
            for(var x=0; x<w; x++) {
                b.writeBit(d[x+w*y]); b.writeBit(0); b.writeBit(0);
                b.writeBit(0); b.writeBit(0); b.writeBit(1);
            }
        }
        gif += b.get() + ";" ;
        return "data:image/gif;base64," + draw2d.util.Base64.encode(gif);
    }
});
draw2d.policy.canvas.ZoomPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.ZoomPolicy",
    init: function()
    {
        this._super();
    },
    onInstall: function(canvas)
    {
        this._super(canvas);
        canvas.setZoom(1);
    },
    onUninstall: function(canvas)
    {
        this._super(canvas);
    },
    setZoom: function( zoomFactor, animated)
    {
        var canvas = this.canvas;
        var _zoom = function(z){
            canvas.zoomFactor = Math.min(Math.max(0.01,z),10);
            var viewBoxWidth  = (canvas.initialWidth*(canvas.zoomFactor))|0;
            var viewBoxHeight = (canvas.initialHeight*(canvas.zoomFactor))|0;
            canvas.paper.setViewBox(0, 0, viewBoxWidth, viewBoxHeight);
            canvas.fireEvent("zoom", {value:canvas.zoomFactor});
        };
        if(animated){
            var myTweenable = new Tweenable();
            myTweenable.tween({
                from:     { 'x': canvas.zoomFactor  },
                to:       { 'x': zoomFactor },
                duration: 300,
                easing : "easeOutSine",
                step: function (params) {
                    _zoom(params.x);
                },
                finish: function (state) {
                    canvas.fireEvent("zoomed", {value:canvas.zoomFactor});
                }
            });
        }
        else{
            _zoom(zoomFactor);
            canvas.fireEvent("zoomed", {value:canvas.zoomFactor});
        }
    }
});
draw2d.policy.canvas.WheelZoomPolicy = draw2d.policy.canvas.ZoomPolicy.extend({
    NAME : "draw2d.policy.canvas.WheelZoomPolicy",
    init: function(){
        this._super();
        this.center=null;
        var _this = this;
        this.debouncedZoomedCallback = this._debounce(function(){
            var canvas = _this.canvas;
            if(canvas!==null){
                canvas.fireEvent("zoomed", {value:canvas.zoomFactor});
            }
            _this.center=null;
        },200);
    },
    onInstall: function(canvas)
    {
        this._super(canvas);
        canvas.setZoom(1);
        canvas.__wheelZoom = 1;
    },
    onUninstall: function(canvas)
    {
        this._super(canvas);
        delete canvas.__wheelZoom;
    },
    onMouseWheel: function(wheelDelta, x, y, shiftKey, ctrlKey)
    {
        if(shiftKey ===false){
            return true;
        }
        wheelDelta = wheelDelta/1024;
        var newZoom = ((Math.min(5,Math.max(0.1,this.canvas.zoomFactor+wheelDelta))*10000|0)/10000);
        if(this.center===null){
            var client = this.canvas.fromCanvasToDocumentCoordinate(x,y);
            this.center={
                x:x,
                y:y,
                clientX: client.x,
                clientY: client.y
            };
        }
        this._zoom(newZoom,this.center);
        this.debouncedZoomedCallback();
        return false;
    },
    setZoom: function( zoomFactor, animated)
    {
        var scrollTop   = this.canvas.getScrollTop();
        var scrollLeft  = this.canvas.getScrollLeft();
        var scrollWidth = this.canvas.getScrollArea().width();
        var scrollHeight= this.canvas.getScrollArea().width();
        var centerY = scrollTop+(scrollHeight/2)*this.canvas.zoomFactor;
        var centerX = scrollLeft+(scrollWidth/2)*this.canvas.zoomFactor;
        var _this = this;
        if(animated){
            var myTweenable = new Tweenable();
            myTweenable.tween({
                from:     { 'x': this.canvas.zoomFactor  },
                to:       { 'x': zoomFactor },
                duration: 300,
                easing : "easeOutSine",
                step: function (params) {
                    _this._zoom(params.x, centerX, centerY);
                },
                finish: function (state) {
                    _this.debouncedZoomedCallback();
                }
            });
        }
        else{
            this._zoom(zoomFactor, {x:centerX, y:centerY});
            this.debouncedZoomedCallback();
        }
    },
     _zoom: function(zoom, center){
         var canvas = this.canvas;
         if(zoom === canvas.zoomFactor){
            return;
         }
         canvas.zoomFactor=zoom;
         canvas.paper.setViewBox(0, 0, canvas.initialWidth, canvas.initialHeight);
         $(canvas.html)
             .find("svg")
             .attr({'width': canvas.initialWidth/zoom,
                   'height': canvas.initialHeight/zoom});
         if(center.clientX) {
             var coordsAfter = canvas.fromCanvasToDocumentCoordinate(center.x, center.y);
             canvas.scrollTo(this.canvas.getScrollTop() - (center.clientY - coordsAfter.y), canvas.getScrollLeft() - (center.clientX - coordsAfter.x));
         }
         canvas.fireEvent("zoom", {value:canvas.zoomFactor});
    },
    _debounce: function (func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    }
});
draw2d.policy.canvas.KeyboardPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.KeyboardPolicy",
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
    },
    onKeyUp: function(canvas, keyCode, shiftKey, ctrlKey)
    {
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
    }
});
draw2d.policy.canvas.DefaultKeyboardPolicy = draw2d.policy.canvas.KeyboardPolicy.extend({
    NAME : "draw2d.policy.canvas.DefaultKeyboardPolicy",
    init: function()
    {
        this._super();
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        if(keyCode===46 && canvas.getPrimarySelection()!==null){
            canvas.getCommandStack().startTransaction(draw2d.Configuration.i18n.command.deleteShape);
            canvas.getSelection().each(function(index, figure){
               var cmd = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE));
               if(cmd!==null){
                   canvas.getCommandStack().execute(cmd);
               }
           });
           canvas.getCommandStack().commitTransaction();
        }
        else{
            this._super(canvas, keyCode, shiftKey, ctrlKey);
         }
    }
});
draw2d.policy.canvas.ExtendedKeyboardPolicy = draw2d.policy.canvas.KeyboardPolicy.extend({
    NAME : "draw2d.policy.canvas.ExtendedKeyboardPolicy",
    init: function()
    {
        this._super();
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        if(canvas.getPrimarySelection()!==null && ctrlKey ===true){
            switch(keyCode){
                case 71: 
                    if(canvas.getPrimarySelection() instanceof draw2d.shape.composite.Group && canvas.getSelection().getSize()===1){
                        canvas.getCommandStack().execute(new draw2d.command.CommandUngroup(canvas, canvas.getPrimarySelection()));
                    }
                    else{
                        canvas.getCommandStack().execute(new draw2d.command.CommandGroup(canvas, canvas.getSelection()));
                    }
                    break;
                case 66: 
                    canvas.getPrimarySelection().toBack();
                    break;
                case 70: 
                    canvas.getPrimarySelection().toFront();
            }
        }
        else{
           this._super(canvas, keyCode, shiftKey, ctrlKey);
        }
    }
});
draw2d.policy.canvas.SelectionPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.SelectionPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    select: function(canvas, figure)
    {
    },
    unselect: function(canvas, figure)
    {
        canvas.getSelection().remove(figure);
        figure.unselect();
        canvas.fireEvent("unselect",{figure:figure});
        canvas.fireEvent("select",{figure:null});
    }
});
draw2d.policy.canvas.SingleSelectionPolicy =  draw2d.policy.canvas.SelectionPolicy.extend({
    NAME : "draw2d.policy.canvas.SingleSelectionPolicy",
    init: function()
    {
        this._super();
        this.mouseMovedDuringMouseDown = false;
        this.mouseDraggingElement = null;
        this.mouseDownElement = null;
    },
    select: function(canvas, figure)
    {
        if(canvas.getSelection().contains(figure)){
            return; 
        }
        var oldSelection = canvas.getSelection().getPrimary();
        if(canvas.getSelection().getPrimary()!==null){
            this.unselect(canvas, canvas.getSelection().getPrimary());
        }
        if(figure !==null) {
            figure.select(true); 
        }
        canvas.getSelection().setPrimary(figure);
        if(oldSelection !== figure){
            canvas.fireEvent("select",{figure:figure});
        }
    },
    onMouseDown: function(canvas, x, y, shiftKey, ctrlKey)
    {
        this.mouseMovedDuringMouseDown  = false;
        var canDragStart = true;
        var figure = canvas.getBestFigure(x, y, draw2d.Port);
        while(figure!==null){
            var delegate = figure.getSelectionAdapter()();
            if(delegate===figure){
                break;
            }
            figure = delegate;
        }
        if (figure !== null && figure.isDraggable()) {
            canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
            this.mouseDraggingElement = canDragStart===false ? null : figure;
        }
        this.mouseDownElement = figure;
        if(this.mouseDownElement!==null){
            this.mouseDownElement.fireEvent("mousedown", {x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        }
        if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
            this.select(canvas,figure);
            if (figure instanceof draw2d.shape.basic.Line) {
                if (!(figure instanceof draw2d.Connection)) {
                    canvas.draggingLineCommand = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
                    if (canvas.draggingLineCommand !== null) {
                        canvas.draggingLine = figure;
                    }
                }
            }
            else if (canDragStart === false) {
                figure.unselect();
            }
        }
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        this.mouseMovedDuringMouseDown = true;
        if (this.mouseDraggingElement !== null) {
            var sel =canvas.getSelection();
            if(!sel.contains(this.mouseDraggingElement)){
                this.mouseDraggingElement.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
            }
            else{
                sel.each(function(i,figure){
                    figure.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
                });
            }
            var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + (dx/canvas.zoomFactor), canvas.mouseDownY + (dy/canvas.zoomFactor));           
            var target = canvas.getBestFigure(p.x, p.y,this.mouseDraggingElement);
            if (target !== canvas.currentDropTarget) {
                if (canvas.currentDropTarget !== null) {
                    canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                    canvas.currentDropTarget.fireEvent("dragLeave",{draggingElement:this.mouseDraggingElement});
                    canvas.currentDropTarget = null;
                }
                if (target !== null) {
                    canvas.currentDropTarget = target.delegateTarget(this.mouseDraggingElement);
                    if( canvas.currentDropTarget !==null) {
                        canvas.currentDropTarget.onDragEnter(this.mouseDraggingElement); 
                        canvas.currentDropTarget.fireEvent("dragEnter", {draggingElement: this.mouseDraggingElement});
                    }
                }
            }
       }
       else if(this.mouseDownElement!==null && !(this.mouseDownElement instanceof draw2d.Connection)){
           if(this.mouseDownElement.panningDelegate!==null){
               this.mouseDownElement.panningDelegate.fireEvent("panning", {dx:dx,dy:dy,dx2:dx2,dy2:dy2, shiftKey:shiftKey, ctrlKey:ctrlKey});
               this.mouseDownElement.panningDelegate.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
           }
           else{
               this.mouseDownElement.fireEvent("panning", {dx:dx, dy:dy, dx2:dx2, dy2:dy2, shiftKey:shiftKey, ctrlKey:ctrlKey });
               this.mouseDownElement.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
           }
       }
    },
    onMouseUp: function(canvas, x, y, shiftKey, ctrlKey)
    {       
        if (this.mouseDraggingElement !== null) {
            var redrawConnection = new draw2d.util.ArrayList();
            if(this.mouseDraggingElement instanceof draw2d.shape.node.Node){
                canvas.lineIntersections.each(function(i, inter){
                    if(!redrawConnection.contains(inter.line))redrawConnection.add(inter.line);
                    if(!redrawConnection.contains(inter.other))redrawConnection.add(inter.other);
                });
            }
            canvas.getCommandStack().startTransaction();
                    var sel =canvas.getSelection().getAll();
                    if(!sel.contains(this.mouseDraggingElement)){
                        this.mouseDraggingElement.onDragEnd( x, y, shiftKey, ctrlKey);
                    }
                    else{
                        canvas.getSelection().getAll().each(function(i,figure){
                             figure.onDragEnd( x, y, shiftKey, ctrlKey);
                        });
                    }
                    if(canvas.currentDropTarget!==null && !this.mouseDraggingElement.isResizeHandle){
                        this.mouseDraggingElement.onDrop(canvas.currentDropTarget, x, y, shiftKey, ctrlKey);
                        canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                        canvas.currentDropTarget.fireEvent("dragLeave",{draggingElement:this.mouseDraggingElement});
                        canvas.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
                        canvas.currentDropTarget = null;
                    }
            canvas.getCommandStack().commitTransaction();
            if(this.mouseDraggingElement instanceof draw2d.shape.node.Node){
                canvas.lineIntersections.each(function(i, inter){
                    if(!redrawConnection.contains(inter.line))redrawConnection.add(inter.line);
                    if(!redrawConnection.contains(inter.other))redrawConnection.add(inter.other);
                });
                redrawConnection.each(function(i, line){
                    line.svgPathString=null;
                    line.repaint();
                });
            }
            this.mouseDraggingElement = null;
        }
        else if(this.mouseDownElement!==null && !(this.mouseDownElement instanceof draw2d.Connection)){
            if(this.mouseDownElement.panningDelegate!==null){
                this.mouseDownElement.panningDelegate.fireEvent("panningEnd");
                this.mouseDownElement.panningDelegate.onPanningEnd();
            }
            else{
                this.mouseDownElement.fireEvent("panningEnd");
                this.mouseDownElement.onPanningEnd();
            }
        }
        if (this.mouseDownElement === null && this.mouseMovedDuringMouseDown===false) {
            this.select(canvas,null);
        }
        if(this.mouseDownElement!==null){
            this.mouseDownElement.fireEvent("mouseup", {x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        }
        this.mouseDownElement = null;
        this.mouseMovedDuringMouseDown  = false;
    },
    onClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
        if(figure!==null){
            figure.fireEvent("click", {
                figure:figure,
                x:mouseX,
                y:mouseY,
                relX: mouseX-figure.getAbsoluteX(),
                relY: mouseY-figure.getAbsoluteY(),
                shiftKey:shiftKey,
                ctrlKey:ctrlKey});
            figure.onClick();
        }
    },
    onDoubleClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
        if(figure!==null){
            figure.fireEvent("dblclick", {x:mouseX, y:mouseY, shiftKey:shiftKey, ctrlKey:ctrlKey});
            figure.onDoubleClick();
        }
    }
});
draw2d.policy.canvas.PanningSelectionPolicy =  draw2d.policy.canvas.SingleSelectionPolicy.extend({
    NAME : "draw2d.policy.canvas.PanningSelectionPolicy",
    init: function()
    {
        this._super();
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        this._super(canvas, dx,dy,dx2,dy2, shiftKey, ctrlKey);
        if (this.mouseDraggingElement === null && this.mouseDownElement===null) {
           var area = canvas.getScrollArea();
           area.scrollTop(area.scrollTop()-dy2);
           area.scrollLeft(area.scrollLeft()-dx2);
       }
    }
});
draw2d.policy.canvas.BoundingboxSelectionPolicy =  draw2d.policy.canvas.SingleSelectionPolicy.extend({
    NAME : "draw2d.policy.canvas.BoundingboxSelectionPolicy",
    init: function()
    {
        this.isInsideMode   = function(rect1,rect2){return rect1.isInside(rect2);};
        this.intersectsMode = function(rect1,rect2){return rect1.intersects(rect2);};
        this.decision = this.isInsideMode;
        this._super();
        this.boundingBoxFigure1 = null;
        this.boundingBoxFigure2 = null;
        this.x = 0;
        this.y = 0;
        this.canDrawBoundingBox = false;
     },
     select: function(canvas, figure)
     {
         if(canvas.getSelection().contains(figure)){
             return; 
         }
         var oldSelection = canvas.getSelection().getPrimary();
         if(figure !==null) {
             figure.select(true); 
         }
         if(oldSelection!==figure){
             canvas.getSelection().setPrimary(figure);
             canvas.fireEvent("select",{figure:figure});
         }
         var _this = this;
         var selection = canvas.getSelection();
         canvas.getLines().each(function(i,line){
             if(line instanceof draw2d.Connection){
                 if(selection.contains(line.getSource().getRoot()) && selection.contains(line.getTarget().getRoot())){
                     _this.select(canvas,line,false);
                 }
             }
         });
     },
     setDecisionMode: function(useIntersectionMode)
     {
         if(useIntersectionMode===true){
             this.decision = this.intersectsMode;
         }
         else{
             this.decision = this.isInsideMode;
         }
         return this;
     },
     onMouseDown: function(canvas, x, y, shiftKey, ctrlKey)
     {
         try{
            var _this = this;
            this.x = x;
            this.y = y;
            var currentSelection = canvas.getSelection().getAll();
            this.mouseMovedDuringMouseDown  = false;
            var canDragStart = true;
             this.canDrawBoundingBox = false;
             var figure = canvas.getBestFigure(x, y);
             while(figure!==null){
                var delegated = figure.getSelectionAdapter()();
                if(delegated===figure){
                    break;
                }
                figure = delegated;
             }
             if (figure instanceof draw2d.Port) {
                 return;
             }
             this.canDrawBoundingBox = true;
            if (figure !== null && figure.isDraggable()) {
                canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
                this.mouseDraggingElement = canDragStart===false ? null : figure;
            }
             this.mouseDownElement = figure;
             if(this.mouseDownElement!==null){
                 this.mouseDownElement.fireEvent("mousedown", {x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
             }
            if(shiftKey === false){
                if(this.mouseDownElement!==null && this.mouseDownElement.isResizeHandle===false && !currentSelection.contains(this.mouseDownElement)){
                    currentSelection.each(function(i, figure){
                        _this.unselect(canvas,figure);
                    });
                }
            }
            if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
                this.select(canvas,figure);
                if (figure instanceof draw2d.shape.basic.Line) {
                    if (!(figure instanceof draw2d.Connection)) {
                        canvas.draggingLineCommand = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
                        if (canvas.draggingLineCommand !== null) {
                            canvas.draggingLine = figure;
                        }
                    }
                }
                else if (canDragStart === false) {
                    figure.unselect();
                }
            }
            if(this.mouseDownElement!==null && this.mouseDownElement.isResizeHandle===false) {
                currentSelection = canvas.getSelection().getAll();
                currentSelection.each(function (i, figure) {
                    var fakeDragX = 1;
                    var fakeDragY = 1;
                    var handleRect = figure.getHandleBBox();
                    if (handleRect !== null) {
                        handleRect.translate(figure.getAbsolutePosition().scale(-1));
                        fakeDragX = handleRect.x + 1;
                        fakeDragY = handleRect.y + 1;
                    }
                    var canDragStart = figure.onDragStart(fakeDragX, fakeDragY, shiftKey, ctrlKey, true );
                    if (figure instanceof draw2d.shape.basic.Line) {
                    }
                    else if (canDragStart === false) {
                        _this.unselect(canvas, figure);
                    }
                });
            }
         }
         catch(exc){
             console.log(exc);
         }
     },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        if( this.canDrawBoundingBox===false){
            return;
        }
        try{
            this._super(canvas, dx,dy,dx2,dy2, shiftKey, ctrlKey);
            if (this.mouseDraggingElement === null && this.mouseDownElement===null && this.boundingBoxFigure1===null) {
                this.boundingBoxFigure1 = new draw2d.shape.basic.Rectangle({
                	width  :1,
                	height :1,
                	x      : this.x,
                	y      : this.y,
                	bgColor: "#d4d1d4",
                	alpha  : 0.1
                });
                this.boundingBoxFigure1.setCanvas(canvas);
                this.boundingBoxFigure2 = new draw2d.shape.basic.Rectangle({
                	width:1,
                	height:1,
                	x: this.x,
                	y:this.y,
                	dash:"--..",
                	stroke:0.5,
                	color:"#37a8ff",
                	bgColor:null
                });
                this.boundingBoxFigure2.setCanvas(canvas);
           }
            if (this.boundingBoxFigure1!==null) {
            	this.boundingBoxFigure1.setDimension(Math.abs(dx),Math.abs(dy));
            	this.boundingBoxFigure1.setPosition(this.x + Math.min(0,dx), this.y + Math.min(0,dy));
            	this.boundingBoxFigure2.setDimension(Math.abs(dx),Math.abs(dy));
            	this.boundingBoxFigure2.setPosition(this.x + Math.min(0,dx), this.y + Math.min(0,dy));
            }
        }
        catch(exc){
            console.log(exc);
        }
    },
    onMouseUp: function(canvas, x,y, shiftKey, ctrlKey)
    {
        try{
            var _this = this;
            if(this.mouseDownElement===null){
                canvas.getSelection().getAll().each(function(i,figure){
                    _this.unselect(canvas, figure);
                });
            }
            else if(this.mouseDownElement instanceof draw2d.ResizeHandle || (this.mouseDownElement instanceof draw2d.shape.basic.LineResizeHandle)){
            }
            else if(this.mouseDownElement!==null && this.mouseMovedDuringMouseDown===false){
                var sel =canvas.getSelection().getAll();
                if(!sel.contains(this.mouseDownElement)){
                   canvas.getSelection().getAll().each(function(i,figure){
                       _this.unselect(canvas, figure);
                   });
                }   
            }
            this._super(canvas, x,y, shiftKey, ctrlKey);
            if (this.boundingBoxFigure1!==null) {
            	var selectionRect = this.boundingBoxFigure1.getBoundingBox();
             	canvas.getFigures().each(function(i,figure){
            		if(figure.isSelectable() === true && _this.decision(figure.getBoundingBox(),selectionRect)){
                        var fakeDragX = 1;
                        var fakeDragY = 1;
                        var handleRect = figure.getHandleBBox();
                        if(handleRect!==null){
                            handleRect.translate(figure.getAbsolutePosition().scale(-1));
                            fakeDragX = handleRect.x+1;
                            fakeDragY = handleRect.y+1;
                        }
                        var canDragStart = figure.onDragStart(fakeDragX,fakeDragY, shiftKey, ctrlKey);
                        if(canDragStart===true){
                            _this.select(canvas,figure,false);
                        }
            		}
            	});
        	  this.boundingBoxFigure1.setCanvas(null);
           	  this.boundingBoxFigure1 = null;
          	  this.boundingBoxFigure2.setCanvas(null);
           	  this.boundingBoxFigure2 = null;
            }
        }
        catch(exc){
            console.log(exc);
            debugger;
        }
   }
});
draw2d.policy.canvas.ReadOnlySelectionPolicy = draw2d.policy.canvas.SelectionPolicy.extend({
    NAME : "draw2d.policy.canvas.ReadOnlySelectionPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onInstall: function(canvas)
    {
        this._super(canvas);
        canvas.getAllPorts().each(function(i,port){
            port.setVisible(false);
        });
    },
    onUninstall: function(canvas)
    {
        canvas.getAllPorts().each(function(i,port){
            port.setVisible(true);
        });
        this._super(canvas);
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        var area = canvas.getScrollArea();
        area.scrollTop(area.scrollTop()-dy2);
        area.scrollLeft(area.scrollLeft()-dx2);
    }
});
draw2d.policy.canvas.DecorationPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.DecorationPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    }
});
draw2d.policy.canvas.FadeoutDecorationPolicy = draw2d.policy.canvas.DecorationPolicy.extend({
    NAME : "draw2d.policy.canvas.FadeoutDecorationPolicy",
    DEFAULT_FADEOUT_DURATION : 60,
    DEFAULT_ALPHA_DECREMENT: 0.05,
    init: function()
    {
        this._super();
        this.alpha = 1.0;
        this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
        this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = false;
    },
    onInstall: function(canvas)
    {
        this._super(canvas);
        this.timerId = window.setInterval($.proxy(this.onTimer,this), 50);
        this.hidePortsCounter=1;
        this.alpha = 0.1;
    },
    onUninstall: function(canvas)
    {
        window.clearInterval(this.timerId);
        this.canvas.getAllPorts().each(function(i,port){
            port.setAlpha(1.0);
        });
        this._super(canvas);
    },
    onTimer: function()
    {
        this.hidePortsCounter--;
        var _this = this;
        if(this.hidePortsCounter<=0 && this.alpha >0){
            this.alpha = Math.max(0,this.alpha-this.alphaDec);
            this.canvas.getAllPorts().each(function(i,port){
                port.setAlpha(_this.alpha);
            });
            this.canvas.getSelection().getAll().each(function(i,figure){
                figure.selectionHandles.each(function(i,handle){
                    handle.setAlpha(_this.alpha);
                });
            });
        }
        else if(this.hidePortsCounter>0 && this.alpha!==1.0){
            this.alpha =1;
            this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
            this.duringHide = false;
            this.canvas.getAllPorts().each(function(i,port){
                port.setAlpha(_this.alpha);
            });
            this.canvas.getSelection().getAll().each(function(i,figure){
                figure.selectionHandles.each(function(i,handle){
                    handle.setAlpha(_this.alpha);
                });
            });
        }
    },
    onMouseDown: function(canvas, x,y, shiftKey, ctrlKey)
    {
        this.hidePortsCounter=this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = (canvas.getBestFigure(x, y) instanceof draw2d.Port);
    },
    onMouseMove: function(canvas, x, y, shiftKey, ctrlKey)
    {
        this.hidePortsCounter=this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = false;
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        if(this.portDragging === false){
            this.hidePortsCounter=0;
            this.alphaDec = 0.1;
            this.onTimer();
        }
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
        this.hidePortsCounter=this.DEFAULT_FADEOUT_DURATION;
        this.portDragging = false;
    }
});
draw2d.policy.canvas.CoronaDecorationPolicy = draw2d.policy.canvas.DecorationPolicy.extend({
    NAME : "draw2d.policy.canvas.CoronaDecorationPolicy",
    init: function( attr, setter, getter){
        this.startDragX = 0;
        this.startDragY = 0;
        this.diameterToBeFullVisible = 0;
        this.diameterToBeVisible = 0;
        this.sumDiameter =0;
        this._super(
            $.extend({diameterToBeVisible: 200, diameterToBeFullVisible:20},attr) ,
            $.extend({
                diameterToBeVisible    : this.setDiameterToBeVisible,
                diameterToBeFullVisible : this.setDiameterToBeFullVisible
           },setter),
            $.extend({
                diameterToBeVisible    : this.getDiameterToBeVisible,
                diameterToBeFullVisible: this.getDiameterToBeFullVisible
           },getter)
        );
   },
   setDiameterToBeVisible: function(diameter)
   {
       this.diameterToBeVisible = diameter;
       this.sumDiameter = this.diameterToBeFullVisible + this.diameterToBeVisible;
   },
   getDiameterToBeVisible: function()
   {
	   return this.diameterToBeVisible;
   },
   setDiameterToBeFullVisible: function(diameter)
   {
       this.diameterToBeFullVisible = diameter;
       this.sumDiameter = this.diameterToBeFullVisible + this.diameterToBeVisible;
   },
   getDiameterToBeFullVisible: function()
   {
	   return this.diameterToBeFullVisible;
   },
    onInstall: function(canvas)
   {
       this._super(canvas);
        var figures = canvas.getFigures();
        figures.each(function(i,figure){
            figure.getPorts().each(function(i,p){
                p.setVisible(false);
            });
        });
    },
    onUninstall: function(canvas)
    {
        this._super(canvas);
        var figures = canvas.getFigures();
        figures.each(function(i,figure){
            figure.getPorts().each(function(i,p){
                if(p.__origAlpha){
                    p.setAlpha(p.__origAlpha);
                    delete p.__origAlpha;
                }
                p.setVisible(true);
            });
        });
    },
    onMouseDown: function(canvas, x, y, shiftKey, ctrlKey)
    {
        this.startDragX = x;
        this.startDragY = y;
    },
    onMouseMove: function(canvas, x, y, shiftKey, ctrlKey)
    {
        this.updatePorts(canvas, x, y);
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        this.updatePorts(canvas, this.startDragX+dx, this.startDragY+dy);
    },
    updatePorts: function(canvas,x,y)
    {
        var figures = canvas.getFigures();
        var _this=this;
        figures.each(function(i,figure){
            if(figure instanceof draw2d.shape.node.Node){
                if (figure.isVisible()===true && figure.hitTest(x, y, _this.sumDiameter) === true){
                    figure.getPorts().each(function(i,p){
                        if(p.isVisible()===false){
                            p.__origAlpha= figure.getAlpha();
                        }
                        var dist = figure.getBoundingBox().getDistance(new draw2d.geo.Point(x,y));
                        var alpha = 1-((100/(_this.diameterToBeVisible- _this.diameterToBeFullVisible))*dist)/100.0;
                        p.setAlpha(alpha);
                        p.setVisible(true);
                    });
                }
                else{
                    figure.getPorts().each(function(i,p){
                        if(p.__origAlpha){
                            p.setAlpha(p.__origAlpha);
                            delete p.__origAlpha;
                        }
                        p.setVisible(false);
                    });
                }
            }
        });
    }
});
draw2d.SnapToHelper = {};
draw2d.SnapToHelper.NORTH   =  1;
draw2d.SnapToHelper.SOUTH   =  4;
draw2d.SnapToHelper.WEST    =  8;
draw2d.SnapToHelper.EAST    = 16;
draw2d.SnapToHelper.CENTER_H= 32;
draw2d.SnapToHelper.CENTER_V= 642;
draw2d.SnapToHelper.NORTH_EAST  = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.EAST;
draw2d.SnapToHelper.NORTH_WEST  = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.SOUTH_EAST  = draw2d.SnapToHelper.SOUTH | draw2d.SnapToHelper.EAST;
draw2d.SnapToHelper.SOUTH_WEST  = draw2d.SnapToHelper.SOUTH | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.NORTH_SOUTH = draw2d.SnapToHelper.NORTH | draw2d.SnapToHelper.SOUTH;
draw2d.SnapToHelper.EAST_WEST   = draw2d.SnapToHelper.EAST | draw2d.SnapToHelper.WEST;
draw2d.SnapToHelper.NSEW        = draw2d.SnapToHelper.NORTH_SOUTH | draw2d.SnapToHelper.EAST_WEST;
draw2d.policy.canvas.SnapToEditPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToEditPolicy",
    init: function( attr, setter, getter)
    {
        this.lineColor = null;
        this._super(
            $.extend({
                lineColor: "#51C1FC"
            },attr),
            $.extend({
                lineColor : this.setLineColor
            }, setter),
            $.extend({
                lineColor : this.getLineColor
            }, getter));
    },
    setLineColor: function( color)
    {
        this.lineColor = new draw2d.util.Color(color);
        return this;
    },
    getLineColor: function()
    {
        return this.lineColor;
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        return modifiedPos;
    }
});
draw2d.policy.canvas.ShowGridEditPolicy = draw2d.policy.canvas.DecorationPolicy.extend({
    NAME : "draw2d.policy.canvas.ShowGridEditPolicy",
    GRID_COLOR  : "#f0f0f0",
    GRID_WIDTH  : 20,
    init: function( grid)
    {
        this.color = new draw2d.util.Color(this.GRID_COLOR);
        this.zoom=1;
        this.svg = null;
        this._super();
        if(typeof grid ==="number"){
            this.grid = grid;
        }
        else{
            this.grid = this.GRID_WIDTH;
        }
    },
	onInstall: function(canvas)
	{
        this._super(canvas);
	    this.zoom = canvas.getZoom();
        this.setGrid(this.grid);
	},
	onUninstall: function(canvas)
	{
        this._super(canvas);
        if(this.svg  !==null){
            this.svg.remove();
        }
	},
	setGridColor: function(color)
	{
	    this.color=new draw2d.util.Color(color);
        this.setGrid(this.grid);
	},
    setGrid: function(grid)
    {
        this.grid = grid;
        if(this.canvas !=null){
            if(this.svg  !==null){
                    this.svg.remove();
            }
            var r= this.canvas.paper;
            var d = this.grid, i;
            var w= r.width;
            var h = r.height;
            var props = {stroke: this.color.hash()};
            r.setStart();
                for (i = d+0.5; i < h; i += d) {
                    r.path([[ "M", 0, i], ["L", w, i]]).attr(props);
                }
                for (i = d+0.5; i < w; i += d) {
                    r.path([["M", i, 0], ["L", i, h]]).attr(props);
                }
            this.svg = r.setFinish();
            this.svg.toBack();
        }
    }
});
draw2d.policy.canvas.SnapToGridEditPolicy = draw2d.policy.canvas.ShowGridEditPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToGridEditPolicy",
    init: function( grid)
    {
        this._super(grid);
	},
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        if(figure instanceof draw2d.shape.basic.Line) {
            return modifiedPos;
        }
        var snapPoint = figure.getSnapToGridAnchor();
        modifiedPos.x= modifiedPos.x+snapPoint.x;
        modifiedPos.y= modifiedPos.y+snapPoint.y;
        modifiedPos.x = this.grid*Math.floor(((modifiedPos.x + this.grid/2.0) / this.grid));
        modifiedPos.y = this.grid*Math.floor(((modifiedPos.y + this.grid/2.0) / this.grid));
        modifiedPos.x= modifiedPos.x-snapPoint.x;
        modifiedPos.y= modifiedPos.y-snapPoint.y;
        return modifiedPos;
    }
});
draw2d.policy.canvas.ShowDotEditPolicy = draw2d.policy.canvas.DecorationPolicy.extend({
    NAME : "draw2d.policy.canvas.ShowDotEditPolicy",
    DOT_COLOR  : "#999999",
    DOT_RADIUS  : 1,
    DOT_DISTANCE : 20,
    init: function( dotDistance, dotRadius, dotColor)
    {
        this._super();
        this.dotDistance = dotDistance ? dotDistance : this.DOT_DISTANCE;
        this.dotRadius = dotRadius ? dotRadius : this.DOT_RADIUS;
        this.dotColor = new draw2d.util.Color(dotColor ? dotColor : this.DOT_COLOR);
        var mypixels = Array(this.dotDistance*this.dotDistance);
        mypixels[0] = 1;
        this.imageDataURL = this.createMonochromGif(this.dotDistance, this.dotDistance, mypixels, this.dotColor);
    },
    onInstall: function(canvas)
    {
        this._super(canvas);
        this.oldBg =  this.canvas.html.css("background-image");
        $(canvas.paper.canvas).css({"background-image": "url('"+this.imageDataURL+"')"});
    },
    onUninstall: function(canvas)
    {
        this._super(canvas);
        $(canvas.paper.canvas).css({"background-image": this.oldBg});
    }
});
draw2d.policy.canvas.SnapToGeometryEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToGeometryEditPolicy",
    SNAP_THRESHOLD   : 3,
    FADEOUT_DURATION : 300,
    init: function( attr, setter, getter)
    {
        this._super(attr, setter,getter);
        this.rows=null;
        this.cols=null;
        this.vline = null;
        this.hline = null;
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
        this.rows=null;
        this.cols=null;
        this.hideVerticalLine();
        this.hideHorizontalLine();
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        if(figure instanceof draw2d.shape.basic.Line) {
            return modifiedPos;
        }
        var result;
        var allowXChanges = modifiedPos.x=== originalPos.x;
        var allowYChanges = modifiedPos.y=== originalPos.y;
        if(!allowXChanges && !allowYChanges){
            return modifiedPos;
        }
        if(figure instanceof draw2d.ResizeHandle)
        {
           var snapPoint = figure.getSnapToGridAnchor();
           modifiedPos.x+= snapPoint.x;
           modifiedPos.y+= snapPoint.y;
           var snapDirections = figure.getSnapToDirection();
            result = this.snapPoint(snapDirections, modifiedPos);
           if(allowXChanges && (snapDirections & draw2d.SnapToHelper.EAST_WEST) && !(result.edge & draw2d.SnapToHelper.EAST_WEST)) {
               this.showVerticalLine(figure, draw2d.SnapToHelper.WEST, result.point.x);
           }
           else {
               this.hideVerticalLine();
           }
           if(allowYChanges && (snapDirections & draw2d.SnapToHelper.NORTH_SOUTH) && !(result.edge & draw2d.SnapToHelper.NORTH_SOUTH)) {
               this.showHorizontalLine(figure, draw2d.SnapToHelper.NORTH, result.point.y);
           }
           else {
               this.hideHorizontalLine();
           }
           result.point.x= allowXChanges? result.point.x-snapPoint.x: modifiedPos.x;
           result.point.y= allowYChanges? result.point.y-snapPoint.y: modifiedPos.y;
           return result.point;
        }
        var inputBounds = new draw2d.geo.Rectangle(modifiedPos.x,modifiedPos.y, figure.getWidth(), figure.getHeight());
        result = this.snapRectangle( inputBounds);
        if(!allowXChanges){
            result.bounds.x= modifiedPos.x;
        }
        if(!allowYChanges){
            result.bounds.y=modifiedPos.y;
        }
        if(allowXChanges && !(result.edge & draw2d.SnapToHelper.WEST)) {
            this.showVerticalLine(figure, draw2d.SnapToHelper.WEST, result.bounds.x);
        }
        else if(allowXChanges && ! (result.edge & draw2d.SnapToHelper.EAST)) {
            this.showVerticalLine(figure, draw2d.SnapToHelper.EAST, result.bounds.x + result.bounds.getWidth());
        }
        else {
            this.hideVerticalLine();
        }
        if(allowYChanges && !(result.edge & draw2d.SnapToHelper.NORTH)) {
            this.showHorizontalLine(figure, draw2d.SnapToHelper.NORTH, result.bounds.y);
        }
        else if(allowYChanges && !(result.edge & draw2d.SnapToHelper.SOUTH)) {
            this.showHorizontalLine(figure, draw2d.SnapToHelper.SOUTH, result.bounds.y + result.bounds.getHeight());
        }
        else {
            this.hideHorizontalLine();
        }
        return result.bounds.getTopLeft();
    },
    snapRectangle: function(inputBounds)
    {
        var resultBounds = inputBounds.clone();
        var topLeft = this.snapPoint(draw2d.SnapToHelper.NORTH_WEST, inputBounds.getTopLeft());
        resultBounds.x = topLeft.point.x;
        resultBounds.y = topLeft.point.y;
        var bottomRight = this.snapPoint(draw2d.SnapToHelper.SOUTH_EAST, inputBounds.getBottomRight());
        if(topLeft.edge & draw2d.SnapToHelper.WEST) {
            resultBounds.x = bottomRight.point.x - inputBounds.getWidth();
        }
        if(topLeft.edge & draw2d.SnapToHelper.NORTH) {
            resultBounds.y = bottomRight.point.y - inputBounds.getHeight();
        }
        return {edge: topLeft.edge|bottomRight.edge , bounds:resultBounds};
    },
    snapPoint: function( snapOrientation,  inputPoint)
    {
        var resultPoint = inputPoint.clone();
       if(this.rows===null || this.cols===null)
         this.populateRowsAndCols();
       if ((snapOrientation & draw2d.SnapToHelper.EAST) !== 0) 
       {
          var rightCorrection = this.getCorrectionFor(this.cols, inputPoint.x +1, 1);
          if (rightCorrection !== this.SNAP_THRESHOLD) 
          {
             snapOrientation &= ~draw2d.SnapToHelper.EAST;
             resultPoint.x += rightCorrection;
          }
       }
       if ((snapOrientation & draw2d.SnapToHelper.WEST) !== 0) 
       {
          var leftCorrection = this.getCorrectionFor(this.cols, inputPoint.x, -1);
          if (leftCorrection !== this.SNAP_THRESHOLD) 
          {
             snapOrientation &= ~draw2d.SnapToHelper.WEST;
             resultPoint.x += leftCorrection;
          }
       }
       if ((snapOrientation & draw2d.SnapToHelper.SOUTH) !== 0) 
       {
          var bottomCorrection = this.getCorrectionFor(this.rows,  inputPoint.y +1, 1);
          if (bottomCorrection !== this.SNAP_THRESHOLD) 
          {
             snapOrientation &= ~draw2d.SnapToHelper.SOUTH;
             resultPoint.y += bottomCorrection;
          }
       }
       if ((snapOrientation & draw2d.SnapToHelper.NORTH) !== 0) 
       {
          var topCorrection = this.getCorrectionFor(this.rows, inputPoint.y, -1);
          if (topCorrection !== this.SNAP_THRESHOLD) 
          {
             snapOrientation &= ~draw2d.SnapToHelper.NORTH;
             resultPoint.y += topCorrection;
          }
       }
       return {edge: snapOrientation, point: resultPoint};
    },
    populateRowsAndCols: function()
    {
       var selection = this.canvas.getSelection();
       this.rows = [];
       this.cols = [];
       var figures = this.canvas.getFigures();
       for (var i = 0; i < figures.getSize();i++ )
       {
          var figure = figures.get(i);
          if(!selection.contains(figure, true))
          {
             var bounds = figure.getBoundingBox();
             this.cols.push({type:-1, location: bounds.x});
             this.cols.push({type:0 , location: bounds.x + (bounds.w - 1) / 2});
             this.cols.push({type:1 , location: bounds.getRight() +1 });
             this.rows.push({type:-1, location: bounds.y});
             this.rows.push({type:0 , location: bounds.y + (bounds.h - 1) / 2});
             this.rows.push({type:1 , location: bounds.getBottom()+1 });
         }
       }
    },
    getCorrectionFor: function( entries,  value,  side)
    {
       var resultMag = this.SNAP_THRESHOLD;
       var result = this.SNAP_THRESHOLD;
       for (var i = 0; i < entries.length; i++) 
       {
          var entry = entries[i];
          var magnitude;
          if (entry.type === -1 && side !== 0) 
          {
             magnitude = Math.abs(value - entry.location);
             if (magnitude < resultMag)
             {
                   resultMag = magnitude;
                   result = entry.location - value;
             }
          }
          else if (entry.type === 0 && side === 0) 
          {
             magnitude = Math.abs(value - entry.location);
             if (magnitude < resultMag)
             {
                resultMag = magnitude;
                result = entry.location - value;
             }
          }
          else if (entry.type === 1 && side !== 0) 
          {
             magnitude = Math.abs(value - entry.location);
             if (magnitude < resultMag)
             {
                resultMag = magnitude;
                result = entry.location - value;
             }
          }
       }
       return result;
    },
    showVerticalLine: function(causedFigure, edge, x)
    {
        if(this.vline!=null){
            this.vline.stop();
            this.vline.remove();
        }
        var figures = this.canvas.getFigures().clone();
        figures.removeAll(this.canvas.getSelection().getAll(true));
        figures.map(function(figure){
            return figure.getBoundingBox();
        });
        figures.grep(function(bbox){
            return (Math.abs(bbox.x-x)<=1) || (Math.abs(bbox.getRight()-x)<=1);
        });
        if(figures.getSize()===0){
            return;
        }
        var causedBox  = causedFigure.getBoundingBox();
        var causedCenter  = causedBox.getCenter();
        figures.sort(function(a,b){
            var d_a = a.getCenter().getDistance(causedCenter);
            var d_b = b.getCenter().getDistance(causedCenter);
            return d_a-d_b;
        });
        var fromY = 0;
        var maxLength= this.canvas.getHeight()*Math.max(1,this.canvas.getZoom());
        var yLength  = maxLength;
        var snappedBox = figures.get(0);
        if(causedBox.y <snappedBox.y){
            fromY   = causedBox.y;
            yLength = snappedBox.getBottom()-causedBox.y;
        }
        else{
            fromY   = snappedBox.y;
            yLength = causedBox.getBottom()-snappedBox.y;
        }
        x=(x|0)+0.5; 
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + x + " 0 l 0 " + maxLength)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + x + " "+fromY+" l 0 " + yLength)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.vline = this.canvas.paper.setFinish();
        this.vline.toBack();
    },
    hideVerticalLine: function()
    {
        if(this.vline==null){
            return;
        }
        this.vline.animate(
            {opacity: 0.1},
            this.FADEOUT_DURATION,
            $.proxy(function(){
                if(this.vline!==null) {
                    this.vline.remove();
                    this.vline = null;
                }
            },this)
        );
    },
    showHorizontalLine: function(causedFigure, edge, y)
    {
        if(this.hline!=null){
            this.hline.stop();
            this.hline.remove();
        }
        var figures = this.canvas.getFigures().clone();
        figures.removeAll(this.canvas.getSelection().getAll(true));
        figures.map(function(figure){
            return figure.getBoundingBox();
        });
        figures.grep(function(bbox){
            return (Math.abs(bbox.y-y)<=1) || (Math.abs(bbox.getBottom()-y)<=1);
        });
        if(figures.getSize()===0){
            return;
        }
        var causedBox  = causedFigure.getBoundingBox();
        var causedCenter  = causedBox.getCenter();
        figures.sort(function(a,b){
            var d_a = a.getCenter().getDistance(causedCenter);
            var d_b = b.getCenter().getDistance(causedCenter);
            return d_a-d_b;
        });
        var fromX = 0;
        var maxLength;
        var xLength  = maxLength = this.canvas.getWidth()*Math.max(1,this.canvas.getZoom());
        var snappedBox = figures.get(0);
        if(causedBox.x <snappedBox.x){
            fromX   = causedBox.x;
            xLength = snappedBox.getRight()-causedBox.x;
        }
        else{
            fromX   = snappedBox.x;
            xLength = causedBox.getRight()-snappedBox.x;
        }
        y=(y|0)+0.5; 
        this.canvas.paper.setStart();
        this.canvas.paper.path("M 0 "+y+ " l " + maxLength+" 0")
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M "+fromX+" " + y + " l " + xLength + " 0")
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.hline = this.canvas.paper.setFinish();
        this.hline.toBack();
    },
    hideHorizontalLine: function()
    {
        if(this.hline===null){
            return; 
        }
        this.hline.animate(
            {opacity: 0.1},
            this.FADEOUT_DURATION,
            $.proxy(function(){
                if(this.hline!==null) {
                    this.hline.remove();
                    this.hline = null;
                }
            },this)
        );
    }
});
draw2d.policy.canvas.SnapToVerticesEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToVerticesEditPolicy",
    SNAP_THRESHOLD   : 3,
    FADEOUT_DURATION : 300,
    init: function( attr, setter, getter)
    {
        this._super(attr, setter,getter);
        this.constraints = null;
        this.vline = null;
        this.hline = null;
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
        this.constraints = null;
        this.hideVerticalLine();
        this.hideHorizontalLine();
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        if(!(figure instanceof draw2d.shape.basic.VertexResizeHandle)){
            return modifiedPos;
        }
        var allowXChanges = modifiedPos.x=== originalPos.x;
        var allowYChanges = modifiedPos.y=== originalPos.y;
        if(!allowXChanges && !allowYChanges){
            return modifiedPos;
        }
        var result = modifiedPos.clone();
        var correction  = this.getCorrectionFor(figure, originalPos);
        if(allowXChanges && (correction.vertical.x !==Number.MAX_SAFE_INTEGER)) {
            result.x = correction.vertical.x;
            this.showVerticalLine(originalPos, correction.vertical);
        }
        else {
            this.hideVerticalLine();
        }
        if(allowYChanges && (correction.horizontal.y !==Number.MAX_SAFE_INTEGER)) {
            result.y = correction.horizontal.y;
            this.showHorizontalLine(originalPos, correction.horizontal);
        }
        else {
            this.hideHorizontalLine();
        }
        return result;
    },
    getCorrectionFor: function(vertexResizeHandle, point)
    {
        var _this =this;
        if(this.constraints===null) {
            this.constraints = [];
            var lines = this.canvas.getLines();
            lines.each(function (i, line) {
                line.getVertices().each(function (ii, vertex) {
                    if(vertexResizeHandle.index!==ii || vertexResizeHandle.owner!==line)
                        _this.constraints.push(vertex);
                });
            });
        }
        var SNAP = this.SNAP_THRESHOLD;
        var vertical   = {x:Number.MAX_SAFE_INTEGER, y:Number.MAX_SAFE_INTEGER, diffy:Number.MAX_SAFE_INTEGER};
        var horizontal = {x:Number.MAX_SAFE_INTEGER, y:Number.MAX_SAFE_INTEGER, diffx:Number.MAX_SAFE_INTEGER};
        var diffx, diffy;
        for (var i = 0; i < this.constraints.length; i++) {
           var entry = this.constraints[i];
           diffx = Math.abs(point.x - entry.x);
           diffy = Math.abs(point.y - entry.y);
           if (diffx < SNAP) {
             if(diffy<vertical.diffy){
                 vertical   = {x:entry.x, y:entry.y, diffy:diffy};
             }
           }
           if (diffy < SNAP) {
               if(diffx<horizontal.diffx){
                   horizontal = {x:entry.x, y:entry.y, diffx:diffx};
               }
           }
       }
       return {vertical:vertical, horizontal:horizontal};
    },
    showVerticalLine: function(originalPos, snappedPos)
    {
        if(this.vline!=null){
            this.vline.stop();
            this.vline.remove();
        }
        var maxLength = this.canvas.getHeight();
        var x=(snappedPos.x|0)+0.5; 
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + x + " 0 l 0 " + maxLength)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + x + " "+originalPos.y+" L "+x+" " + snappedPos.y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.vline = this.canvas.paper.setFinish();
        this.vline.toBack();
    },
    hideVerticalLine: function()
    {
        if(this.vline==null){
            return;
        }
        this.vline.animate(
            {opacity: 0.1},
            this.FADEOUT_DURATION,
            $.proxy(function(){
                if(this.vline!==null) {
                    this.vline.remove();
                    this.vline = null;
                }
            },this)
        );
    },
    showHorizontalLine: function(originalPos, snappedPos)
    {
        if(this.hline!=null) {
            this.hline.stop();
            this.hline.remove();
        }
        var maxLength = this.canvas.getWidth();
        var y=(snappedPos.y|0)+0.5; 
        this.canvas.paper.setStart();
        this.canvas.paper.path("M 0 "+y+ " l " + maxLength+" 0")
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M "+originalPos.x+" " + y + " L " + snappedPos.x + " "+y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.hline = this.canvas.paper.setFinish();
        this.hline.toBack();
    },
    hideHorizontalLine: function()
    {
        if(this.hline===null){
            return; 
        }
        this.hline.animate(
            {opacity: 0.1},
            this.FADEOUT_DURATION,
            $.proxy(function(){
                if(this.hline!==null) {
                    this.hline.remove();
                    this.hline = null;
                }
            },this)
        );
    }
});
draw2d.policy.canvas.SnapToInBetweenEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToInBetweenEditPolicy",
    SNAP_THRESHOLD   : 5,
    FADEOUT_DURATION : 500,
    init: function( attr, setter, getter){
        this._super(attr, setter, getter);
        this.bounds=null;
        this.horizontalGuideLines = null;
        this.verticalGuideLines = null;
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
        this.bounds=null;
        this.hideHorizontalGuides(false);
        this.hideVerticalGuides(false);
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        if(figure instanceof draw2d.ResizeHandle) {
           return modifiedPos;
        }
        if(figure instanceof draw2d.shape.basic.Line) {
            return modifiedPos;
        }
        var allowXChanges = modifiedPos.x=== originalPos.x;
        var allowYChanges = modifiedPos.y=== originalPos.y;
        var inputBounds = new draw2d.geo.Rectangle(modifiedPos.x,modifiedPos.y, figure.getWidth(), figure.getHeight());
        modifiedPos = modifiedPos.clone();
        if(allowXChanges===true) {
            var horizontal = this.snapHorizontal(inputBounds);
            if (horizontal.snapped) {
                this.showHorizontalGuides(figure, horizontal);
                modifiedPos.x += horizontal.diff;
            }
            else {
                this.hideHorizontalGuides(true);
            }
        }
        else{
            this.hideHorizontalGuides(true);
        }
        if(allowYChanges===true) {
            var vertical = this.snapVertical(inputBounds);
            if (vertical.snapped) {
                this.showVerticalGuides(figure, vertical);
                modifiedPos.y += vertical.diff;
            }
            else {
                this.hideVerticalGuides(true);
            }
        }
        else{
            this.hideVerticalGuides(true);
        }
        return modifiedPos;
    },
    snapHorizontal: function( boundingBox )
    {
        var center = boundingBox.getCenter();
        if(this.bounds===null)
         this.populateBounds();
        var result = {
            point:center,
            snapped:false,
            snappedBox : boundingBox.clone()
        };
        var intersectionPoint=null;
        var leftIntersections = [];
        var leftInputPoint = center.clone();
        leftInputPoint.x=0;
        this.bounds.forEach(function( bbox,index){
            intersectionPoint =  draw2d.shape.basic.Line.intersection(bbox.getTopRight(), bbox.getBottomRight(), center, leftInputPoint);
            if (intersectionPoint !== null) {
                intersectionPoint.causedBBox = bbox;
                leftIntersections.push(intersectionPoint);
            }
        });
        if(leftIntersections.length===0){
            return result;
        }
        leftIntersections.sort(function(a, b) {
            return b.x - a.x;
        });
        var rightIntersections= [];
        var rightInputPoint = center.clone();
        rightInputPoint.x= Number.MAX_SAFE_INTEGER;
        this.bounds.forEach(function( bbox,index){
            intersectionPoint =  draw2d.shape.basic.Line.intersection(bbox.getTopLeft(), bbox.getBottomLeft(), center, rightInputPoint);
            if (intersectionPoint !== null) {
                intersectionPoint.causedBBox = bbox;
                rightIntersections.push(intersectionPoint);
            }
        });
        if(rightIntersections.length===0){
            return result;
        }
        rightIntersections.sort(function(a, b) {
            return a.x - b.x;
        });
        var snappedRect = boundingBox.clone();
        var diff = ((leftIntersections[0].x + rightIntersections[0].x)/2)-center.x;
        snappedRect.x +=diff;
        return {snapped: Math.abs(diff)<this.SNAP_THRESHOLD, snappedRect:snappedRect, diff:diff, leftSide:leftIntersections[0], rightSide:rightIntersections[0]};
    },
    snapVertical: function( boundingBox )
    {
        var center = boundingBox.getCenter();
        if(this.bounds===null) {
            this.populateBounds();
        }
        var result = {
            point:center,
            snapped:false,
            snappedBox : boundingBox.clone()
        };
        var intersectionPoint=null;
        var topIntersections = [];
        var topInputPoint = center.clone();
        topInputPoint.y=0;
        this.bounds.forEach(function( bbox){
            intersectionPoint =  draw2d.shape.basic.Line.intersection(bbox.getBottomLeft(), bbox.getBottomRight(), center, topInputPoint);
            if (intersectionPoint !== null) {
                intersectionPoint.causedBBox = bbox;
                topIntersections.push(intersectionPoint);
            }
        });
        if(topIntersections.length===0){
            return result;
        }
        topIntersections.sort(function(a, b) {
            return b.y - a.y;
        });
        var bottomIntersections= [];
        var bottomInputPoint = center.clone();
        bottomInputPoint.y= Number.MAX_SAFE_INTEGER;
        this.bounds.forEach(function( bbox){
            intersectionPoint =  draw2d.shape.basic.Line.intersection(bbox.getTopLeft(), bbox.getTopRight(), center, bottomInputPoint);
            if (intersectionPoint !== null) {
                intersectionPoint.causedBBox = bbox;
                bottomIntersections.push(intersectionPoint);
            }
        });
        if(bottomIntersections.length===0){
            return result;
        }
        bottomIntersections.sort(function(a, b) {
            return a.y - b.y;
        });
        var snappedRect = boundingBox.clone();
        var diff = ((topIntersections[0].y + bottomIntersections[0].y)/2)-center.y;
        snappedRect.y +=diff;
        return {snapped: Math.abs(diff)<this.SNAP_THRESHOLD, snappedRect:snappedRect, diff:diff, topSide:topIntersections[0], bottomSide:bottomIntersections[0]};
    },
    populateBounds: function()
    {
       var selection = this.canvas.getSelection().getAll(true);
       var bounds = this.bounds = [];
       var figures = this.canvas.getFigures();
       figures.each(function(index,figure){
          if(!selection.contains(figure)){
             bounds.push(figure.getBoundingBox());
         }
       });
    },
    showHorizontalGuides: function(causedFigure, constraint)
    {
        if(this.horizontalGuideLines!=null){
            this.horizontalGuideLines.stop();
            this.horizontalGuideLines.remove();
        }
        var snapTopLeft  = constraint.snappedRect.getTopLeft();
        var snapTopRight = constraint.snappedRect.getTopRight();
        var y = ((Math.min(constraint.leftSide.causedBBox.getTopRight().y,Math.min(constraint.rightSide.causedBBox.y,causedFigure.getY()))-50)|0)+0.5;
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + ((constraint.leftSide.x|0)+0.5)   + " "+y+" L "+((constraint.leftSide.x|0)+0.5) + " "  + constraint.leftSide.y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});;
        this.canvas.paper.path("M " + ((snapTopLeft.x |0)+0.5)  + " "+y+" L "+((snapTopLeft.x|0)+0.5) + " "  + snapTopLeft.y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});;
        this.canvas.paper.path("M " + ((snapTopRight.x|0)+0.5)   + " "+y+" L "+((snapTopRight.x|0)+0.5) + " "  + snapTopRight.y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});;
        this.canvas.paper.path("M " + ((constraint.rightSide.x|0)+0.5)  + " "+y+" L "+((constraint.rightSide.x|0)+0.5)+ " "  + constraint.rightSide.y)
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});;
        this.canvas.paper.path("M " + (constraint.leftSide.x)   + " "+(y+5)+" L "+(snapTopLeft.x)+ " "  + (y+5)).attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path("M " + (constraint.rightSide.x)  + " "+(y+5)+" L "+(snapTopRight.x)+ " "  + (y+5)).attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
              " M " + (constraint.leftSide.x+5) + " "+(y)
             +" L " + (constraint.leftSide.x) + " "+(y+5)
             +" L " + (constraint.leftSide.x+5) + " "+(y+10))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (snapTopLeft.x-5) + " "+(y)
            +" L " + (snapTopLeft.x) + " "+(y+5)
            +" L " + (snapTopLeft.x-5) + " "+(y+10))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (snapTopRight.x+5) + " "+(y)
            +" L " + (snapTopRight.x) + " "+(y+5)
            +" L " + (snapTopRight.x+5) + " "+(y+10))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (constraint.rightSide.x-5) + " "+(y)
            +" L " + (constraint.rightSide.x) + " "+(y+5)
            +" L " + (constraint.rightSide.x-5) + " "+(y+10))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.horizontalGuideLines = this.canvas.paper.setFinish();
        this.horizontalGuideLines.toFront();
    },
    hideHorizontalGuides: function( fast)
    {
        if(this.horizontalGuideLines==null){
            return;
        }
        if(fast===true) {
            if (this.horizontalGuideLines !== null) {
                this.horizontalGuideLines.remove();
                this.horizontalGuideLines = null;
            }
        }
        else {
            this.horizontalGuideLines.animate(
                {opacity: 0.1},
                this.FADEOUT_DURATION,
                $.proxy(function () {
                    if (this.horizontalGuideLines !== null) {
                        this.horizontalGuideLines.remove();
                        this.horizontalGuideLines = null;
                    }
                }, this)
            );
        }
    },
    showVerticalGuides: function(causedFigure, constraint)
    {
        if(this.verticalGuideLines!=null){
            this.verticalGuideLines.stop();
            this.verticalGuideLines.remove();
        }
        var snapTopRight    = constraint.snappedRect.getTopRight();
        var snapBottomRight = constraint.snappedRect.getBottomRight();
        var x = ((Math.max(constraint.topSide.causedBBox.getRight(),Math.max(constraint.bottomSide.causedBBox.getRight(),causedFigure.getX()))+40)|0)+0.5;
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + x + " "+((constraint.topSide.y|0)+0.5)+" L "+((constraint.topSide.x|0)+0.5) + " "  + ((constraint.topSide.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + x + " "+((snapTopRight.y|0)+0.5)+" L "+((snapTopRight.x|0)+0.5) + " "  + ((snapTopRight.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + x + " "+((snapBottomRight.y|0)+0.5)+" L "+((snapBottomRight.x|0)+0.5) + " "  + ((snapBottomRight.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + x   + " "+((constraint.bottomSide.y|0)+0.5)+" L "+((constraint.bottomSide.x|0)+0.5) + " "  + ((constraint.bottomSide.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1, "stroke-dasharray":". "});
        this.canvas.paper.path("M " + (x-5)  + " "+(((constraint.topSide.y|0)+0.5))+" L "+(x-5)+ " "  +((snapTopRight.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path("M " + (x-5)  + " "+(((constraint.bottomSide.y|0)+0.5))+" L "+(x-5)+ " "  +((snapBottomRight.y|0)+0.5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (x-10)+ " "+(constraint.topSide.y+5)
            +" L " + (x-5) + " "+(constraint.topSide.y)
            +" L " + (x)   + " "+(constraint.topSide.y+5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (x-10)+ " "+(snapTopRight.y-5)
            +" L " + (x-5) + " "+(snapTopRight.y)
            +" L " + (x)   + " "+(snapTopRight.y-5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (x-10)+ " "+(snapBottomRight.y+5)
            +" L " + (x-5) + " "+(snapBottomRight.y)
            +" L " + (x)   + " "+(snapBottomRight.y+5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.canvas.paper.path(
             " M " + (x-10)+ " "+(constraint.bottomSide.y-5)
            +" L " + (x-5) + " "+(constraint.bottomSide.y)
            +" L " + (x)   + " "+(constraint.bottomSide.y-5))
            .attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.verticalGuideLines = this.canvas.paper.setFinish();
        this.verticalGuideLines.toFront();
    },
    hideVerticalGuides: function()
    {
        if(this.verticalGuideLines==null){
            return; 
        }
        this.verticalGuideLines.animate(
            {opacity: 0.1},
            this.FADEOUT_DURATION,
            $.proxy(function(){
                if(this.verticalGuideLines!==null) {
                    this.verticalGuideLines.remove();
                    this.verticalGuideLines = null;
                }
            },this)
        );
    }
});
draw2d.policy.canvas.SnapToCenterEditPolicy = draw2d.policy.canvas.SnapToEditPolicy.extend({
    NAME : "draw2d.policy.canvas.SnapToCenterEditPolicy",
    SNAP_THRESHOLD   : 5,
    FADEOUT_DURATION : 500,
    init: function( attr, setter, getter)
    {
        this._super(attr, setter, getter);
        this.centers=null;
        this.horizontalGuideLines = null;
        this.verticalGuideLines = null;
    },
    onMouseUp: function(figure, x, y, shiftKey, ctrlKey)
    {
        this.centers=null;
        this.hideHorizontalGuides(false);
        this.hideVerticalGuides(false);
    },
    snap: function(canvas, figure, modifiedPos, originalPos)
    {
        if(figure instanceof draw2d.ResizeHandle) {
           return modifiedPos;
        }
        if(figure instanceof draw2d.shape.basic.Line) {
            return modifiedPos;
        }
        var allowXChanges = modifiedPos.x=== originalPos.x;
        var allowYChanges = modifiedPos.y=== originalPos.y;
        var inputBounds = new draw2d.geo.Rectangle(modifiedPos.x,modifiedPos.y, figure.getWidth(), figure.getHeight());
        var inputCenter = inputBounds.getCenter();
        modifiedPos = modifiedPos.clone();
        if(allowXChanges===true) {
            var horizontal = this.snapHorizontal(inputCenter);
            if (horizontal.snapped) {
                this.showHorizontalGuides(figure, horizontal);
                modifiedPos.y += horizontal.diff;
            }
            else {
                this.hideHorizontalGuides(true);
            }
        }
        else{
            this.hideHorizontalGuides(true);
        }
        if(allowYChanges===true) {
            var vertical = this.snapVertical(inputCenter);
            if (vertical.snapped) {
                this.showVerticalGuides(figure, vertical);
                modifiedPos.x += vertical.diff;
            }
            else {
                this.hideVerticalGuides(true);
            }
        }
        else{
            this.hideVerticalGuides(true);
        }
        return modifiedPos;
    },
    snapVertical: function( center  )
    {
        var _this = this;
        if(this.centers===null) {
            this.populateCenters();
        }
        var result = {
            point:center,
            snapped:false,
            diff : 0
        };
        var candidates= [];
        this.centers.forEach(function( point){
            if(Math.abs(point.x - center.x)<_this.SNAP_THRESHOLD){
                candidates.push(point);
            }
        });
        if(candidates.length===0){
            return result;
        }
        candidates.sort(function(a, b) {
            return a.x - b.x;
        });
        var diff = candidates[0].x -center.x;
        var snappedPoint = center.clone();
        snappedPoint.x +=diff;
        return {snapped: true, diff:diff, point:candidates[0], snappedPoint:snappedPoint};
    },
    snapHorizontal: function( center  )
    {
        var _this = this;
        if(this.centers===null) {
            this.populateCenters();
        }
        var result = {
            point:center,
            snapped:false,
            diff : 0
        };
        var candidates= [];
        this.centers.forEach(function( point){
            if(Math.abs(point.y - center.y)<_this.SNAP_THRESHOLD){
                candidates.push(point);
            }
        });
        if(candidates.length===0){
            return result;
        }
        candidates.sort(function(a, b) {
            return a.y - b.y;
        });
        var diff = candidates[0].y -center.y;
        var snappedPoint = center.clone();
        snappedPoint.y +=diff;
        return {snapped: true, diff:diff, point:candidates[0], snappedPoint:snappedPoint};
    },
    populateCenters: function()
    {
       var selection = this.canvas.getSelection().getAll(true);
       var centers = this.centers = [];
       var figures = this.canvas.getFigures();
       figures.each(function(index, figure){
          if(!selection.contains(figure)){
             centers.push(figure.getBoundingBox().getCenter());
         }
       });
    },
    showHorizontalGuides: function(causedFigure, constraint)
    {
        if(this.horizontalGuideLines!==null){
            this.horizontalGuideLines.stop();
            this.horizontalGuideLines.remove();
        }
        var start  = constraint.point;
        var end    = constraint.snappedPoint;
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + (start.x)  + " "+((start.y|0)+0.5)+" L "+(end.x)+ " "  + ((end.y|0)+0.5)).attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.horizontalGuideLines = this.canvas.paper.setFinish();
        this.horizontalGuideLines.toFront();
    },
    hideHorizontalGuides: function( fast)
    {
        if(this.horizontalGuideLines===null){
            return;
        }
        if(fast===true) {
            if (this.horizontalGuideLines !== null) {
                this.horizontalGuideLines.remove();
                this.horizontalGuideLines = null;
            }
        }
        else {
            this.horizontalGuideLines.animate(
                {opacity: 0.1},
                this.FADEOUT_DURATION,
                $.proxy(function () {
                    if (this.horizontalGuideLines !== null) {
                        this.horizontalGuideLines.remove();
                        this.horizontalGuideLines = null;
                    }
                }, this)
            );
        }
    },
    showVerticalGuides: function(causedFigure, constraint)
    {
        if(this.verticalGuideLines!==null){
            this.verticalGuideLines.stop();
            this.verticalGuideLines.remove();
        }
        var start  = constraint.point;
        var end    = constraint.snappedPoint;
        this.canvas.paper.setStart();
        this.canvas.paper.path("M " + ((start.x|0)+0.5)  + " "+(start.y)+" L "+((end.x|0)+0.5)+ " "  + (end.y)).attr({"stroke":this.lineColor.hash(),"stroke-width":1});
        this.verticalGuideLines = this.canvas.paper.setFinish();
        this.verticalGuideLines.toFront();
    },
    hideVerticalGuides: function( fast)
    {
        if(this.verticalGuideLines===null){
            return;
        }
        if(fast===true) {
            if (this.verticalGuideLines !== null) {
                this.verticalGuideLines.remove();
                this.verticalGuideLines = null;
            }
        }
        else {
            this.verticalGuideLines.animate(
                {opacity: 0.1},
                this.FADEOUT_DURATION,
                $.proxy(function () {
                    if (this.verticalGuideLines !== null) {
                        this.verticalGuideLines.remove();
                        this.verticalGuideLines = null;
                    }
                }, this)
            );
        }
    }
});
draw2d.policy.canvas.DropInterceptorPolicy = draw2d.policy.canvas.CanvasPolicy.extend({
    NAME : "draw2d.policy.canvas.DropInterceptorPolicy",
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
    },
    delegateTarget: function(connectInquirer, connectIntent)
    {
    	if(!(connectInquirer instanceof draw2d.Port) && connectIntent instanceof draw2d.shape.composite.StrongComposite){
    		return connectIntent;
    	}
    	if(!(connectIntent instanceof draw2d.Port) || !(connectInquirer instanceof draw2d.Port)){
    		return null;
    	}
    	if(connectIntent.getConnections().getSize() >= connectIntent.getMaxFanOut()){
    	    return null;
    	}
        if (connectInquirer instanceof draw2d.OutputPort && connectIntent instanceof draw2d.OutputPort) {
            return null;
        }
        if (connectInquirer instanceof draw2d.InputPort && connectIntent instanceof draw2d.InputPort) {
            return null;
        }
        if((connectInquirer instanceof draw2d.Port) && (connectIntent instanceof draw2d.Port)){
	        if(connectInquirer.getParent() === connectIntent.getParent()){
	            return null;
	         }
        }
        if((connectInquirer instanceof draw2d.Port) && (connectIntent instanceof draw2d.shape.node.Hub)) {
            return connectIntent.getHybridPort(0);
        }
        return connectIntent;
    }
});
draw2d.policy.connection.ConnectionCreatePolicy = draw2d.policy.canvas.KeyboardPolicy.extend({
    NAME : "draw2d.policy.connection.ConnectionCreatePolicy",
    init: function(attr, setter, getter)
    {
        this._super( attr,setter,getter);
    },
    createConnection:function()
    {
        return new draw2d.Connection({
            router: new draw2d.layout.connection.DirectRouter()
        });
    },
    ripple: function(x,y, type)
    {
        switch(type){
            case 0:
                var circle = this.canvas.paper.circle(x, y, 3, 3).attr({fill: null, stroke:"#d0d0ff"});
                var anim = Raphael.animation(
                    {transform: "s6", opacity:0.0, "stroke-width":3 },
                    500,
                    "linear",
                    function(){circle.remove()}
                );
                circle.animate(anim);
                return this.canvas.paper.set();
                break;
            case 1:
                var circle1 = this.canvas.paper.circle(x, y, 3, 3).attr({fill: null, stroke:"#3f72bf"});
                var circle2 = this.canvas.paper.circle(x, y, 3, 3).attr({fill: null, stroke:"#ff0000"});
                var anim1 = Raphael.animation(
                    {transform: "s6", opacity:0.0, "stroke-width":1 },
                    1200,
                    "linear"
                ).repeat(Infinity);
                circle1.animate(anim1);
                var anim2 = Raphael.animation(
                    {transform: "s12", opacity:0.0, "stroke-width":4 },
                    500,
                    "linear",
                    function(){circle2.remove()}
                );
                circle2.animate(anim2);
                return circle1;
                break;
        }
    }
});
draw2d.policy.connection.ComposedConnectionCreatePolicy = draw2d.policy.connection.ConnectionCreatePolicy.extend({
    NAME : "draw2d.policy.connection.ComposedConnectionCreatePolicy",
    init: function( policies )
    {
        this.policies = policies;
        this._super();
    },
    onMouseDown: function()
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onMouseDown.apply(p,_arg);
        });
    },
    onMouseDrag: function()
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onMouseDrag.apply(p,_arg);
        });
    },
    onMouseUp: function()
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onMouseUp.apply(p,_arg);
        });
    },
    onClick: function()
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onClick.apply(p,_arg);
        });
    },
    onMouseMove: function()
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onMouseMove.apply(p,_arg);
        });
    },
    onKeyUp: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onKeyUp.apply(p,_arg);
        });
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onKeyDown.apply(p,_arg);
        });
    },
    onInstall: function(canvas)
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onInstall.apply(p,_arg);
        });
    },
    onUninstall: function(canvas)
    {
        var _arg = arguments;
        $.each(this.policies, function(i,p){
            p.onUninstall.apply(p,_arg);
        });
    }
});
draw2d.policy.connection.ClickConnectionCreatePolicy = draw2d.policy.connection.ConnectionCreatePolicy.extend({
    NAME : "draw2d.policy.connection.ClickConnectionCreatePolicy",
    init: function(attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.port1 = null;
        this.beeline = null;
        this.pulse= null;
        this.tempConnection = null;
        this.vertices = [];
    },
    onClick: function(figure, x, y, shiftKey, ctrlKey)
    {
        var _this = this;
        var port = figure;
        if(port === null && this.port1 === null){
            return;
        }
        if(port===null){
            this.vertices.push(new draw2d.geo.Point(x,y));
            this.beeline.setStartPosition(x,y);
            this.tempConnection.setVertices(this.vertices);
            if(this.pulse!==null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.ripple(x,y,0);
            return;
        }
        if(!(port instanceof draw2d.Port)){
            return;
        }
        if(this.port1===null){
            var canvas = port.getCanvas();
            this.port1 = port;
            this.vertices.push(port.getAbsolutePosition());
            this.beeline = new draw2d.shape.basic.Line({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                dasharray:"- ",
                color:"#2C70FF"
            });
            this.beeline.hide= function(){
                _this.beeline.setCanvas(null);
            };
            this.beeline.show= function(canvas){
                _this.beeline.setCanvas(canvas);
                _this.beeline.shape.toFront();
            };
            this.beeline.show(canvas);
            this.tempConnection = new draw2d.shape.basic.PolyLine({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                stroke:2,
                color:"#2C70FF"
            });
            this.tempConnection.hide= function(){
                _this.tempConnection.setCanvas(null);
            };
            this.tempConnection.show= function(canvas){
                _this.tempConnection.setCanvas(canvas);
                _this.tempConnection.shape.toFront();
            };
            this.tempConnection.show(canvas);
            this.tempConnection.setVertices([this.port1.getAbsolutePosition(),this.port1.getAbsolutePosition()]);
            var a= function() {
                _this.tempConnection.shape.animate({"stroke-width" : 2}, 800, b);
            };
            var b=function() {
                _this.tempConnection.shape.animate({"stroke-width":1}, 800, a);
            };
            a();
            var pos = port.getAbsolutePosition();
            this.pulse =this.ripple(pos.x, pos.y, 1);
            return;
        }
        var possibleTarget = port.delegateTarget(this.port1);
        if(!(possibleTarget instanceof draw2d.Port)){
            return; 
        }
        var request = new draw2d.command.CommandType(draw2d.command.CommandType.CONNECT);
        request.source = this.port1;
        request.target = port;
        var command = null;
        if(this.port1 instanceof draw2d.InputPort) {
             command = this.port1.createCommand(request);
        }
        else{
             command = port.createCommand(request);
        }
        if(command!==null){
            this.vertices.push(port.getPosition());
            command.setConnection( this.createConnection());
            figure.getCanvas().getCommandStack().execute(command);
            this.beeline.hide();
            this.tempConnection.hide();
            if(this.pulse!==null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.beeline = null;
            this.port1=null;
            this.vertices = [];
        }
    },
    onMouseMove: function(canvas, x, y, shiftKey, ctrlKey)
    {
        if(this.beeline!==null){
            this.beeline.setEndPosition(x,y);
        }
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        var KEYCODE_ENTER = 13;
        var KEYCODE_ESC = 27;
        if (keyCode === KEYCODE_ESC && this.beeline!==null){
            this.beeline.hide();
            this.tempConnection.hide();
            this.beeline = null;
            this.port1=null;
            this.vertices = [];
            if(this.pulse!=null) {
                this.pulse.remove();
                this.pulse=null;
            }
        }
    },
    createConnection: function()
    {
        var connection = this._super();
        if(this.vertices.length===2){
            connection.setRouter(new draw2d.layout.connection.DirectRouter());
        }
        else {
            connection.setRouter(new draw2d.layout.connection.VertexRouter());
            connection.setVertices(this.vertices);
        }
        connection.setRadius(10);
        return connection;
    }
});
draw2d.policy.connection.OrthogonalConnectionCreatePolicy = draw2d.policy.connection.ConnectionCreatePolicy.extend({
    NAME : "draw2d.policy.connection.ClickConnectionCreatePolicy",
    init: function(attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.port1 = null;
        this.beeline = null;
        this.pulse= null;
        this.tempConnection = null;
        this.vertices = new draw2d.util.ArrayList();
    },
    onClick: function(figure, x, y, shiftKey, ctrlKey)
    {
        var UP   = draw2d.geo.Rectangle.DIRECTION_UP;
        var RIGHT= draw2d.geo.Rectangle.DIRECTION_RIGHT;
        var DOWN = draw2d.geo.Rectangle.DIRECTION_DOWN;
        var LEFT = draw2d.geo.Rectangle.DIRECTION_LEFT;
        var _this = this;
        var port = figure;
        if(port === null && this.port1 === null){
            return;
        }
        if(port===null){
            var canvas = this.port1.getCanvas();
            var newPos = this.beeline.getEndPosition();
            this.vertices.add(newPos);
            this.beeline.setStartPosition(this.beeline.getEndPosition());
            this.tempConnection.setVertices(this.vertices);
            if(this.pulse!==null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.ripple(newPos.x, newPos.y, 0);
            return;
        }
        if(!(port instanceof draw2d.Port)){
            return;
        }
        if(this.port1===null){
            var canvas = port.getCanvas();
            this.port1 = port;
            this.vertices.add(port.getAbsolutePosition());
            this.beeline = new draw2d.shape.basic.Line({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                dasharray:"- ",
                color:"#2C70FF"
            });
            this.beeline.hide= function(){
                _this.beeline.setCanvas(null);
            };
            this.beeline.show= function(canvas){
                _this.beeline.setCanvas(canvas);
                _this.beeline.shape.toFront();
            };
            this.beeline.show(canvas);
            this.tempConnection = new draw2d.shape.basic.PolyLine({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                stroke:2,
                color:"#2C70FF"
            });
            this.tempConnection.hide= function(){
                _this.tempConnection.setCanvas(null);
            };
            this.tempConnection.show= function(canvas){
                _this.tempConnection.setCanvas(canvas);
                _this.tempConnection.shape.toFront();
            };
            this.tempConnection.show(canvas);
            this.tempConnection.setVertices([this.port1.getAbsolutePosition(),this.port1.getAbsolutePosition()]);
            var a= function() {
                _this.tempConnection.shape.animate({"stroke-width" : 2}, 800, b);
            };
            var b=function() {
                _this.tempConnection.shape.animate({"stroke-width":1}, 800, a);
            };
            a();
            canvas.paper.setStart();
            if(this.pulse!==null) {
                this.pulse.remove();
                this.pulse = null;
            }
            var pos = port.getAbsolutePosition();
            this.ripple(pos.x, pos.y, 1);
            this.pulse = canvas.paper.setFinish();
        }
        else {
            var possibleTarget = port.delegateTarget(this.port1);
            if (!(possibleTarget instanceof draw2d.Port)) {
                return; 
            }
            var request = new draw2d.command.CommandType(draw2d.command.CommandType.CONNECT);
            request.source = this.port1;
            request.target = port;
            var command = null;
            if (this.port1 instanceof draw2d.InputPort) {
                command = this.port1.createCommand(request);
            }
            else {
                command = port.createCommand(request);
            }
            if (command !== null) {
                var connection = this.createConnection();
                command.setConnection(connection);
                port.getCanvas().getCommandStack().execute(command);
                this.beeline.hide();
                this.tempConnection.hide();
                if (this.pulse !== null) {
                    this.pulse.remove();
                    this.pulse = null;
                }
                this.beeline = null;
                this.port1 = null;
                if(this.vertices.getSize()<=2){
                    return;
                }
                var MINDIST = command.getConnection().getRouter().MINDIST;
                var beforeVertex = this.vertices.get(this.vertices.getSize()-2);
                var lastVertex   = this.vertices.last();
                var portPos      = port.getAbsolutePosition();
                var lastSegmentDir = UP;
                if(lastVertex.x === beforeVertex.x){
                    lastSegmentDir = lastVertex.y< beforeVertex.y ? UP : DOWN;
                }
                else{
                    lastSegmentDir = lastVertex.x< beforeVertex.x ? LEFT : RIGHT;
                }
                switch(port.getConnectionDirection(this.port1)){
                    case UP:
                        switch(lastSegmentDir){
                            case UP:
                                if(lastVertex.y<(portPos.y-MINDIST)) {
                                    this.vertices.add(new draw2d.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.y = portPos.y-MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case RIGHT:
                                if(lastVertex.y>(portPos.y-MINDIST)){
                                    beforeVertex.y = portPos.y-MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x = portPos.x;
                                    this.vertices.add(portPos);
                                }
                                break;
                            case DOWN:
                                if(lastVertex.y<(portPos.y-MINDIST)) {
                                    beforeVertex.x = portPos.x;
                                    lastVertex.setPosition(portPos);
                                }
                                else{
                                    lastVertex.y = portPos.y-MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(portPos.x,lastVertex.y ));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case LEFT:
                                if(lastVertex.y>(portPos.y-MINDIST)){
                                    beforeVertex.y = portPos.y-MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x = portPos.x;
                                    this.vertices.add(portPos);
                                }
                                break;
                        }
                        break;
                    case RIGHT:
                        switch(lastSegmentDir){
                            case UP:
                                if(lastVertex.x > (portPos.x+MINDIST)){
                                    lastVertex.y = portPos.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    this.vertices.add(new draw2d.geo.Point(portPos.x+MINDIST, lastVertex.y));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x+MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case RIGHT:
                                if(lastVertex.x > (portPos.x+MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x =  portPos.x+MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case DOWN:
                                if(lastVertex.x > (portPos.x+MINDIST)){
                                    lastVertex.y = portPos.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    this.vertices.add(new draw2d.geo.Point(portPos.x+MINDIST, lastVertex.y));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x+MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case LEFT:
                                if(lastVertex.x > (portPos.x+MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x =  portPos.x+MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                        }
                        break;
                    case DOWN:
                        switch(lastSegmentDir){
                            case UP:
                                if(lastVertex.y<(portPos.y+MINDIST)) {
                                    lastVertex.y = portPos.y+MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x   = portPos.x;
                                    lastVertex.y   = portPos.y;
                                    beforeVertex.x = portPos.x;
                                }
                                break;
                            case RIGHT:
                                if(lastVertex.y<(portPos.y+MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y+MINDIST));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x, portPos.y+MINDIST));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x = portPos.x;
                                    this.vertices.add(portPos);
                                }
                                break;
                            case DOWN:
                                if(lastVertex.y<(portPos.y+MINDIST)) {
                                    lastVertex.y = portPos.y+MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(portPos.x,lastVertex.y ));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    this.vertices.add(new draw2d.geo.Point(portPos.x,lastVertex.y ));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case LEFT:
                                if(lastVertex.y<(portPos.y-MINDIST)){
                                    beforeVertex.y = portPos.y-MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x = portPos.x;
                                    this.vertices.add(portPos);
                                }
                                break;
                        }
                        break;
                    case LEFT:
                        switch(lastSegmentDir){
                            case UP:
                                if(lastVertex.x >= (portPos.x-MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, lastVertex.y));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else if(lastVertex.y > portPos.y && lastVertex.x < (portPos.x-MINDIST)){
                                    lastVertex.y = portPos.y;
                                    this.vertices.add(portPos);
                                }
                                else{
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, lastVertex.y));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case RIGHT:
                                if(lastVertex.y<portPos.y && lastVertex.x > (portPos.x-MINDIST)){
                                    var center = portPos.y-(portPos.y-lastVertex.y)/2;
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, center));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, center));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else if(lastVertex.y>portPos.y && lastVertex.x > (portPos.x-MINDIST)){
                                    var center = portPos.y+(lastVertex.y-portPos.y)/2;
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, center));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, center));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                break;
                            case DOWN:
                                if(lastVertex.x >= (portPos.x-MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, lastVertex.y));
                                    this.vertices.add(new draw2d.geo.Point(portPos.x-MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.y=portPos.y;
                                    this.vertices.add(portPos);
                                }
                                break;
                            case LEFT:
                                if(lastVertex.x < (portPos.x-MINDIST)){
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                else{
                                    lastVertex.x =  portPos.x-MINDIST;
                                    this.vertices.add(new draw2d.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                            break;
                        }
                    break;
                }
                if(this.vertices.getSize()>3) {
                    connection._routingMetaData.routedByUserInteraction = true;
                    connection.setVertices(this.vertices);
                }
                this.vertices.clear();
            }
        }
    },
    onMouseMove: function(canvas, x, y, shiftKey, ctrlKey)
    {
        if(this.beeline!==null){
            this.beeline.setEndPosition(this.orthogonal(this.vertices.last(), {x:x,y:y}));
        }
    },
    onKeyDown: function(canvas, keyCode, shiftKey, ctrlKey)
    {
        var KEYCODE_ENTER = 13;
        var KEYCODE_ESC = 27;
        if (keyCode === KEYCODE_ESC && this.beeline!==null){
            this.beeline.hide();
            this.tempConnection.hide();
            this.beeline = null;
            this.port1=null;
            this.vertices.clear();
            if(this.pulse!=null) {
                this.pulse.remove();
                this.pulse=null;
            }
        }
    },
    orthogonal: function(anchor, p)
    {
        var xDiff = Math.abs(anchor.x- p.x)+10;
        var xDist = draw2d.geo.Line.distance(anchor.x-xDiff, anchor.y, anchor.x+xDiff, anchor.y, p.x, p.y);
        var yDiff = Math.abs(anchor.y- p.y)+10;
        var yDist = draw2d.geo.Line.distance(anchor.x, anchor.y-yDiff, anchor.x, anchor.y+yDiff, p.x, p.y);
        return yDist>xDist? {x: p.x, y:anchor.y}:{x: anchor.x, y: p.y};
    },
    createConnection: function()
    {
        var connection = this._super();
        connection.attr({radius:7, stroke:3});
        connection.setRouter(new draw2d.layout.connection.InteractiveManhattanConnectionRouter());
        return connection;
    }
});
draw2d.policy.connection.DragConnectionCreatePolicy = draw2d.policy.connection.ConnectionCreatePolicy.extend({
    NAME : "draw2d.policy.connection.DragConnectionCreatePolicy",
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
        this.mouseDraggingElement =null;
        this.currentDropTarget = null;
        this.currentTarget = null;
    },
    onMouseDown: function(canvas, x, y, shiftKey, ctrlKey)
    {
        var port = canvas.getBestFigure(x, y);
        if(port===null){
            return;
        }
        if(!(port instanceof draw2d.Port)){
            return;
        }
        if(port.isInDragDrop===true){
            port.onDragEnd( x, y, shiftKey, ctrlKey);
            port.isInDragDrop=false;
        }
        if (port.isDraggable()) {
            var canDragStart = port.onDragStart(x - port.getAbsoluteX(), y - port.getAbsoluteY(), shiftKey, ctrlKey);
            if(canDragStart) {
                port.fireEvent("dragstart", {x: x - port.getAbsoluteX(), y: y - port.getAbsoluteY(), shiftKey: shiftKey, ctrlKey: ctrlKey});
            }
            this.mouseDraggingElement = canDragStart===false ? null : port;
            this.mouseDownElement = port;
        }
    },
    onMouseDrag: function(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
        try{
            if (this.mouseDraggingElement !== null) {
                var de = this.mouseDraggingElement;
                var ct = this.currentTarget;
                de.isInDragDrop = true;
                de.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
                var target=canvas.getBestFigure(de.getAbsoluteX(),de.getAbsoluteY(), de);
                if(target!==ct){
                    if(ct!==null){
                        ct.onDragLeave(de);
                        ct.fireEvent("dragLeave",{draggingElement:de});
                        de.editPolicy.each(function(i,e){
                            if(e instanceof draw2d.policy.port.PortFeedbackPolicy){
                                e.onHoverLeave(canvas, de, ct);
                            }
                        });
                    }
                    if(target!==null){
                        this.currentTarget= ct = target.delegateTarget(de);
                        if(ct!==null){
                            ct.onDragEnter(de); 
                            ct.fireEvent("dragEnter",{draggingElement:de});
                            de.editPolicy.each(function(i,e){
                                if(e instanceof draw2d.policy.port.PortFeedbackPolicy){
                                    e.onHoverEnter(canvas, de, ct);
                                }
                            });
                        }
                    }
                    else{
                        this.currentTarget = null;
                    }
                }
                var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + (dx/canvas.zoomFactor), canvas.mouseDownY + (dy/canvas.zoomFactor));
                var target = canvas.getBestFigure(p.x, p.y,this.mouseDraggingElement);
                if (target !== this.currentDropTarget) {
                    if (this.currentDropTarget !== null) {
                        this.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                        this.currentDropTarget.fireEvent("dragLeave",{draggingElement:this.mouseDraggingElement});
                        this.currentDropTarget = null;
                    }
                    if (target !== null) {
                        this.currentDropTarget = target.delegateTarget(this.mouseDraggingElement);
                        if( this.currentDropTarget !==null) {
                            this.currentDropTarget.onDragEnter(this.mouseDraggingElement); 
                            this.currentDropTarget.fireEvent("dragEnter", {draggingElement: this.mouseDraggingElement});
                        }
                    }
                }
            }
        }
        catch(exc){
            console.log(exc);
            debugger;
        }
    },
    onMouseUp: function(canvas, x, y, shiftKey, ctrlKey)
    {
        if (this.mouseDraggingElement !== null) {
            var de = this.mouseDraggingElement;
            var ct = this.currentTarget;
            canvas.getCommandStack().startTransaction();
            de.onDragEnd(x, y, shiftKey, ctrlKey);
            if(ct){
                de.editPolicy.each(function(i,e){
                    if(e instanceof draw2d.policy.port.PortFeedbackPolicy){
                        e.onHoverLeave(canvas, de, ct);
                    }
                });
            }
            de.editPolicy.each(function(i,e){
                if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                    e.onDragEnd(canvas, de, x, y, shiftKey, ctrlKey);
                }
            });
            this.currentTarget = null;
            de.isInDragDrop =false;
            de.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
            if (this.currentDropTarget !== null) {
                this.mouseDraggingElement.onDrop(this.currentDropTarget, x, y, shiftKey, ctrlKey);
                this.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                this.currentDropTarget.fireEvent("dragLeave", {draggingElement: this.mouseDraggingElement});
                if(this.currentDropTarget instanceof draw2d.Port){
                    var request = new draw2d.command.CommandType(draw2d.command.CommandType.CONNECT);
                    request.source = this.currentDropTarget;
                    request.target = this.mouseDraggingElement;
                    var command = this.mouseDraggingElement.createCommand(request);
                    if(command!==null){
                        command.setConnection(this.createConnection());
                        canvas.getCommandStack().execute(command);
                        this.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
                    }
                }
            }
            canvas.getCommandStack().commitTransaction();
            this.currentDropTarget = null;
            this.mouseDraggingElement = null;
        }
    },
    createConnection: function()
    {
        var connection = this._super();
        connection.setRouter(new draw2d.layout.connection.DirectRouter());
        return connection;
    }
});
draw2d.policy.figure.FigureEditPolicy = draw2d.policy.EditPolicy.extend({
    NAME : "draw2d.policy.figure.FigureEditPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onRightMouseDown: function(figure, x, y, shiftKey, ctrlKey)
    {
    }
});
draw2d.policy.figure.DragDropEditPolicy = draw2d.policy.figure.FigureEditPolicy.extend({
    NAME : "draw2d.policy.figure.DragDropEditPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onDragStart: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
    	figure.shape.attr({cursor:"move"});
        if(figure.isMoving===true){
            figure.setAlpha(figure.originalAlpha);
        }
        figure.originalAlpha = figure.getAlpha();
    	figure.isMoving = false;
        return true;
    },
    onDrag: function(canvas, figure)
    {
        if(figure.isMoving===false){
            figure.isMoving = true;
            figure.setAlpha(figure.originalAlpha*0.4);
        }    	
    },
    onDragEnd: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
        figure.shape.attr({cursor:"default"});
        figure.isMoving = false;
        figure.setAlpha(figure.originalAlpha);
    },
    adjustPosition: function(figure, x,y)
    {
        if(x instanceof draw2d.geo.Point){
            return x;
        }
        return new draw2d.geo.Point(x,y);
    },
    adjustDimension: function(figure, w, h)
    {
        return new draw2d.geo.Rectangle(0,0,w,h);
    },
    moved: function(canvas,figure) 
    {
    }
});
draw2d.policy.figure.RegionEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({
    NAME : "draw2d.policy.figure.RegionEditPolicy",
    init: function( x,y,w,h){
        this._super();
        if(x instanceof draw2d.geo.Rectangle){
            this.constRect = x;
        }
        else if(typeof h === "number"){
            this.constRect = new draw2d.geo.Rectangle(x,y,w,h);
        }
        else{
            throw "Invalid parameter. RegionEditPolicy need a rectangle as parameter in the constructor";
        }
    },
    setBoundingBox: function(boundingBox)
    {
      this.constRect = boundingBox;  
      return this;
    },
    adjustPosition: function(figure, x, y)
    {
        var r = null;
        if (x instanceof draw2d.geo.Point) {
            r = new draw2d.geo.Rectangle(x.x, x.y, figure.getWidth(), figure.getHeight());
        }
        else {
            r = new draw2d.geo.Rectangle(x, y, figure.getWidth(), figure.getHeight());
        }
        r = this.constRect.moveInside(r);
        return r.getTopLeft();
    },
    adjustDimension: function(figure, w, h)
    {
        var diffW = (figure.getAbsoluteX()+w)-this.constRect.getRight();
        var diffH = (figure.getAbsoluteY()+h)-this.constRect.getBottom();
        if(diffW>0){
            w = w- diffW;
        }
        if(diffH>0){
            h = h- diffH;
        }
        return {w:w, h:h};
    }
});
draw2d.policy.figure.HorizontalEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({
    NAME : "draw2d.policy.figure.HorizontalEditPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    adjustPosition: function(figure, x, y)
    {
        return new draw2d.geo.Point(x,figure.getY());
    }
});
draw2d.policy.figure.VerticalEditPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({
    NAME : "draw2d.policy.figure.VerticalEditPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    adjustPosition: function(figure, x, y)
    {
        return new draw2d.geo.Point(figure.getX(),y);
    }
});
draw2d.policy.figure.SelectionFeedbackPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({
    NAME : "draw2d.policy.figure.SelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection)
    {
    },
    onUnselect: function(canvas, figure )
    {
        figure.selectionHandles.each(function(i,e){
            e.hide();
        });
        figure.selectionHandles = new draw2d.util.ArrayList();
    },
    onInstall: function( figure)
    {
        this._super(figure);
        var canvas = figure.getCanvas();
        if(canvas!==null){
            if(canvas.getSelection().contains(figure)){
                this.onSelect(canvas, figure, true);
            }
        }
    },
    onUninstall: function( figure)
    {
        this._super(figure);
        if(typeof figure.selectionHandles ==="undefined"){
            return;
        }
        figure.selectionHandles.each(function(i,e){
            e.hide();
        });
        figure.selectionHandles = new draw2d.util.ArrayList();
    }
});
draw2d.policy.figure.ResizeSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.figure.ResizeSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection){
        if(figure.selectionHandles.isEmpty())
        {
            var r1= draw2d.Configuration.factory.createResizeHandle(figure,1); 
            var r3= draw2d.Configuration.factory.createResizeHandle(figure,3); 
            var r5= draw2d.Configuration.factory.createResizeHandle(figure,5); 
            var r7= draw2d.Configuration.factory.createResizeHandle(figure,7); 
            figure.selectionHandles.add(r1);
            figure.selectionHandles.add(r3);
            figure.selectionHandles.add(r5);
            figure.selectionHandles.add(r7);
            r1.show(canvas);
            r3.show(canvas);
            r5.show(canvas);
            r7.show(canvas);
            if(figure.isResizeable()===false) {
              r1.setBackgroundColor(null);
              r3.setBackgroundColor(null);
              r5.setBackgroundColor(null);
              r7.setBackgroundColor(null);
              r1.setDraggable(false);
              r3.setDraggable(false);
              r5.setDraggable(false);
              r7.setDraggable(false);
            }
            if((!figure.getKeepAspectRatio()) && figure.isResizeable()){
                var r2= draw2d.Configuration.factory.createResizeHandle(figure,2); 
                var r4= draw2d.Configuration.factory.createResizeHandle(figure,4); 
                var r6= draw2d.Configuration.factory.createResizeHandle(figure,6); 
                var r8= draw2d.Configuration.factory.createResizeHandle(figure,8); 
                figure.selectionHandles.add(r2);
                figure.selectionHandles.add(r4);
                figure.selectionHandles.add(r6);
                figure.selectionHandles.add(r8);
                r2.show(canvas);
                r4.show(canvas);
                r6.show(canvas);
                r8.show(canvas);
            }
        }
        this.moved(canvas, figure);
   },
    moved: function(canvas, figure ){
        if(figure.selectionHandles.isEmpty()){
            return; 
        }
        var objHeight   = figure.getHeight();
        var objWidth    = figure.getWidth();
        var xPos = figure.getX();
        var yPos = figure.getY();
        var r1= figure.selectionHandles.find(function(handle){return handle.type===1});
        var r3= figure.selectionHandles.find(function(handle){return handle.type===3});
        var r5= figure.selectionHandles.find(function(handle){return handle.type===5});
        var r7= figure.selectionHandles.find(function(handle){return handle.type===7});
        r1.setPosition(xPos-r1.getWidth(),yPos-r1.getHeight());
        r3.setPosition(xPos+objWidth,yPos-r3.getHeight());
        r5.setPosition(xPos+objWidth,yPos+objHeight);
        r7.setPosition(xPos-r7.getWidth(),yPos+objHeight);
        if(!figure.getKeepAspectRatio())
        {
            var r2= figure.selectionHandles.find(function(handle){return handle.type===2});
            var r4= figure.selectionHandles.find(function(handle){return handle.type===4});
            var r6= figure.selectionHandles.find(function(handle){return handle.type===6});
            var r8= figure.selectionHandles.find(function(handle){return handle.type===8});
            r2.setPosition(xPos+(objWidth/2)-(r2.getWidth()/2),yPos-r2.getHeight());
            r4.setPosition(xPos+objWidth,yPos+(objHeight/2)-(r4.getHeight()/2));
            r6.setPosition(xPos+(objWidth/2)-(r6.getWidth()/2),yPos+objHeight);
            r8.setPosition(xPos-r8.getWidth(),yPos+(objHeight/2)-(r8.getHeight()/2));
        }
    }
});
draw2d.policy.figure.RectangleSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.figure.RectangleSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection)
    {
        if(figure.selectionHandles.isEmpty())
        {
            var box = new draw2d.shape.basic.Rectangle({bgColor:null, dashArray:"- ", color:"#2C70FF", stroke:0.5});
            box.hide= function(){
                box.setCanvas(null);
            };
            box.show= function(canvas){
                box.setCanvas(canvas);
                box.toFront(figure);
            };
            var r1= draw2d.Configuration.factory.createResizeHandle(figure,1); 
            var r3= draw2d.Configuration.factory.createResizeHandle(figure,3); 
            var r5= draw2d.Configuration.factory.createResizeHandle(figure,5); 
            var r7= draw2d.Configuration.factory.createResizeHandle(figure,7); 
            figure.selectionHandles.add(r1);
            figure.selectionHandles.add(r3);
            figure.selectionHandles.add(r5);
            figure.selectionHandles.add(r7);
            r1.show(canvas);
            r3.show(canvas);
            r5.show(canvas);
            r7.show(canvas);
            if(figure.isResizeable()===false) {
              r1.setBackgroundColor(null);
              r3.setBackgroundColor(null);
              r5.setBackgroundColor(null);
              r7.setBackgroundColor(null);
              r1.setDraggable(false);
              r3.setDraggable(false);
              r5.setDraggable(false);
              r7.setDraggable(false);
            }
            if((!figure.getKeepAspectRatio()) && figure.isResizeable())
            {
                var r2= draw2d.Configuration.factory.createResizeHandle(figure,2); 
                var r4= draw2d.Configuration.factory.createResizeHandle(figure,4); 
                var r6= draw2d.Configuration.factory.createResizeHandle(figure,6); 
                var r8= draw2d.Configuration.factory.createResizeHandle(figure,8); 
                figure.selectionHandles.add(r2);
                figure.selectionHandles.add(r4);
                figure.selectionHandles.add(r6);
                figure.selectionHandles.add(r8);
                r2.show(canvas);
                r4.show(canvas);
                r6.show(canvas);
                r8.show(canvas);
            }
            figure.selectionHandles.add(box);
            box.show(canvas);
        }
        this.moved(canvas, figure);
   },
    moved: function(canvas, figure )
    {
        if(figure.selectionHandles.isEmpty()){
            return; 
        }
        var objHeight   = figure.getHeight();
        var objWidth    = figure.getWidth();
        var xPos = figure.getAbsoluteX();
        var yPos = figure.getAbsoluteY();
        var r1= figure.selectionHandles.find(function(handle){return handle.type===1});
        var r3= figure.selectionHandles.find(function(handle){return handle.type===3});
        var r5= figure.selectionHandles.find(function(handle){return handle.type===5});
        var r7= figure.selectionHandles.find(function(handle){return handle.type===7});
        r1.setPosition(xPos-r1.getWidth(),yPos-r1.getHeight());
        r3.setPosition(xPos+objWidth,yPos-r3.getHeight());
        r5.setPosition(xPos+objWidth,yPos+objHeight);
        r7.setPosition(xPos-r7.getWidth(),yPos+objHeight);
        if(!figure.getKeepAspectRatio()  && figure.isResizeable())
        {
            var r2= figure.selectionHandles.find(function(handle){return handle.type===2});
            var r4= figure.selectionHandles.find(function(handle){return handle.type===4});
            var r6= figure.selectionHandles.find(function(handle){return handle.type===6});
            var r8= figure.selectionHandles.find(function(handle){return handle.type===8});
            r2.setPosition(xPos+(objWidth/2)-(r2.getWidth()/2),yPos-r2.getHeight());
            r4.setPosition(xPos+objWidth,yPos+(objHeight/2)-(r4.getHeight()/2));
            r6.setPosition(xPos+(objWidth/2)-(r6.getWidth()/2),yPos+objHeight);
            r8.setPosition(xPos-r8.getWidth(),yPos+(objHeight/2)-(r8.getHeight()/2));
        }
        var box= figure.selectionHandles.last();
        box.setPosition(figure.getAbsolutePosition().translate(-2.5,-2.5));
        box.setDimension(figure.getWidth()+4, figure.getHeight()+4);
        box.setRotationAngle(figure.getRotationAngle());
    }
});
draw2d.policy.figure.AntSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.figure.AntSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection)
    {
        if (figure.selectionHandles.isEmpty()) {
            var box = new draw2d.shape.basic.Rectangle({bgColor:null, dasharray:"- ", color:"#2C70FF"});
            box.hide= function(){
                box.setCanvas(null);
            };
            box.show= function(canvas){
                box.setCanvas(canvas);
                box.shape.toFront();
            };
            box.show(canvas);
            figure.selectionHandles.add(box);
            if(figure.getParent()!==null){
                var line = new draw2d.shape.basic.Line({opacity:0.5, bgColor:null, dasharray:"- ", color:"#2C70FF"});
                line.show= function(canvas) {
                    line.setCanvas(canvas);
                };
                line.hide= function(){
                    line.setCanvas(null);
                };
                line.show(canvas);
                figure.selectionHandles.add(line);
                this._updateBeeLine(line, figure);
            }
        }
        this.moved(canvas, figure);
   },
    moved: function(canvas, figure)
    {
        if(figure.selectionHandles.isEmpty()){
            return; 
        }
        var box= figure.selectionHandles.first();
        box.setPosition(figure.getAbsolutePosition().translate(-2.5,-2.5));
        box.setDimension(figure.getWidth()+4, figure.getHeight()+4);
        box.setRotationAngle(figure.getRotationAngle());
        if(figure.selectionHandles.getSize()>1){
            var line = figure.selectionHandles.get(1);
            this._updateBeeLine( line, figure);
        }
    },
    _updateBeeLine: function(line, figure){
        var parent = figure.getParent();
        if(parent===null){
            return;
        }
        if(parent instanceof draw2d.shape.basic.Line){
            var center =figure.getBoundingBox().getCenter();
            var projection= parent.pointProjection(center);
            if(projection===null){
                var p1= line.getStartPosition();
                var p2= line.getEndPosition();
                var d1= center.distance(p1);
                var d2= center.distance(p1);
                projection=d1<d2?p1:p2;
            }
            var intersection =figure.getBoundingBox().intersectionWithLine(center, projection);
            if(intersection.getSize()>0) {
                line.setStartPosition(figure.getBoundingBox().intersectionWithLine(center, projection).get(0))
                    .setEndPosition(projection);
            }
            else{
                line.setStartPosition(figure.getBoundingBox().getCenter())
                    .setEndPosition(projection);
            }
        }
        else {
            var rect1 = figure.getBoundingBox(),
                rect2 = parent.getBoundingBox();
            var center1 = rect1.getCenter();
            var center2 = rect2.getCenter();
            if (rect1.intersects(rect2)) {
                line.setStartPosition(center1)
                    .setEndPosition(center2);
            }
            else if (rect1.hitTest(center2) || rect2.hitTest(center1)) {
                line.setStartPosition(center1)
                    .setEndPosition(center2);
            }
            else {
                rect1.scale(3, 3);
                rect2.scale(3, 3);
                line.setStartPosition(rect1.intersectionWithLine(center1, center2).get(0))
                    .setEndPosition(rect2.intersectionWithLine(center1, center2).get(0));
            }
        }
    }
}); 
draw2d.policy.figure.VertexSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.figure.VertexSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, connection, isPrimarySelection)
    {
    	var points = connection.getVertices();
    	for(var i=0 ; i<points.getSize(); i++){
    		var handle = new draw2d.shape.basic.VertexResizeHandle(connection, i);
            connection.selectionHandles.add( handle);         
            handle.setDraggable(connection.isResizeable());
            handle.show(canvas);
            if(i!==0){
        		var handle = new draw2d.shape.basic.GhostVertexResizeHandle(connection, i-1);
                connection.selectionHandles.add( handle);         
                handle.setDraggable(connection.isResizeable());
                handle.show(canvas);
            }
        }
        this.moved(canvas, connection);
    },
    moved: function(canvas,figure)
    {
        figure.selectionHandles.each(function(i,e){
            e.relocate();
        });
    }
});
draw2d.policy.line.LineSelectionFeedbackPolicy = draw2d.policy.figure.SelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.line.LineSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection)
    {
        if(figure.selectionHandles.isEmpty()){
            figure.selectionHandles.add( new draw2d.shape.basic.LineStartResizeHandle(figure));
            figure.selectionHandles.add( new draw2d.shape.basic.LineEndResizeHandle(figure));
            figure.selectionHandles.each(function(i,e){
                e.setDraggable(figure.isResizeable());
                e.show(canvas);
            });
        }
        this.moved(canvas, figure);
    },
    moved: function(canvas,figure)
    {
    	figure.selectionHandles.each(function(i,e){
            e.relocate();
        });
    }
});
draw2d.policy.line.VertexSelectionFeedbackPolicy = draw2d.policy.line.LineSelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.line.VertexSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onSelect: function(canvas, figure, isPrimarySelection)
    {
        var startHandle =  new draw2d.shape.basic.LineStartResizeHandle(figure);
        var endHandle = new draw2d.shape.basic.LineEndResizeHandle(figure);
        figure.selectionHandles.add(startHandle);
        figure.selectionHandles.add( endHandle);
    	var points = figure.getVertices();
    	var count = points.getSize()-1;
    	var i=1;
    	for( ; i<count; i++){
    	    figure.selectionHandles.add( new draw2d.shape.basic.VertexResizeHandle(figure, i));         
    	    figure.selectionHandles.add( new draw2d.shape.basic.GhostVertexResizeHandle(figure, i-1));         
        }
    	figure.selectionHandles.add( new draw2d.shape.basic.GhostVertexResizeHandle(figure, i-1));         
    	figure.selectionHandles.each(function(i,e){
            e.setDraggable(figure.isResizeable());
            e.show(canvas);
        });
        this.moved(canvas, figure);
    }   
});
draw2d.policy.line.OrthogonalSelectionFeedbackPolicy = draw2d.policy.line.LineSelectionFeedbackPolicy.extend({
    NAME : "draw2d.policy.line.OrthogonalSelectionFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.ResizeHandle = draw2d.ResizeHandle.extend({
            NAME : "draw2d.policy.line.OrthogonalSelectionFeedbackPolicy.ResizeHandle",
             init: function( figure, index)
             {
                this._super(figure);
                this.index = index;
             },
            onDragStart: function(x, y, shiftKey, ctrlKey)
            {
                this._super(x, y, shiftKey, ctrlKey);
                this.command = this.getCanvas().getPrimarySelection().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_VERTICES));
                this.vertex = this.owner.getVertex(this.index).clone();
            },
            onDrag: function(dx, dy, dx2, dy2)
            {
                if (this.command == null) {
                    return false;
                }
                var MINDIST = this.owner.getRouter().MINDIST || 10;
                var fromDir = this.owner.getSource().getConnectionDirection(this.owner.getTarget());
                var toDir   = this.owner.getTarget().getConnectionDirection(this.owner.getSource());
                this.vertex.translate(dx2, dy2);
                var vertices = this.owner.getVertices();
                var   count  = vertices.getSize();
                var max = Math.max;
                var min = Math.min;
                if(this.index === 1){
                    var p0 = vertices.get(this.index-1); 
                    var p1 = vertices.get(this.index  ); 
                    var p2 = vertices.get(this.index+1); 
                    if((p1.x == p2.x) && (p0.y == p1.y)){
                       switch(fromDir){
                       case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                          this.owner.setVertex(1,max(p0.x+MINDIST,this.vertex.x), p1.y); 
                          this.owner.setVertex(2,max(p0.x+MINDIST,this.vertex.x), p2.y); 
                          break;
                       case draw2d.geo.Rectangle.DIRECTION_LEFT:
                          this.owner.setVertex(1,min(p0.x-MINDIST,this.vertex.x), p1.y); 
                          this.owner.setVertex(2,min(p0.x-MINDIST,this.vertex.x), p2.y); 
                          break;
                       }
                    }
                    else{
                       switch(fromDir){
                       case draw2d.geo.Rectangle.DIRECTION_UP:
                          this.owner.setVertex(1,p1.x,min(p0.y-MINDIST,this.vertex.y)); 
                          this.owner.setVertex(2,p2.x,min(p0.y-MINDIST,this.vertex.y)); 
                          break;
                       case draw2d.geo.Rectangle.DIRECTION_DOWN:
                          this.owner.setVertex(1,p1.x,max(p0.y+MINDIST,this.vertex.y)); 
                          this.owner.setVertex(2,p2.x,max(p0.y+MINDIST,this.vertex.y)); 
                          break;
                       }
                    }
                 }
                else if(this.index === (count-2)){
                   var p2 = vertices.get(this.index-1);  
                   var p1 = vertices.get(this.index  );  
                   var p0 = vertices.get(this.index+1);  
                   if((p0.x === p1.x) && (p2.y === p1.y)){
                      switch(toDir){
                      case draw2d.geo.Rectangle.DIRECTION_UP:
                         this.owner.setVertex(count - 2,p1.x, min(p0.y-MINDIST,this.vertex.y)); 
                         this.owner.setVertex(count - 3,p2.x, min(p0.y-MINDIST,this.vertex.y)); 
                         break;
                      case draw2d.geo.Rectangle.DIRECTION_DOWN:
                          this.owner.setVertex(count - 2,p1.x, max(p0.y+MINDIST,this.vertex.y)); 
                          this.owner.setVertex(count - 3,p2.x, max(p0.y+MINDIST,this.vertex.y)); 
                         break;
                      }
                   }
                   else{
                      switch(toDir){
                      case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                          this.owner.setVertex(count -2,max(p0.x+MINDIST,this.vertex.x),p1.y); 
                          this.owner.setVertex(count -3,max(p0.x+MINDIST,this.vertex.x),p2.y); 
                         break;
                      case draw2d.geo.Rectangle.DIRECTION_LEFT:
                          this.owner.setVertex(count -2,min(p0.x-MINDIST,this.vertex.x),p1.y); 
                          this.owner.setVertex(count -3,min(p0.x-MINDIST,this.vertex.x),p2.y); 
                         break;
                      }
                   }
                }
                else{
                   var p_m1= vertices.get(this.index-2);
                   var p0  = vertices.get(this.index-1);
                   var p1  = vertices.get(this.index);   
                   var p2  = vertices.get(this.index+1);
                   var p3  = vertices.get(this.index+2);
                   if((p1.x=== p2.x) && (p1.y === p0.y)){
                      if(this.index-2 === 0) {
                         switch(fromDir){
                         case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                             this.owner.setVertex(this.index-1,p0.x,max(this.vertex.y,p_m1.y-MINDIST));          
                             this.owner.setVertex(this.index  ,this.vertex.x,max(this.vertex.y,p_m1.y-MINDIST)); 
                             this.owner.setVertex(this.index+1,this.vertex.x,p2.y);                         
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_LEFT:
                             this.owner.setVertex(this.index-1,p0.x,min(this.vertex.y,p_m1.y+MINDIST));          
                             this.owner.setVertex(this.index  ,this.vertex.x,this.vertex.y); 
                             this.owner.setVertex(this.index+1,this.vertex.x,p2.y);                         
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_UP:
                             this.owner.setVertex(this.index-1,p0.x,min(this.vertex.y,p_m1.y-MINDIST));          
                             this.owner.setVertex(this.index  ,this.vertex.x,min(this.vertex.y,p_m1.y-MINDIST)); 
                             this.owner.setVertex(this.index+1,this.vertex.x,p2.y);                         
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_DOWN:
                             this.owner.setVertex(this.index-1,p0.x,max(this.vertex.y,p_m1.y+MINDIST));          
                             this.owner.setVertex(this.index  ,this.vertex.x,max(this.vertex.y,p_m1.y+MINDIST)); 
                             this.owner.setVertex(this.index+1,this.vertex.x, p2.y);                        
                            break;
                         }
                      }
                      else if((this.index-count+3) === 0) {
                         switch(toDir){
                         case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                             this.owner.setVertex(this.index-1,p0.x,this.vertex.y);                       
                             this.owner.setVertex(this.index  ,max(this.vertex.x,p3.x+MINDIST),this.vertex.y); 
                             this.owner.setVertex(this.index+1,max(this.vertex.x,p3.x+MINDIST),p2.y);          
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_LEFT:
                             this.owner.setVertex(this.index-1,p0.x,this.vertex.y);                       
                             this.owner.setVertex(this.index  ,min(this.vertex.x,p3.x-MINDIST),this.vertex.y); 
                             this.owner.setVertex(this.index+1,min(this.vertex.x,p3.x-MINDIST),p2.y);          
                            break;
                         }
                      }
                      else{
                          this.owner.setVertex(this.index-1,p0.x,this.vertex.y);                          
                          this.owner.setVertex(this.index  ,this.vertex);                                 
                          this.owner.setVertex(this.index+1,this.vertex.x,p2.y);                          
                      }
                   }
                   else if((p0.x === p1.x) && (p1.y===p2.y)){
                      if(this.index-2 === 0) {
                         switch(fromDir){
                         case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                             this.owner.setVertex(this.index-1,max(this.vertex.x,p_m1.x+MINDIST),p0.y);          
                             this.owner.setVertex(this.index  ,max(this.vertex.x,p_m1.x+MINDIST),this.vertex.y); 
                             this.owner.setVertex(this.index+1,p2.x,this.vertex.y);                              
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_LEFT:
                             this.owner.setVertex(this.index-1,min(this.vertex.x,p_m1.x-MINDIST),p0.y);          
                             this.owner.setVertex(this.index  ,min(this.vertex.x,p_m1.x-MINDIST),this.vertex.y); 
                             this.owner.setVertex(this.index+1,p2.x,this.vertex.y);                              
                            break;
                         }
                      }
                      else if((this.index-count+3) === 0) {
                         switch(toDir){
                         case draw2d.geo.Rectangle.DIRECTION_UP:
                             this.owner.setVertex(this.index-1, this.vertex.x,max(this.vertex.y,p0.y));      
                             this.owner.setVertex(this.index  , this.vertex.x,min(this.vertex.y,p3.y-MINDIST));   
                             this.owner.setVertex(this.index+1, p2.x         ,min(this.vertex.y,p3.y-MINDIST));   
                            break;
                         case draw2d.geo.Rectangle.DIRECTION_DOWN:
                             this.owner.setVertex(this.index-1, this.vertex.x,p0.y);                
                             this.owner.setVertex(this.index  , this.vertex.x,max(this.vertex.y,p3.y+MINDIST));   
                             this.owner.setVertex(this.index+1, p2.x         ,max(this.vertex.y,p3.y+MINDIST));   
                            break;
                         }
                      }
                      else{
                          this.owner.setVertex(this.index-1, this.vertex.x,p0.y         );                  
                          this.owner.setVertex(this.index  , this.vertex                );                  
                          this.owner.setVertex(this.index+1, p2.x         ,this.vertex.y);                  
                      }
                   }
                }
                this.relocate();
                if(this.command!==null){
                    this.command.updateVertices(this.owner.getVertices().clone());                   
                }
                this.owner._routingMetaData.routedByUserInteraction = true;             
                return true;
            },
            onDragEnd: function( x, y, shiftKey, ctrlKey)
            {
                var stack = this.getCanvas().getCommandStack();
                stack.execute(this.command);
                this.command = null;
                return true;
            },
            relocate: function()
            {
                var resizeWidthHalf = this.getWidth()/2;
                var resizeHeightHalf= this.getHeight()/2;
                var anchor = this.owner.getVertices().get(this.index);
                if(anchor)
                this.setPosition(anchor.x-resizeWidthHalf,anchor.y-resizeHeightHalf);
            }
        });
    },
    onSelect: function(canvas, connection, isPrimarySelection){
    	this._super(canvas, connection, isPrimarySelection);
    	var points = connection.getVertices();
    	var i=1;
    	for( ; i<(points.getSize()-1); i++){
    		var handle = new this.ResizeHandle(connection, i);
            connection.selectionHandles.add( handle);         
            handle.setDraggable(connection.isResizeable());
            handle.show(canvas);
        }
        this.moved(canvas, connection);
    },
    removeSegment: function(conn, segmentIndex){
       var PADDING = 10;
       var segmentCount  = conn.getVertices().getSize()-1;
       var fromPt  = conn.getStartPoint();
       var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());
       var toPt    = conn.getEndPoint();
       var toDir   = conn.getTarget().getConnectionDirection( conn.getSource());
       var p0 = conn.getVertex(segmentIndex -1);
       var p1 = conn.getVertex(segmentIndex   );
       var p2 = conn.getVertex(segmentIndex +1);
       var p3 = conn.getVertex(segmentIndex +2);
       if(p1.y === p2.y){
          var newX = (p1.x + p2.x) / 2;
          if(segmentIndex === 1){
              switch(fromDir){
                  case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                      newX = Math.max(newX ,fromPt.x+PADDING);
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_LEFT:
                      newX = Math.min(newX ,fromPt.x-PADDING);
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_UP:
                      newX = fromPt.x;
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_DOWN:
                      newX = fromPt.x;
                      break;
              }
          }
          if(segmentIndex === segmentCount-2){
              switch(fromDir){
                  case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                      newX = Math.max(newX ,toPt.x+PADDING);
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_LEFT:
                      newX = Math.min(newX ,toPt.x-PADDING);
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_UP:
                      newX = toPt.x;
                      break;
                  case draw2d.geo.Rectangle.DIRECTION_DOWN:
                      newX = toPt.x;
                      break;
              }
          }
          conn.setVertex(segmentIndex -1, new draw2d.geo.Point(newX,p0.y));
          conn.setVertex(segmentIndex +2, new draw2d.geo.Point(newX,p3.y));
          conn.removeVertexAt(segmentIndex);
          conn.removeVertexAt(segmentIndex);
          conn._routingMetaData.routedByUserInteraction = true; 
       }
       else if(p1.x === p2.x){
           var newY = (p1.y + p2.y) / 2;
           if(segmentIndex === 1){
               switch(fromDir){
                   case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                   case draw2d.geo.Rectangle.DIRECTION_LEFT:
                       newY = fromPt.y;
                       break;
                   case draw2d.geo.Rectangle.DIRECTION_UP:
                   case draw2d.geo.Rectangle.DIRECTION_DOWN:
                       newX = fromPt.x;
                       break;
               }
           }
           if(segmentIndex === segmentCount-2){
               switch(toDir){
                   case draw2d.geo.Rectangle.DIRECTION_RIGHT:
                   case draw2d.geo.Rectangle.DIRECTION_LEFT:
                       newY = toPt.y;
                       break;
                   case draw2d.geo.Rectangle.DIRECTION_UP:
                   case draw2d.geo.Rectangle.DIRECTION_DOWN:
                       newX = toPt.x;
                       break;
               }
           }
           conn.setVertex(segmentIndex -1, new draw2d.geo.Point(p0.x,newY));
           conn.setVertex(segmentIndex +2, new draw2d.geo.Point(p3.x,newY));
           conn.removeVertexAt(segmentIndex);
           conn.removeVertexAt(segmentIndex);
           conn._routingMetaData.routedByUserInteraction = true; 
       }
    },
    splitSegment: function(conn, segmentIndex, x, y){
       var segmentCount  = conn.getVertices().getSize()-1;
       var p1 = conn.getVertex(segmentIndex   );
       var p2 = conn.getVertex(segmentIndex +1);
       var length= 40;
       if(p1.x == p2.x){
          conn._routingMetaData.routedByUserInteraction = true; 
          if(segmentCount === 1){
              var newSegLength = (p1.getDistance(p2)/4)/2; 
              var np1 = new draw2d.geo.Point(p1.x       , y-newSegLength);
              var np2 = new draw2d.geo.Point(p2.x+length, y-newSegLength);
              var np3 = new draw2d.geo.Point(p2.x+length, y+newSegLength);
              var np4 = new draw2d.geo.Point(p2.x       , y+newSegLength);
              conn.insertVertexAt(segmentIndex+1, np1);
              conn.insertVertexAt(segmentIndex+2, np2);
              conn.insertVertexAt(segmentIndex+3, np3);
              conn.insertVertexAt(segmentIndex+4, np4);
          }
          else{
              var np1 = new draw2d.geo.Point(0,0);
              var np2 = new draw2d.geo.Point(0,0);
              if(segmentIndex===0){
                  np1.y = y;
                  np1.x = p1.x ;
                  np2.y = y;
                  np2.x = p2.x+length;
                  conn.setVertex(segmentIndex+1, new draw2d.geo.Point(np2.x,p2.y));
              }
              else if(segmentIndex === segmentCount-1){
                  np1.y = y;
                  np1.x = p1.x-length;
                  np2.y = y;
                  np2.x = p2.x;
                  conn.setVertex(segmentIndex  , new draw2d.geo.Point(np1.x,p1.y));
              }
              else {
                  np1.y = y;
                  np1.x = p1.x - (length/2);
                  np2.y = y;
                  np2.x = p2.x + (length/2);
                  conn.setVertex(segmentIndex  , new draw2d.geo.Point(np1.x,p1.y));
                  conn.setVertex(segmentIndex+1, new draw2d.geo.Point(np2.x,p2.y));
              }
              conn.insertVertexAt(segmentIndex+1, np1);
              conn.insertVertexAt(segmentIndex+2, np2);
          }
       }
       else if(p1.y == p2.y){
          conn._routingMetaData.routedByUserInteraction = true; 
          if(segmentCount===1){
              var newSegLength = (p1.getDistance(p2)/4)/2; 
              var np1 = new draw2d.geo.Point(x-newSegLength, p1.y);
              var np2 = new draw2d.geo.Point(x-newSegLength, p1.y-length);
              var np3 = new draw2d.geo.Point(x+newSegLength, p1.y-length);
              var np4 = new draw2d.geo.Point(x+newSegLength, p1.y);
              conn.insertVertexAt(segmentIndex+1, np1);
              conn.insertVertexAt(segmentIndex+2, np2);
              conn.insertVertexAt(segmentIndex+3, np3);
              conn.insertVertexAt(segmentIndex+4, np4);
          }
          else{
              var np1 = new draw2d.geo.Point(0,0);
              var np2 = new draw2d.geo.Point(0,0);
              if(segmentIndex===0){
                  np1.x = x;
                  np1.y = p1.y;
                  np2.x = x;
                  np2.y = p2.y+length;
                  conn.setVertex(segmentIndex+1, new draw2d.geo.Point(p2.x,np2.y));
              }
              else if(segmentIndex === segmentCount-1){
                  np1.x = x;
                  np1.y = p1.y-length;
                  np2.x = x;
                  np2.y = p2.y;
                  conn.setVertex(segmentIndex  , new draw2d.geo.Point(p1.x,np1.y));
              }
              else {
                  np1.x = x;
                  np1.y = p1.y - (length/2);
                  np2.x = x;
                  np2.y = p2.y + (length/2);
                  conn.setVertex(segmentIndex  , new draw2d.geo.Point(p1.x,np1.y));
                  conn.setVertex(segmentIndex+1, new draw2d.geo.Point(p2.x,np2.y));
              }
              conn.insertVertexAt(segmentIndex+1, np1);
              conn.insertVertexAt(segmentIndex+2, np2);
          }
       }
    },
    onRightMouseDown: function(conn, x, y, shiftKey, ctrlKey){
        var segment = conn.hitSegment(x,y);
        var items = {"split":  {name: draw2d.Configuration.i18n.menu.addSegment}};
        if(segment===null){
            return;
        }
        if(conn.getRouter().canRemoveSegmentAt(conn, segment.index)){
            items.remove= {name: draw2d.Configuration.i18n.menu.deleteSegment};
        }
        $.contextMenu({
            selector: 'body', 
            events:
            {  
                hide: function(){ $.contextMenu( 'destroy' ); }
            },
            callback: $.proxy(function(key, options) 
            {
               switch(key){
               case "remove":
                   var originalVertices = conn.getVertices().clone(true);
                   this.removeSegment(conn, segment.index);
                   var newVertices = conn.getVertices().clone(true);
                   conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                   break;
               case "split":
                   var originalVertices = conn.getVertices().clone(true);
                   this.splitSegment(conn, segment.index, x, y);
                   var newVertices = conn.getVertices().clone(true);
                   conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                   break;
               default:
                   break;
               }
            },this),
            x:x,
            y:y,
            items: items
        });
    }
});
draw2d.policy.port.PortFeedbackPolicy = draw2d.policy.figure.DragDropEditPolicy.extend({
    NAME : "draw2d.policy.port.PortFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
    },
    onHoverEnter: function(canvas, draggedFigure, hoverFigure)
    {
    },
    onHoverLeave: function(canvas, draggedFigure, hoverFigure)
    {
    }
});
draw2d.policy.port.ElasticStrapFeedbackPolicy = draw2d.policy.port.PortFeedbackPolicy.extend({
    NAME : "draw2d.policy.port.ElasticStrapFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.connectionLine = null;
    },
    onDragStart: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
        this.connectionLine = new draw2d.shape.basic.Line();
        this.connectionLine.setCanvas(canvas);
        this.connectionLine.getShapeElement();
        this.onDrag(canvas, figure);
    },
    onDrag: function(canvas, figure)
    {
        var x1 = figure.ox+figure.getParent().getAbsoluteX();
        var y1 = figure.oy+figure.getParent().getAbsoluteY();
        this.connectionLine.setStartPoint(x1,y1);
        this.connectionLine.setEndPoint(figure.getAbsoluteX(),figure.getAbsoluteY());
    },
    onDragEnd: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
        this.connectionLine.setCanvas(null);
        this.connectionLine = null;
    },
    onHoverEnter: function(canvas, draggedFigure, hoverFiger)
    {
    	this.connectionLine.setGlow(true);
    	hoverFiger.setGlow(true);
    },
    onHoverLeave: function(canvas, draggedFigure, hoverFiger)
    {
    	hoverFiger.setGlow(false);
    	this.connectionLine.setGlow(false);
    }
});
draw2d.policy.port.IntrusivePortsFeedbackPolicy = draw2d.policy.port.PortFeedbackPolicy.extend({
    NAME : "draw2d.policy.port.IntrusivePortsFeedbackPolicy",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.connectionLine = null;
        this.tweenable = null;
    },
    onDragStart: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
        var start = 0;
        var allPorts = canvas.getAllPorts().clone();
        allPorts.each(function(i, element){
            if(typeof element.__beforeInflate ==="undefined") {
                element.__beforeInflate = element.getWidth();
            }
	        start = element.__beforeInflate;
    	});
        allPorts.grep(function(p){
    	    return (p.NAME != figure.NAME && p.parent!==figure.parent) || (p instanceof draw2d.HybridPort) || (figure instanceof draw2d.HybridPort);
    	});
        this.tweenable = new Tweenable();
        this.tweenable.tween({
          from:     { 'size': start/2 },
          to:       { 'size': start   },
          duration: 200,
          easing : "easeOutSine",
          step: function(params) {
        	  allPorts.each(function(i, element){
                  element.shape.attr({rx : params.size, ry :params.size});
                  element.width = element.height = params.size*2;
              });
          }
        });
        this.connectionLine = new draw2d.shape.basic.Line();
        this.connectionLine.setCanvas(canvas);
        this.connectionLine.getShapeElement();
        this.connectionLine.setDashArray("- ");
        this.connectionLine.setColor("#30c48a");
        this.onDrag(canvas, figure);
        return true;
    },
    onDrag: function(canvas, figure)
    {
        var x1 = figure.ox+figure.getParent().getAbsoluteX();
        var y1 = figure.oy+figure.getParent().getAbsoluteY();
        this.connectionLine.setStartPoint(x1,y1);
        this.connectionLine.setEndPoint(figure.getAbsoluteX(),figure.getAbsoluteY());
    },
    onDragEnd: function(canvas, figure, x, y, shiftKey, ctrlKey)
    {
        if(this.tweenable) {
            this.tweenable.stop(true);
            this.tweenable.dispose();
            this.tweenable = null;
        }
        canvas.getAllPorts().each(function(i, element){
    	    element.shape.attr({rx : element.__beforeInflate/2, ry :element.__beforeInflate/2});
            element.width = element.height = element.__beforeInflate;
            delete element.__beforeInflate;
    	});
        this.connectionLine.setCanvas(null);
        this.connectionLine = null;
    },
    onHoverEnter: function(canvas, draggedFigure, hoverFiger)
    {
    	this.connectionLine.setGlow(true);
    	hoverFiger.setGlow(true);
    },
    onHoverLeave: function(canvas, draggedFigure, hoverFiger)
    {
    	hoverFiger.setGlow(false);
        if(this.connectionLine===null){
            debugger;
        }
    	this.connectionLine.setGlow(false);
    }
});
draw2d.Configuration = {
    version : "6.1.65",
    i18n : {
        command : {
            move : "Move Shape",
            assignShape : "Add Shapes to Composite",
            groupShapes : "Group Shapes",
            ungroupShapes : "Ungroup Shapes",
            deleteShape : "Delete Shape",
            moveShape : "Move Shape",
            moveLine : "Move Line",
            addShape : "Add Shape",
            moveVertex : "Move Vertex",
            moveVertices : "Move Vertices",
            deleteVertex : "Delete Vertex",
            resizeShape : "Resize Shape",
            collection : "Execute Commands",
            addVertex : "Add Vertex",
            changeAttributes:"Change Attributes",
            connectPorts : "Connect Ports"
        },
        menu : {
            deleteSegment : "Delete Segment",
            addSegment : "Add Segment"
        },
        dialog : {
            filenamePrompt : "Enter Filename:"
        }
    },
    factory:{
    	createResizeHandle: function(forShape, type){
    		return new draw2d.ResizeHandle(forShape, type);
    	},
    	createConnection: function(sourcePort, targetPort, callback, dropTarget){
            console.log("deprecated call factory.createConnection");
            debugger;
    	    return new draw2d.Connection();
    	},
    	createInputPort: function(relatedFigure){
    	    return new draw2d.InputPort();
    	},
        createOutputPort: function(relatedFigure){
            return new draw2d.OutputPort();
        },
        createHybridPort: function(relatedFigure){
            return new draw2d.HybridPort();
        }
    }
};
draw2d.Canvas = Class.extend(
{
    NAME : "draw2d.Canvas",
    init: function(canvasId, width, height)
    {
        var _this = this;
        this.setScrollArea(document.body);
        this.canvasId = canvasId;
        this.html = $("#"+canvasId);
        this.html.css({"cursor":"default"});
        if($.isNumeric(width) && $.isNumeric(height)){
            this.initialWidth  = width;
            this.initialHeight = height;
        }
        else{
            this.initialWidth  = this.getWidth();
            this.initialHeight = this.getHeight();
        }
        this.html.css({"-webkit-tap-highlight-color": "rgba(0,0,0,0)"});
        if(typeof this.html.droppable !=="undefined"){
            this.html.droppable({
                accept: '.draw2d_droppable',
                over: function(event, ui) {
                    _this.onDragEnter(ui.draggable);
                },
                out: function(event, ui) {
                    _this.onDragLeave(ui.draggable);
                },
                drop: function(event, ui){
                    event = _this._getEvent(event);
                    var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    _this.onDrop(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
                }
            });
            $(".draw2d_droppable").draggable({
                appendTo:"body",
                stack:"body",
                zIndex: 27000,
                helper:"clone",
                drag: function(event, ui){
                    event = _this._getEvent(event);
                    var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    _this.onDrag(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
                },
                stop: function(e, ui){
                },
                start: function(e, ui){
                    $(ui.helper).addClass("shadow");
                }
           });
        }
        if($.isNumeric(height)){
            this.paper = Raphael(canvasId, width, height);
        }
        else{
            this.paper = Raphael(canvasId, this.getWidth(), this.getHeight());
        }
        this.paper.canvas.style.position="absolute";
        this.zoomPolicy = null; 
        this.zoomFactor = 1.0; 
        this.selection  = new draw2d.Selection();
        this.currentDropTarget = null;
        this.currentHoverFigure = null;
        this.regionDragDropConstraint =  new draw2d.policy.figure.RegionEditPolicy(0,0,this.getWidth(), this.getHeight());
        this.eventSubscriptions = {};
        this.editPolicy = new draw2d.util.ArrayList();
        this.figures     = new draw2d.util.ArrayList();
        this.lines       = new draw2d.util.ArrayList(); 
        this.commonPorts = new draw2d.util.ArrayList();
        this.dropTargets = new draw2d.util.ArrayList();
        this.resizeHandles = new draw2d.util.ArrayList();
        this.commandStack = new draw2d.command.CommandStack();
        this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
        this.lineIntersections = new draw2d.util.ArrayList();
        this.installEditPolicy( new draw2d.policy.canvas.WheelZoomPolicy());                
        this.installEditPolicy( new draw2d.policy.canvas.DefaultKeyboardPolicy());          
        this.installEditPolicy( new draw2d.policy.canvas.BoundingboxSelectionPolicy());     
        this.installEditPolicy( new draw2d.policy.canvas.DropInterceptorPolicy());          
        this.installEditPolicy( new draw2d.policy.connection.ComposedConnectionCreatePolicy(
                                [
                                    new draw2d.policy.connection.DragConnectionCreatePolicy(),  
                                    new draw2d.policy.connection.ClickConnectionCreatePolicy()  
                                ])
        );
        this.commandStack.addEventListener(function(event){
            if(event.isPostChangeEvent()===true){
                _this.calculateConnectionIntersection();
                _this.linesToRepaintAfterDragDrop.each(function(i,line){
                    line.svgPathString=null;
                    line.repaint();
                });
                _this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
            }
        });
        this.mouseDown  = false;
        this.mouseDownX = 0;
        this.mouseDownY = 0;
        this.mouseDragDiffX =0;
        this.mouseDragDiffY =0;
        this.html.bind("mouseup touchend", function(event)
        {
            if (_this.mouseDown === false){
                return;
            }
            event = _this._getEvent(event);
            _this.calculateConnectionIntersection();
            _this.mouseDown = false;
            var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            _this.editPolicy.each(function(i,policy){
                policy.onMouseUp(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
            });
            _this.mouseDragDiffX = 0;
            _this.mouseDragDiffY = 0;
        });
        this.html.bind("mousemove touchmove", function(event)
        {
            event  = _this._getEvent(event);
            var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            if (_this.mouseDown === false){
               try{
	               var hover = _this.getBestFigure(pos.x,pos.y);
	               if(hover !== _this.currentHoverFigure && _this.currentHoverFigure!==null){
	            	   _this.currentHoverFigure.onMouseLeave(); 
	            	   _this.currentHoverFigure.fireEvent("mouseleave");
                       _this.fireEvent("mouseleave", {figure:_this.currentHoverFigure});
	               }
	               if(hover !== _this.currentHoverFigure && hover!==null){
	            	   hover.onMouseEnter();
	            	   hover.fireEvent("mouseenter");
                       _this.fireEvent("mouseenter", {figure:hover});
	               }
	               _this.currentHoverFigure = hover;
               }
               catch(exc){
            	   console.log(exc);
               }
               _this.editPolicy.each(function(i,policy){
                   policy.onMouseMove(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
               });
               _this.fireEvent("mousemove",{x:pos.x, y:pos.y, shiftKey:event.shiftKey, ctrlKey:event.ctrlKey, hoverFigure:_this.currentHoverFigure});
            }
            else{
               var diffXAbs = (event.clientX - _this.mouseDownX)*_this.zoomFactor;
               var diffYAbs = (event.clientY - _this.mouseDownY)*_this.zoomFactor;
               _this.editPolicy.each(function(i,policy){
                   policy.onMouseDrag(_this,diffXAbs, diffYAbs, diffXAbs-_this.mouseDragDiffX, diffYAbs-_this.mouseDragDiffY,  event.shiftKey, event.ctrlKey);
               });
               _this.mouseDragDiffX = diffXAbs;
               _this.mouseDragDiffY = diffYAbs;
               _this.fireEvent("mousemove",{x:pos.x, y:pos.y, shiftKey:event.shiftKey, ctrlKey:event.ctrlKey, hoverFigure:_this.currentHoverFigure});
           }
        });
        this.html.bind("mousedown touchstart", function(event)
        {
            try{
            var pos = null;
            switch (event.which) {
            case 1: 
            case 0: 
                try{
                    event.preventDefault();
                    event = _this._getEvent(event);
                    _this.mouseDownX = event.clientX;
                    _this.mouseDownY = event.clientY;
                    _this.mouseDragDiffX = 0;
                    _this.mouseDragDiffY = 0;
                    pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    _this.mouseDown = true;
                    _this.editPolicy.each(function(i,policy){
                        policy.onMouseDown(_this,pos.x,pos.y, event.shiftKey, event.ctrlKey);
                    });
                }
                catch(exc){
                    console.log(exc);
                }
                break;
            case 3: 
                event.preventDefault();
                event = _this._getEvent(event);
                pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                _this.onRightMouseDown(pos.x, pos.y, event.shiftKey, event.ctrlKey);
                break;
            case 2:
                break;
             default:
            }
            }
            catch(exc){
                console.log(exc);
            }
        });
        this.html.on("dblclick",function(event)
        {
            event = _this._getEvent(event);
            _this.mouseDownX = event.clientX;
            _this.mouseDownY = event.clientY;
            var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            _this.onDoubleClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
        });
        this.html.on("click",function(event)
        {
            event = _this._getEvent(event);
            if(_this.mouseDownX === event.clientX ||  _this.mouseDownY === event.clientY){
                var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                _this.onClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
            }
        });
        this.html.on('MozMousePixelScroll DOMMouseScroll mousewheel', function(e) {
            var event = _this._getEvent(e);
            var pos = _this.fromDocumentToCanvasCoordinate(event.originalEvent.clientX, event.originalEvent.clientY);
            var delta = 0;
            if (e.type == 'mousewheel') {
                delta = (e.originalEvent.wheelDelta * -1);
            }
            else if (e.type == 'DOMMouseScroll') {
                delta = 40 * e.originalEvent.detail;
            }
            var returnValue = _this.onMouseWheel(delta, pos.x, pos.y, event.shiftKey, event.ctrlKey);
            if(returnValue===false){
                e.preventDefault();
            }
        });
        this.keyupCallback = function(event) {
            var target =$(event.target);
            if(!target.is("input") && !target.is("textarea")){
                _this.editPolicy.each(function(i,policy){
                    if(policy instanceof draw2d.policy.canvas.KeyboardPolicy){
                        policy.onKeyUp(_this, event.keyCode, event.shiftKey, event.ctrlKey);
                    }
               });
             }
        };
        $(document).bind("keyup", this.keyupCallback);
        this.keydownCallback = function(event) {
            var target =$(event.target);
            if(!target.is("input") && !target.is("textarea")){
               _this.editPolicy.each(function(i,policy){
                   if(policy instanceof draw2d.policy.canvas.KeyboardPolicy){
                       policy.onKeyDown(_this, event.keyCode, event.shiftKey, event.ctrlKey);
                   }
              });
            }
        };
        $(document).bind("keydown",this.keydownCallback);
    },
    destroy: function()
    {
      this.clear();
      $(document).unbind("keydown", this.keydownCallback);
      $(document).unbind("keyup"  , this.keyupCallback);
      this.eventSubscriptions = {};
     try{
          this.paper.remove();
      }catch(exc){
      }
    },
    clear: function()
    {
        this.fireEvent("clear");
        var _this = this;
        this.lines.clone().each(function(i,e){
            _this.remove(e);
        });
         this.figures.clone().each(function(i,e){
            _this.remove(e);
        });
        this.zoomFactor =1.0;
        this.selection.clear();
        this.currentDropTarget = null;
        this.figures = new draw2d.util.ArrayList();
        this.lines = new draw2d.util.ArrayList();
        this.commonPorts = new draw2d.util.ArrayList();
        this.dropTargets = new draw2d.util.ArrayList();
        this.commandStack.markSaveLocation();
        this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
        this.lineIntersections = new draw2d.util.ArrayList();
        this.fireEvent("select",{figure:null});
        return this;
    },
    hideDecoration: function()
    {
    },
    showDecoration: function()
    {
    },
    calculateConnectionIntersection: function()
    {
        var _this = this;
        this.lineIntersections = new draw2d.util.ArrayList();
        var lines = this.getLines().clone();
        while(lines.getSize()>0){
            var l1 = lines.removeElementAt(0);
            lines.each(function(ii,l2){
                var partInter =l1.intersection(l2);
                if(partInter.getSize()>0){
                   _this.lineIntersections.add({line:l1, other:l2, intersection:partInter});
                   _this.lineIntersections.add({line:l2, other:l1, intersection:partInter});
                }
            });
        }
        return this;
    },
    installEditPolicy: function(policy)
    {
        var _this = this;
        if(policy instanceof draw2d.policy.canvas.SelectionPolicy){
            this.getSelection().getAll().each(function(i,figure){
                figure.unselect();
            });
            this.editPolicy.grep(function(p){
                var stay = !(p instanceof draw2d.policy.canvas.SelectionPolicy); 
                if(stay===false){
                    p.onUninstall(_this);
                }
                return stay;
            });
        }
        else if(policy instanceof draw2d.policy.canvas.ZoomPolicy){
            this.editPolicy.grep(function(p){
                var stay = !(p instanceof draw2d.policy.canvas.ZoomPolicy);
                if(stay===false){
                    p.onUninstall(_this);
                }
                return stay;
            });
            this.zoomPolicy = policy;
        }
        else if(policy instanceof draw2d.policy.connection.ConnectionCreatePolicy){
            this.editPolicy.grep(function(p){
                var stay = !(p instanceof draw2d.policy.connection.ConnectionCreatePolicy);
                if(stay===false){
                    p.onUninstall(_this);
                }
                return stay;
            });
        }
        else if( policy instanceof draw2d.policy.canvas.DropInterceptorPolicy){
        }
        policy.onInstall(this);
        this.editPolicy.add(policy);  
        return this;
    },
    uninstallEditPolicy: function(policy)
    {
        if(policy===null){
            return; 
        }
        var removed = this.editPolicy.remove(policy);
        if(removed!==null){
            removed.onUninstall(this);
            if(removed instanceof draw2d.policy.canvas.ZoomPolicy){
                this.zoomPolicy = null;
            }
        }
        else{
            var _this = this;
            var name = (typeof policy === "string")?policy:policy.NAME;
            this.editPolicy.grep(function(p){
                if(p.NAME === name){
                    p.onUninstall(_this);
                    if(p instanceof draw2d.policy.canvas.ZoomPolicy){
                        _this.zoomPolicy = null;
                    }
                    return false;
                }
                return true;
            });
        }
        return this;
    },
    getDropInterceptorPolicies: function()
    {
        return  this.editPolicy.clone().grep(function(p){
                   return (p instanceof  draw2d.policy.canvas.DropInterceptorPolicy);
                });
    },
    setZoom: function(zoomFactor, animated)
    {
        if(this.zoomPolicy){
            this.zoomPolicy.setZoom(zoomFactor, animated);
        }
    },
    getZoom: function()
    {
        return this.zoomFactor;
    },
    getDimension: function()
    {
        return new draw2d.geo.Rectangle(0,0,this.initialWidth, this.initialHeight);
    },
    setDimension: function(dim, height)
    {
        if (typeof dim === "undefined"){
            var widths  = this.getFigures().clone().map(function(f){ return f.getAbsoluteX()+f.getWidth();});
            var heights = this.getFigures().clone().map(function(f){ return f.getAbsoluteY()+f.getHeight();});
            this.initialHeight = Math.max.apply(Math,heights.asArray());
            this.initialWidth  = Math.max.apply(Math,widths.asArray());
        }
        else if(dim instanceof draw2d.geo.Rectangle){
            this.initialWidth  = dim.w;
            this.initialHeight = dim.h;
        }
        else if(typeof dim.width ==="number" && typeof dim.height ==="number"){
            this.initialWidth  = dim.width;
            this.initialHeight = dim.height;
        }
        else if(typeof dim ==="number" && typeof height ==="number"){
            this.initialWidth  = dim;
            this.initialHeight = height;
        }
        this.html.css({"width":this.initialWidth+"px", "height":this.initialHeight+"px"});
        this.paper.setSize(this.initialWidth, this.initialHeight);
        this.setZoom(this.zoomFactor, false);
        return this;
    },
    fromDocumentToCanvasCoordinate: function(x, y)
    {
        return new draw2d.geo.Point(
                (x - this.getAbsoluteX() + this.getScrollLeft())*this.zoomFactor,
                (y - this.getAbsoluteY() + this.getScrollTop())*this.zoomFactor);
    },
    fromCanvasToDocumentCoordinate: function(x,y)
    {
        return new draw2d.geo.Point(
                ((x*(1/this.zoomFactor)) + this.getAbsoluteX() - this.getScrollLeft()),
                ((y*(1/this.zoomFactor)) + this.getAbsoluteY() - this.getScrollTop()));
    },
    getHtmlContainer: function()
    {
       return this.html; 
    },
    _getEvent: function(event)
    {
      if(typeof event.originalEvent !== "undefined"){  
          if(event.originalEvent.touches && event.originalEvent.touches.length) {
               return event.originalEvent.touches[0];
          } else if(event.originalEvent.changedTouches && event.originalEvent.changedTouches.length) {
               return event.originalEvent.changedTouches[0];
          }
      }
      return event;
    },
    setScrollArea: function(elementSelector)
    {
       this.scrollArea= $(elementSelector);
       return this;
    },
    getScrollArea: function()
    {
       return this.scrollArea;
    },
    getScrollLeft: function()
    {
      return this.getScrollArea().scrollLeft();
    },
    getScrollTop: function()
    {
      return this.getScrollArea().scrollTop();
    },
    setScrollLeft: function(left)
    {
        this.getScrollArea().scrollLeft();
        return this;
    },
    setScrollTop: function(top)
    {
        this.getScrollArea().scrollTop();
        return this;
    },
    scrollTo: function(top, left)
    {
        this.getScrollArea().scrollTop(top);
        this.getScrollArea().scrollLeft(left);
        return this;
    },
    getAbsoluteX: function()
    {
        return this.html.offset().left;
    },
    getAbsoluteY: function()
    {
      return this.html.offset().top;
    },
    getWidth: function()
    {
        return this.html.width();
    },
    getHeight: function()
    {
      return this.html.height();
    },
    add: function( figure , x,  y)
    {
        if(figure.getCanvas()===this){
            return;
        }
        if(figure instanceof draw2d.shape.basic.Line){
         this.lines.add(figure);
         this.linesToRepaintAfterDragDrop = this.lines;
        }
        else{
         this.figures.add(figure);
         if(typeof y !== "undefined"){
             figure.setPosition(x,y);
         }
         else if(typeof x !== "undefined"){
             figure.setPosition(x);
         }
        }
        figure.setCanvas(this);
        figure.installEditPolicy(this.regionDragDropConstraint);
        figure.getShapeElement();
        figure.repaint();
        this.fireEvent("figure:add", {figure:figure, canvas:this});
        figure.fireEvent("added",{figure:figure, canvas:this});
        figure.fireEvent("move",{figure:figure, dx:0, dy:0});
        if(figure instanceof draw2d.shape.basic.PolyLine) {
            this.calculateConnectionIntersection();
            this.linesToRepaintAfterDragDrop.each(function (i, line) {
                line.svgPathString = null;
                line.repaint();
            });
            this.linesToRepaintAfterDragDrop = new draw2d.util.ArrayList();
        }
        return this;
    },
    remove: function(figure){
        if(figure.getCanvas()!==this){
            return this;
        }
        var _this = this;
        this.editPolicy.each(function(i,policy){
            if(typeof policy.unselect==="function"){
                policy.unselect(_this,figure);
            }
        });
        if(figure instanceof draw2d.shape.basic.Line){
           this.lines.remove(figure);
        }
        else {
           this.figures.remove(figure);
        }
        figure.setCanvas(null);
        if(figure instanceof draw2d.Connection){
           figure.disconnect();
        }
        this.fireEvent("figure:remove", {figure:figure});
        figure.fireEvent("removed", {figure:figure, canvas:this});
        return this;
    },
    getLines: function()
    {
      return this.lines;
    },
    getFigures: function()
    {
      return this.figures;
    },
    getLine: function( id)
    {
      var count = this.lines.getSize();
      for(var i=0; i<count;i++)
      {
         var line = this.lines.get(i);
         if(line.getId()===id){
            return line;
         }
      }
      return null;
    },
    getFigure: function( id)
    {
      var figure = null;
      this.figures.each(function(i,e){
          if(e.id===id){
              figure=e;
              return false;
           }
      });
      return figure;
    },
    getIntersection: function(line)
    {
       var result = new draw2d.util.ArrayList();
       this.lineIntersections.each(function(i, entry){
           if(entry.line ===line){
               entry.intersection.each(function(i,p){
                   result.add({x:p.x, y:p.y, justTouching:p.justTouching, other:entry.other});
               });
           }
       });
       return result;
    },
    snapToHelper:function(figure,  pos)
    {
        if(this.getSelection().getSize()>1){
            return pos;
        }
        var _this = this;
        var orig = pos.clone();
        this.editPolicy.each(function(i,policy){
             pos = policy.snap(_this, figure, pos, orig);
        });
        return pos;
    },
    registerPort: function(port )
    {
      if(!this.commonPorts.contains(port)){
          this.commonPorts.add(port);
      }
      return this;
    },
    unregisterPort: function(port )
    {
        this.commonPorts.remove(port);
        return this;
    },
    getAllPorts: function()
    {
        return this.commonPorts;
    },
    getCommandStack: function()
    {
      return this.commandStack;
    },
    getPrimarySelection: function()
    {
      return this.selection.getPrimary();
    },
    getSelection: function()
    {
      return this.selection;
    },
    setCurrentSelection: function( object )
    {
        var _this = this;
        this.selection.each(function(i,e){
            _this.editPolicy.each(function(i,policy){
                if(typeof policy.unselect==="function"){
                    policy.unselect(_this,e);
                }
            });
        });
        this.addSelection(object);
        return this;
    },
    addSelection:function( object )
    {
        var _this = this;
        var add = function(i, figure){
            _this.editPolicy.each(function(i,policy){
                if(typeof policy.select==="function"){
                    policy.select(_this,figure);
                }
            });            
        };
        if(object instanceof draw2d.util.ArrayList){
            object.each(add);
        }
        else{
            add(0,object);
        }
        return this;
    },
    getBestFigure: function(x, y, blacklist, whitelist)
    {
    	if(!$.isArray(blacklist)){
            if(blacklist)
                blacklist = [blacklist];
            else
                blacklist = [];
    	}
        if(!$.isArray(whitelist)){
            if(whitelist)
                whitelist = [whitelist];
            else
                whitelist = [];
        }
        var result = null;
        var testFigure = null;
        var isInList = function(testFigure, list){
            var i,len; 
            for(i=0,len=list.length; i<len;i++){
                var considering=list[i];
                if($.isFunction(considering)){
                    if(testFigure instanceof considering){
                        return true;
                    }
                }
                else if((considering===testFigure) || (considering.contains(testFigure))){
                    return true;
                }
            }
            return false;
        };
        var isInBlacklist=function(item){return isInList(item,blacklist)};
        var isInWhitelist=whitelist.length===0?function(){return true;}:function(item){return isInList(item,whitelist)};
        var checkRecursive = function(children){
            children.each(function(i,e){
                var c=e.figure;
                checkRecursive(c.children);
                if(result===null && c.isVisible() && c.hitTest(x,y) && !isInBlacklist(c) &&  isInWhitelist(c)){
                    result = c;
                }
                return result===null; 
            });
        };
        var i,len;
        for ( i = 0, len = this.resizeHandles.getSize(); i < len; i++) {
            testFigure = this.resizeHandles.get(i);
            if (testFigure.isVisible() && testFigure.hitTest(x, y) && !isInBlacklist(testFigure) &&  isInWhitelist(testFigure)){
                return testFigure;
            }
        }
        for ( i = 0, len = this.commonPorts.getSize(); i < len; i++) {
            port = this.commonPorts.get(i);
            checkRecursive( port.children);
            if(result===null && port.isVisible() && port.hitTest(x, y) && !isInBlacklist(port) &&  isInWhitelist(port)){
                result = port;
            }
            if(result !==null){
                return result;
            }
        }
        for ( i = (this.figures.getSize()-1); i >=0; i--)
        {
            var figure = this.figures.get(i);
            checkRecursive( figure.children);
            if (result ===null && figure.isVisible() && figure.hitTest(x, y) && !isInBlacklist(figure) &&  isInWhitelist(figure)) {
                result = figure;
            }
            if(result !==null){
                {
                    var resultLine = this.getBestLine(x,y,result);
                    if(resultLine !==null){
                        var lineIndex   = $(resultLine.shape.node).index();
                        var resultIndex = $(result.shape.node).index();
                        if(resultIndex<lineIndex) {
                            return resultLine;
                        }
                    }
                }
                return result;
            }
        }
        var count = this.lines.getSize();
        for(i=0;i< count;i++)
        {
          var line = this.lines.get(i);
          checkRecursive( line.children);
          if(result !==null){
              return result;
          }
        }
        result = this.getBestLine(x,y,blacklist, whitelist);
        if(result !==null){
            return result;
        }
       return result;
    },
    getBestLine: function( x,  y,  lineToIgnore)
    {
    	if(!$.isArray(lineToIgnore)){
    		if(lineToIgnore instanceof draw2d.Figure){
    			lineToIgnore = [lineToIgnore];
    		}
    		else{
    			lineToIgnore=[];
    		}
    	}
    	var count = this.lines.getSize();
	    for(var i=0;i< count;i++)
	    {
	      var line = this.lines.get(i);
	      if(line.isVisible()===true && line.hitTest(x,y)===true  && $.inArray(line, lineToIgnore)===-1)
	      {
	          return line;
	      }
	    }
	    return null;
    }, 
    onDragEnter: function( draggedDomNode )
    {
    },
    onDrag: function(draggedDomNode, x, y )
    {
    },
    onDragLeave: function( draggedDomNode )
    {
    },
    onDrop: function(droppedDomNode, x, y, shiftKey, ctrlKey)
    {
    },
    onDoubleClick: function(x, y, shiftKey, ctrlKey)
    {
        var figure = this.getBestFigure(x, y);
        if(figure===null){
            figure = this.getBestLine(x,y);
        }
        this.fireEvent("dblclick",  {figure:figure, x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        this.editPolicy.each(function(i,policy){
            policy.onDoubleClick(figure, x,y, shiftKey, ctrlKey);
        });
    },
    onClick: function(x, y, shiftKey, ctrlKey)
    {
        var figure = this.getBestFigure(x, y);
        this.fireEvent("click", {
            figure:figure,
            x:x,
            y:y,
            relX: figure!==null?x-figure.getAbsoluteX():0,
            relY: figure!==null?y-figure.getAbsoluteY():0,
            shiftKey:shiftKey,
            ctrlKey:ctrlKey});
        this.editPolicy.each(function(i,policy){
            policy.onClick(figure, x, y, shiftKey, ctrlKey);
        });
    },
    onRightMouseDown: function(x, y, shiftKey, ctrlKey)
    {
        var figure = this.getBestFigure(x, y);
        this.fireEvent("contextmenu",  {figure:figure, x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        if(figure!==null){
            figure.fireEvent("contextmenu", {figure:figure, x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
            figure.onContextMenu(x,y);
            figure.editPolicy.each(function(i,policy){
                policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
            });
        }
        this.editPolicy.each(function(i,policy){
            policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
        });
    },
    onMouseWheel: function(wheelDelta, x, y, shiftKey, ctrlKey)
    {
        var returnValue = true;
        this.fireEvent("wheel", {wheelDelta:wheelDelta, x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        this.editPolicy.each(function(i,policy){
            returnValue =  policy.onMouseWheel( wheelDelta, x, y, shiftKey, ctrlKey) && returnValue;
        });
        return returnValue;
    },
    fireEvent: function(event, args)
    {
        if (typeof this.eventSubscriptions[event] === 'undefined') {
            return;
        }
        var subscribers = this.eventSubscriptions[event];
        for (var i=0; i<subscribers.length; i++) {
            try{
                subscribers[i](this, args);
            }
            catch(exc){
                console.log(exc);
                console.log(subscribers[i]);
                debugger;
            }
        }
    },
    on: function(event, callback)
    {
        var events = event.split(" ");
        for(var i=0; i<events.length; i++){
            if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
                this.eventSubscriptions[events[i]] = [];
            }
            this.eventSubscriptions[events[i]].push(callback);
        }
        return this;
    },
    off: function( eventOrFunction)
    {
        if(typeof eventOrFunction ==="undefined"){
            this.eventSubscriptions = {};
        }
        else if( typeof eventOrFunction === 'string'){
            this.eventSubscriptions[eventOrFunction] = [];
        }
        else{
            for(var event in this.eventSubscriptions ){
                this.eventSubscriptions[event] =$.grep(this.eventSubscriptions[event], function( callback ) { return callback !== eventOrFunction; });
            }
        }
        return this;
    }
});
draw2d.Selection = Class.extend({
    NAME : "draw2d.Selection",
    init: function()
    {
        this.primary = null;
        this.all = new draw2d.util.ArrayList();
    },
    clear: function()
    {
        this.primary = null;
        this.all = new draw2d.util.ArrayList();
        return this;
    },
    getPrimary: function()
    {
        return this.primary;
    },
    setPrimary: function(figure)
    {
        this.primary = figure;
        this.add(figure);
        return this;
    },
    remove: function(figure)
    {
        this.all.remove(figure);
        if(this.primary===figure){
            this.primary = null;
        }
        return this;
    },
    add: function(figure)
    {
        if(figure!==null && !this.all.contains(figure)){
            this.all.add(figure);
        }
        return this;
    },
    contains: function(figure, checkDescendant)
    {
        if(checkDescendant){
            for(var i=0; i<this.all.getSize();i++){
                var figureToCheck = this.all.get(i);
                if(figureToCheck===figure || figureToCheck.contains(figure)){
                    return true;
                }
            }
            return false;
        }
        return this.all.contains(figure);
    },
    getSize: function()
    {
        return this.all.getSize();
    },
    getAll: function(expand)
    {
        if(expand ===true){
            var result = new draw2d.util.ArrayList();
            var addRecursive = function(figures){
                result.addAll(figures,true);
                figures.each(function(index, figure){
                    if(figure instanceof draw2d.shape.composite.StrongComposite){
                        addRecursive(figure.getAssignedFigures());
                    }
                });
            };
            addRecursive(this.all);
            return result;
        }
        return this.all.clone();
    },
    each: function( func, reverse)
    {
        this.all.each(func, reverse);
        return this;
    }
});
draw2d.Figure = Class.extend({
	NAME : "draw2d.Figure",
	MIN_TIMER_INTERVAL: 50, 
    init: function( attr, setter, getter) {
        this.setterWhitelist = $.extend({
            id   : this.setId,
            x   : this.setX,
            y   : this.setY,
            width   : this.setWidth,
            height   : this.setHeight,
            boundingBox : this.setBoundingBox,
            minWidth   : this.setMinWidth,
            minHeight   : this.setMinHeight,
            cssClass   : this.setCssClass,
            userData   : this.setUserData,
            resizeable : this.setResizeable,
            selectable : this.setSelectable,
            angle      : this.setRotationAngle,
            alpha  : this.setAlpha,
            opacity  : this.setAlpha,
            glow  : this.setGlow,
            visible  : this.setVisible,
            keepAspectRatio : this.setKeepAspectRatio
        },setter);
        this.getterWhitelist = $.extend({
            id: this.getId,
            visible: this.isVisible,
            angle: this.getRotationAngle,
            x: this.getX,
            y: this.getY,
            width : this.getWidth,
            height: this.getHeight,
            resizeable : this.isResizeable,
            selectable : this.isSelectable,
            alpha  : this.getAlpha,
            opacity : this.getAlpha
        },getter);
        var _this = this;
        this.id = draw2d.util.UUID.create();
        this.isResizeHandle=false;
        this.command = null;
        this.canvas = null;
        this.shape  = null;
        this.children = new draw2d.util.ArrayList();
        this.selectable = true;
        this.deleteable = true;
        this.resizeable = true;
        this.draggable = true;
        this.visible = true;
        this.keepAspectRatio = false; 
        this.canSnapToHelper = true;
        this.snapToGridAnchor = new draw2d.geo.Point(0,0);    
        this.editPolicy = new draw2d.util.ArrayList();
        this.timerId = -1;
        this.timerInterval = 0;
        this.parent = null;
        this.composite = null;
        this.userData = null;
        this.x = 0;
        this.y = 0;
        this.minHeight = 5;
        this.minWidth = 5;
        this.rotationAngle = 0;
        this.cssClass = this.NAME.replace(new RegExp("[.]","g"), "_");
        this.width  = this.getMinWidth();
        this.height = this.getMinHeight();
        this.alpha = 1.0;
        this.isInDragDrop =false;
        var _this = this;
        this.ox = 0;
        this.oy = 0;
        this.repaintBlocked=false;
        this.lastAppliedAttributes = {};
        this.selectionHandles = new draw2d.util.ArrayList();
        this.panningDelegate = null;
        this.eventSubscriptions = {};
        this.relocateChildrenEventCallback = function(){
            _this.children.each(function(i,e){
                e.locator.relocate(i, e.figure);
            });
        };
        this.defaultSelectionAdapter = this.selectionAdapter = function(){
            return _this;
        };
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());
        this.attr(attr);
    },
    attr: function(name, value){
        var _this = this;
        var orig = this.repaintBlocked;
        try{
            if($.isPlainObject(name)){
                for(key in name){
                    if(key.substring(0,9)==="userData."){
                        if(this.userData===null){this.userData={};}
                        draw2d.util.JSON.set({userData:this.userData}, key, name[key]);
                        this.fireEvent("change:"+key,{value:name[key]});
                    }
                    else{
                        var func=this.setterWhitelist[key];
                        if(func){
                            func.call(this,name[key]); 
                        }
                        else if($.isFunction(name[key])){
                            this[key] = $.proxy(name[key],this);
                        }
                    }
                }
            }
            else if(typeof name === "string"){
                if(typeof value ==="undefined"){
                    var getter = this.getterWhitelist[name];
                    if($.isFunction(getter)){
                        return getter.call(this);
                    }
                    else if(name.substring(0,9)==="userData."){
                        var data = {userData:this.userData};
                        return draw2d.util.JSON.get(data, name);
                    }
                    return; 
                }
                if($.isFunction(value)){
                    value = value();
                }
                if(name.substring(0,9)==="userData."){
                    if(this.userData===null){this.userData={};}
                    draw2d.util.JSON.set({userData:this.userData}, name, value);
                    this.fireEvent("change:"+name,{value:value});
                }
                else{
                    var setter = this.setterWhitelist[name];
                    if (setter){setter.call(this,value);}
                }
            }
            else if($.isArray(name)){
                result = {};
                $.each(name,function(index, entry){
                    result[entry] = _this.attr(entry);
                });
                return result;
            }
            else if(typeof name === "undefined"){
            	var result = {};
            	for(key in this.getterWhitelist){
             		result[key] = this.getterWhitelist[key].call(this);
            	}
            	return result;
            }
        }
        finally{
            this.repaintBlocked=orig;
        }
        return this;
    },
    pick: function(obj, var_keys) {
        var keys = typeof arguments[1] !== 'string' ? arguments[1] : Array.prototype.slice.call(arguments, 1);
        var out = {}, key;
        for (key in keys) {
            if(typeof obj[key] !== "undefined")
                out[key] = obj[key];
        }
        return out;
    },
    select: function(asPrimarySelection){
        if(typeof asPrimarySelection==="undefined"){
            asPrimarySelection=true;
        }
        var _this=this;
        this.editPolicy.each(function(i,e){
              if(e instanceof draw2d.policy.figure.SelectionFeedbackPolicy){
                  e.onSelect(_this.canvas, _this,asPrimarySelection);
              }
        });
        if(this.canvas !== null){
            this.canvas.getSelection().add(this);
        }
         return this;
    },
    unselect: function()
    {
        var _this = this;
        this.editPolicy.each(function(i,e){
              if(e instanceof draw2d.policy.figure.SelectionFeedbackPolicy){
                  e.onUnselect(_this.canvas, _this);
              }
        });
        if(this.canvas !==null){
            this.canvas.getSelection().remove(this);
        }
        return this;
    },
    setSelectionAdapter: function(adapter)
    {
        if(adapter==null){
            this.selectionAdapter = this.defaultSelectionAdapter;
        }
        else {
            this.selectionAdapter = adapter;
        }
        return this;
    },
    getSelectionAdapter: function()
    {
        return this.selectionAdapter;
    },
    isSelected: function(){
        if(this.canvas !==null){
            return this.canvas.getSelection().contains(this);
        }
        return false;
    },
    setUserData: function(object)
    {
      this.userData = object;  
      this.fireEvent("change:userData",{value:object});
      return this;
    },
    getUserData: function()
    {
        return this.userData;
    },
    getId: function()
    {
       return this.id; 
    },
    setId: function(newId)
    {
        this.id = newId; 
        return this;
    },
    getCssClass: function()
    {
       return this.cssClass; 
    },
    setCssClass: function(cssClass)
    {
        this.cssClass = cssClass===null?null:$.trim(cssClass);
        if(this.shape===null){
            return this;
        }
        if(this.cssClass===null){
            this.shape.node.removeAttribute("class");
        }
        else{
            this.shape.node.setAttribute("class", this.cssClass);
        }
        this.fireEvent("change:cssClass",{value:this.cssClass});
        return this;
    },
    hasCssClass: function(className) {
        if(this.cssClass===null){
            return false;
        }
        return new RegExp(' ' + $.trim(className) + ' ').test(' ' + this.cssClass + ' ');
    },
    addCssClass: function( className) 
    {
        className = $.trim(className);
        if (!this.hasCssClass( className)) {
            if(this.cssClass===null){
                this.setCssClass(className);
            }
            else{
                this.setCssClass(this.cssClass + ' ' + className);
            }
            this.fireEvent("change:cssClass",{value:this.cssClass});
        }
        return this;
    },
    removeCssClass: function(className)
    {
        className = $.trim(className);
        var newClass = ' ' + this.cssClass.replace( /[\t\r\n]/g, ' ') + ' ';
        if (this.hasCssClass(className)) {
            while (newClass.indexOf(' ' + className + ' ') >= 0 ) {
                newClass = newClass.replace(' ' + className + ' ', ' ');
            }
            this.setCssClass( newClass.replace(/^\s+|\s+$/g, ''));
            this.fireEvent("change:cssClass",{value:this.cssClass});
       }
        return this;
    },
    toggleCssClass: function( className)
    {
        className = $.trim(className);
        var newClass = ' ' + this.cssClass.replace( /[\t\r\n]/g, ' ' ) + ' ';
        if (this.hasCssClass( className)) {
            while (newClass.indexOf(' ' + className + ' ') >= 0 ) {
                newClass = newClass.replace( ' ' + className + ' ' , ' ' );
            }
            this.setCssClass( newClass.replace(/^\s+|\s+$/g, ''));
        } else {
            this.setCssClass(this.cssClass + ' ' + className);
        }
        this.fireEvent("change:cssClass",{value:this.cssClass});
        return this;
    },
    setCanvas: function( canvas )
    {
      if(canvas===null && this.shape!==null)
      {
         this.unselect();
         this.shape.remove();
         this.shape=null;
      }
      this.canvas = canvas;
      if(this.canvas!==null){
          this.getShapeElement();
      }
      this.lastAppliedAttributes = {};
      if(canvas === null){
    	  this.stopTimer();
      }
      else{
    	  if(this.timerInterval>= this.MIN_TIMER_INTERVAL){
              this.startTimer(this.timerInterval);
    	  }
      }
      this.children.each(function(i,e){
          e.figure.setCanvas(canvas);
      });
      return this;    
     },
     getCanvas: function()
     {
         return this.canvas;
     },
     startTimer: function(milliSeconds)
     {
    	 this.stopTimer();
    	 this.timerInterval = Math.max(this.MIN_TIMER_INTERVAL, milliSeconds);
    	 if(this.canvas!==null){
    		 this.timerId = window.setInterval($.proxy(function(){
    		     this.onTimer();
    		     this.fireEvent("timer");
    		 },this), this.timerInterval);
    	 }
    	 return this;
     },
     stopTimer: function()
     {
    	if(this.timerId>=0){
  		  window.clearInterval(this.timerId);
		  this.timerId=-1;
    	} 
    	return this;
     },
     onTimer: function()
     {
     },
     toFront: function(figure)
     {
         if(this.composite instanceof draw2d.shape.composite.StrongComposite && (typeof figure !=="undefined")){
             var indexFigure = figure.getZOrder();
             var indexComposite= this.composite.getZOrder();
             if(indexFigure<indexComposite){
                 figure = this.composite;
             }
         }
         if(typeof figure ==="undefined"){
             this.getShapeElement().toFront();
             if(this.canvas!==null){
                 var figures = this.canvas.getFigures();
                 var lines = this.canvas.getLines();
                 if(figures.remove(this)!==null){
                     figures.add(this);
                 }else if(lines.remove(this)!==null){
                     lines.add(this);
                 }
             }
         }
         else{
             this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());
             if(this.canvas!==null){
                 var figures = this.canvas.getFigures();
                 var lines = this.canvas.getLines();
                 if(figures.remove(this)!==null){
                     var index = figures.indexOf(figure);
                     figures.insertElementAt(this, index+1);
                 }else if(lines.remove(this)!==null){
                     lines.add(this);
                 }
             }
         }
         var _this = this;
         this.children.each(function(i,child){
             child.figure.toFront(_this);
         });
         this.selectionHandles.each(function(i,handle){
             handle.toFront();
         });
         return this;
     },
     toBack: function(figure )
     {
         if(this.composite instanceof draw2d.shape.composite.StrongComposite){
             this.toFront(this.composite);
             return;
         }
         if(this.canvas!==null){
             var figures = this.canvas.getFigures();
             var lines = this.canvas.getLines();
             if(figures.remove(this)!==null){
                 figures.insertElementAt(this,0);
             }else if(lines.remove(this)!==null){
                 lines.insertElementAt(this,0);
             }
             if(typeof figure !=="undefined"){
                 this.getShapeElement().insertBefore(figure.getShapeElement());
             }
             else{
                 this.getShapeElement().toBack();
             }
         }
         var _this = this;
         this.children.each(function(i,child){
             child.figure.toFront(_this);
         }, true);
         return this;
     },
     installEditPolicy: function(policy)
     {
         if(policy instanceof draw2d.policy.figure.SelectionFeedbackPolicy){
             var _this = this;
             this.editPolicy.grep(function(p){
                 var stay = !(p instanceof draw2d.policy.figure.SelectionFeedbackPolicy); 
                 if(!stay){
                     p.onUninstall(_this);
                 }
                 return stay;
             });
         }
         policy.onInstall(this);
         this.editPolicy.add(policy);
         return this;
     },
     uninstallEditPolicy: function(policy)
     {
         var removedPolicy = this.editPolicy.remove(policy);
         if(removedPolicy !==null){
             removedPolicy.onUninstall(this);
             return; 
         }
         var _this = this;
         var name = (typeof policy === "string")?policy:policy.NAME;
         this.editPolicy.grep(function(p){
             if(p.NAME === name){
                 p.onUninstall(_this);
                 return false;
             }
             return true;
         });
     },
     add: function(child, locator, index)
     {
         if(typeof locator ==="undefined" || locator ===null){
             throw "Second parameter 'locator' is required for method 'Figure#add'";
         }
         child.setParent(this);
         locator.bind(this, child);
         child.on("resize", this.relocateChildrenEventCallback);
         if($.isNumeric(index)){
             this.children.insertElementAt({figure:child, locator:locator}, index);
         }
         else{
             this.children.add({figure:child, locator:locator});
         }
         if(this.canvas!==null){
             child.setCanvas(this.canvas);
         }
         this.repaint();
         return this;
     },
     remove: function(child)
     {
         if(typeof child ==="undefined" || child ===null){
             debug.warn("The parameter child is required for Figure.remove");
             return null;
         }
         var removed = null;
         this.children.grep(function(e){
             var stay = e.figure!==child;
             if(!stay){
                 removed=e;
             }
             return stay;
         });
         if(removed!==null){
             child.setParent(null);
             child.setCanvas(null);
             removed.locator.unbind(this, child);
             child.off(this.relocateChildrenEventCallback);
             this.repaint();
             return removed;
         }
         return null;
     },
     getChildren: function()
     {
         return this.children.clone().map(function(e){return e.figure;});
     },
     resetChildren: function()
     {
         this.children.each(function(i,e){
             e.figure.setCanvas(null);
         });
         this.children= new draw2d.util.ArrayList();
         this.repaint();
         return this;
     },
    getShapeElement: function()
    {
       if(this.shape!==null){
         return this.shape;
       }
      this.shape=this.createShapeElement();
      if(!this.isVisible()){
          this.shape.hide();
      }
      if(this.cssClass!==null){
          this.shape.node.setAttribute("class",this.cssClass);
      }
      return this.shape;
    },
    getTopLevelShapeElement: function()
    {
        return this.getShapeElement();
    },
    createShapeElement: function()
    {
        throw "Inherited class ["+this.NAME+"] must override the abstract method createShapeElement";
    },
     repaint: function(attributes)
     {
         if (this.repaintBlocked===true || this.shape === null){
             return this;
         }
         attributes = attributes || {};
         if(this.visible===true){
             if(this.shape.isVisible()===false){
                 if($.isNumeric(attributes.visibleDuration)){
                     var _this = this;
                     $(this.shape.node).fadeIn(attributes.visibleDuration, function(){
                         _this.shape.show();
                     });
                 }
                 else {
                     this.shape.show();
                 }
             }
         }
         else{
             if(this.shape.isVisible()===true){
                 if($.isNumeric(attributes.visibleDuration)){
                     var _this = this;
                     $(this.shape.node).fadeOut(attributes.visibleDuration, function(){
                         _this.shape.hide();
                     });
                 }
                 else {
                     this.shape.hide();
                 }
             }
        	 return this;
         }
         attributes.opacity = this.alpha;
         attributes = draw2d.util.JSON.flatDiff(attributes, this.lastAppliedAttributes);
         this.lastAppliedAttributes= attributes;
         if(!$.isEmptyObject(attributes)) {
             this.shape.attr(attributes);
         }
         this.applyTransformation();
         this.children.each(function(i,e){
            e.locator.relocate(i, e.figure);
         });
         return this;
     },
     applyTransformation: function()
     {
         return this;
     },
     setGlow: function(flag)
     {
         return this;
     },
     getHandleBBox: function()
     {
        return null;
     },
    onDragStart: function(x, y, shiftKey, ctrlKey )
    {
      this.isInDragDrop =false;
      var bbox = this.getHandleBBox();
      if(bbox!==null && bbox.translate(this.getAbsolutePosition().scale(-1)).hitTest(x,y)===false){
          this.panningDelegate = this.getBestChild(this.getX()+x,this.getY()+y);
          if(this.panningDelegate!==null){
              this.panningDelegate.onDragStart(x-this.panningDelegate.x, y-this.panningDelegate.y, shiftKey, ctrlKey);
          }
          return false;
      }
      this.command = this.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
      if(this.command!==null){
         this.ox = this.getX();
         this.oy = this.getY();
         this.isInDragDrop =true;
         var _this = this;
         var canStartDrag = true;
         this.editPolicy.each(function(i,e){
             if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                 canStartDrag = canStartDrag && e.onDragStart(_this.canvas, _this, x,y,shiftKey,ctrlKey);
             }
         });
          if(canStartDrag) {
              this.fireEvent("dragstart", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});
          }
          return canStartDrag;
      }
      return false;
    },
    onDrag: function( dx,  dy, dx2, dy2, shiftKey, ctrlKey)
    {
      var _this = this;
      this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                var newPos = e.adjustPosition(_this,_this.ox+dx,_this.oy+dy);
                if(newPos) {
                    dx = newPos.x - _this.ox;
                    dy = newPos.y - _this.oy;
                }
            }
      });
      var newPos = new draw2d.geo.Point(this.ox+dx, this.oy+dy);
      if(this.getCanSnapToHelper()){
        newPos = this.getCanvas().snapToHelper(this, newPos);
      }
      this.setPosition(newPos);
      this.editPolicy.each(function(i,e){
          if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
              e.onDrag(_this.canvas, _this);
          }
      });
      this.fireEvent("drag",{dx:dx, dy:dy, dx2:dx2, dy2:dy2, shiftKey:shiftKey, ctrlKey:ctrlKey});
    },
    onPanning: function(dx, dy, dx2, dy2, shiftKey, ctrlKey)
    {
    },
    onPanningEnd: function()
    {
    },
    onDragEnd: function( x, y, shiftKey, ctrlKey)
    {
      var _this = this;
      if (this.command !== null) {
          this.command.setPosition(this.x, this.y);
          this.canvas.getCommandStack().execute(this.command);
          this.command = null;
      }
      this.isInDragDrop = false;
      this.panningDelegate=null;
      this.editPolicy.each(function(i,e){
          if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
              e.onDragEnd(_this.canvas, _this, x, y, shiftKey, ctrlKey);
          }
      });
      this.fireEvent("move",    {figure:this, dx:0, dy:0});
      this.fireEvent("change:x",{figure:this, dx:0});
      this.fireEvent("change:y",{figure:this, dy:0});
      this.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
    },
    delegateTarget: function( draggedFigure )
    {
        var _this = this;
        var delegate = draggedFigure;
        this.getCanvas().getDropInterceptorPolicies().each(function(i, policy){
            delegate = policy.delegateTarget(draggedFigure, _this);
            if(delegate!==null){
                return false; 
            }
        });
        return delegate;
    },
    onDragEnter: function( draggedFigure )
    {
    },
    onDragLeave: function( draggedFigure )
    {
    },
    onDrop: function(dropTarget, x, y, shiftKey, ctrlKey)
    {
    },
    onCatch: function(droppedFigure, x, y, shiftKey, ctrlKey)
    {
    },
    onMouseEnter: function()
    {
    },
    onMouseLeave: function()
    {
    },
    onDoubleClick: function()
    {
    },
    onClick: function()
    {
    },
    onContextMenu: function(x,y)
    {
    },
    setAlpha: function( percent)
    {
      percent = Math.min(1,Math.max(0,parseFloat(percent)));
      if(percent===this.alpha){
         return;
      }
      this.alpha =percent;
      this.repaint();
      this.fireEvent("change:opacity",{value:this.alpha});
      return this;
    },
    getAlpha: function()
    {
        return this.alpha;
    },
    setRotationAngle: function(angle)
    {
        var _this = this;
        this.rotationAngle = angle;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:angle",{value:this.rotationAngle});
        this.repaint();
        return this;
    },
    getRotationAngle: function()
    {
        return this.rotationAngle;
    },
    setVisible: function(flag, duration)
    {
        flag=!!flag;
        if(flag===this.visible){
            return;
        }
    	this.visible = flag;
    	this.repaint({visibleDuration:duration});
        if (this.visible) {
            this.fireEvent("show");
        } else {
            this.fireEvent("hide");
        }
        this.fireEvent("change:visibility",{value:this.visible});
    	return this;
    },
    isVisible: function()
    {
        return this.visible && this.shape!==null;
    },
    setKeepAspectRatio: function( flag)
    {
        this.keepAspectRatio = flag;
        return this;
    },
    getKeepAspectRatio: function()
    {
        return this.keepAspectRatio;
    },
    getZOrder: function()
    {
        if(this.shape===null){
            return -1;
        }
        var i = 0;
        var child = this.shape.node;
        while( (child = child.previousSibling) !== null ) {
          i++;
        }
        return i;
    },
    setCanSnapToHelper: function(flag)
    {
      this.canSnapToHelper = !!flag;
      return this;
    },
    getCanSnapToHelper: function()
    {
      return this.canSnapToHelper;
    },
    getSnapToGridAnchor: function()
    {
      return this.snapToGridAnchor;
    },
    setSnapToGridAnchor: function(point)
    {
      this.snapToGridAnchor = point;
      return this;
    },
    setWidth: function( width)
    {
        this.setDimension(parseFloat(width), this.getHeight());
        this.fireEvent("change:width",{value:this.width});
        return this;
    },
    getWidth: function()
    {
      return this.width;
    },
    setHeight: function( height)
    {
        this.setDimension(this.getWidth(), parseFloat(height));
        this.fireEvent("change:height",{value:this.height});
        return this;
    },
    getHeight: function()
    {
      return this.height;
    },
    getMinWidth: function()
    {
      return this.minWidth;
    },
    setMinWidth: function(w)
    {
      this.minWidth = parseFloat(w);
      this.fireEvent("change:minWidth",{value:this.minWidth});
      this.setWidth(this.getWidth());
      return this;
    },
    getMinHeight: function()
    {
      return this.minHeight;
    },
    setMinHeight: function(h)
    {
        this.minHeight =parseFloat(h);
        this.fireEvent("change:minHeight",{value:this.minHeight});
        this.setHeight(this.getHeight());
        return this;
    },
    setX: function(x)
    {
        this.setPosition(parseFloat(x), this.y);
        this.fireEvent("change:x",{value:this.x});
        return this;
    },
    getX: function()
    {
        return this.x;
    },
    setY: function(y)
    {
        this.setPosition(this.x, parseFloat(y));
        this.fireEvent("change:y",{value:this.y});
        return this;
    },
    getY: function()
    {
        return this.y;
    },
    getAbsoluteX: function()
    {
        if(!this.parent){
            return this.getX();
        }
        return this.getX() + this.parent.getAbsoluteX();  
    },
    getAbsoluteY: function()
    {
        if(!this.parent){
            return this.getY();
        }
        return this.getY() + this.parent.getAbsoluteY();  
    },
    getAbsolutePosition: function()
    {
      return new draw2d.geo.Point(this.getAbsoluteX(), this.getAbsoluteY());
    },
    getAbsoluteBounds: function()
    {
      return new draw2d.geo.Rectangle(this.getAbsoluteX(), this.getAbsoluteY(),this.getWidth(),this.getHeight());
    },
    setPosition: function(x, y)
    {
        if(typeof x==="undefined"){
            debugger;
        }
        var oldPos = {x:this.x, y:this.y};
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }
        var _this = this;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                var newPos = e.adjustPosition(_this,_this.x,_this.y);
                _this.x = newPos.x;
                _this.y = newPos.y;
            }
        });
        this.repaint();
        {
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                    e.moved(_this.canvas, _this);
                }
            });
            var dx = this.x-oldPos.x;
            var dy = this.y-oldPos.y;
            this.fireEvent("move",     {figure:this,dx: dx, dy:dy});
            this.fireEvent("change:x", {figure:this,dx: dx});
            this.fireEvent("change:y", {figure:this,dy: dy});
        }
        return this;
    },
    getPosition: function()
    {
        return new draw2d.geo.Point(this.getX(), this.getY());
    },
    translate: function(dx , dy )
    {
    	this.setPosition(this.getX()+dx,this.getY()+dy);
    	return this;
    },
    setDimension: function(w, h)
    {
        var old = {width:this.width, height:this.height};
        var _this = this;
        w = Math.max(this.getMinWidth(),w);
        h = Math.max(this.getMinHeight(),h);
        if(this.width === w && this.height ===h){
            this.editPolicy.each(function(i,e){
                if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                    e.moved(_this.canvas, _this);
                }
             });
            return this;
        }
        this.editPolicy.each(function(i,e){
              if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                  var newDim = e.adjustDimension(_this,w,h);
                  w = newDim.w;
                  h = newDim.h;
              }
        });
        if(this.keepAspectRatio===true){
            if (w >= this.getMinWidth()) {
                h = this.getHeight() * (w/this.getWidth());
                if(h>=this.getMinHeight()){
                    this.width = w;
                    this.height= h;
                }
            } 
        }
        else{
            this.width = Math.max(this.getMinWidth(),w);
            this.height= Math.max(this.getMinHeight(),h);
        }
        {
            this.repaint();
            this.fireEvent("resize");
            this.fireEvent("change:dimension",{value:{height:this.height, width:this.width, old:old}});
            this.editPolicy.each(function (i, e) {
                if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                    e.moved(_this.canvas, _this);
                }
            });
        }
		return this;
    },
    setBoundingBox: function(rect)
    {
    	rect = new draw2d.geo.Rectangle(rect);
        var orig = this.repaintBlocked;
        this.repaintBlocked=true;
        this.setPosition(rect.x, rect.y);
        this.repaintBlocked=orig;
        this.setDimension(rect.w,rect.h);
        return this;
    },
    getBoundingBox: function()
    {
        return new draw2d.geo.Rectangle(this.getAbsoluteX(),this.getAbsoluteY(),this.getWidth(),this.getHeight());
    },
    hitTest: function ( iX , iY, corona)
    {
        if(typeof corona === "number"){
            return this.getBoundingBox().scale(corona,corona).hitTest(iX,iY);
        }
        return this.getBoundingBox().hitTest(iX,iY);
    },
    setDraggable: function(flag)
    {
      this.draggable= !!flag;
      return this;
    },
    isDraggable: function()
    {
        if(this.composite!==null){
            return this.composite.isMemberDraggable(this, this.draggable);
        }
        return this.draggable;
    },
    isResizeable: function()
    {
      return this.resizeable;
    },
    setResizeable: function(flag)
    {
      this.resizeable=!!flag;
      this.fireEvent("change:resizeable",{value:this.resizeable});
      return this;
    },
    isSelectable: function()
    {
        if(this.composite!==null){
            return this.composite.isMemberSelectable(this, this.selectable);
        }
        return this.selectable;
    },
    setSelectable: function(flag)
    {
      this.selectable=!!flag;
      this.fireEvent("change:selectable",{value:this.selectable});
      return this;
    },
    isStrechable: function()
    {
      return !this.getKeepAspectRatio();
    },
    isDeleteable: function()
    {
      return this.deleteable;
    },
    setDeleteable: function(flag)
    {
      this.deleteable = !!flag;
      this.fireEvent("change:deleteable",{value:this.deleteable});
      return this;
    },
    setParent: function( parent)
    {
      this.parent = parent;
      if(parent!==null) {
          this.setSelectionAdapter(parent.getSelectionAdapter());
      }
      else{
          this.setSelectionAdapter(null);
      }
      return this;
    },
    getParent: function()
    {
      return this.parent;
    },
    contains: function(containedFigure)
    {
        if(containedFigure.getParent()===this){
            return true;
        }
        for(var i= 0,len=this.children.getSize(); i<len;i++){
            var child = this.children.get(i).figure;
            if(child.contains(containedFigure)) {
                return true;
            }
        }
        return false;
    },
    getRoot: function()
    {
        var root = this.parent;
        while(root!==null && root.parent!==null){
            root = root.parent;
        }
        return root;
    },
    setComposite: function( composite)
    {
        if(composite!==null && !(composite instanceof draw2d.shape.composite.StrongComposite)){
            throw "'composite must inherit from 'draw2d.shape.composite.StrongComposite'";
        }
        this.composite = composite;
        return this;
    },
    getComposite: function()
    {
      return this.composite;
    },
    fireEvent: function(event, args) 
    {
        try{
            if (typeof this.eventSubscriptions[event] === 'undefined') {
                return;
            }
            if(this._inEvent===true){
                return;
            }
            this._inEvent=true;
            var subscribers = this.eventSubscriptions[event];
            for (var i=0; i<subscribers.length; i++) {
                subscribers[i](this, args);
            }
        }
        finally{
            this._inEvent=false;
            if(event.substring(0,7)==="change:"){
                this.fireEvent("change",event.substring(7));
            }
       }
    },
    on: function(event, callback, context) {
        var events = event.split(" ");
        if(typeof callback ==="undefined"){
            debugger;
        }
        if(context){
            callback = $.proxy(callback,context);
            callback.___originalCallback = callback;
        }
        for(var i=0; i<events.length; i++){
            if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
                this.eventSubscriptions[events[i]] = [];
            }
            if(-1 !== $.inArray(callback, this.eventSubscriptions[events[i]])){
            }
            else {
                this.eventSubscriptions[events[i]].push(callback);
            }
        }
        return this;
    },
    off: function( eventOrFunction)
    {
        if(typeof eventOrFunction ==="undefined"){
            this.eventSubscriptions = {};
        }
        else if( typeof eventOrFunction === 'string'){
            this.eventSubscriptions[eventOrFunction] = [];
        }
        else{
            for(var event in this.eventSubscriptions ){
                this.eventSubscriptions[event] =$.grep(this.eventSubscriptions[event], function( callback ) { 
                    if(typeof callback.___originalCallback !=="undefined"){
                        return callback.___originalCallback !== eventOrFunction;
                    }
                    return callback !== eventOrFunction; 
                });
            }
        }
        return this;
    },
    getBestChild: function(x, y, figureToIgnore)
    {
        if(!$.isArray(figureToIgnore)){
            if(figureToIgnore instanceof draw2d.Figure){
                figureToIgnore = [figureToIgnore];
            }
            else{
                figureToIgnore=[];
            }
        }
        var result = null;
        var checkRecursive = function(children){
            children.each(function(i,e){
                var c=e.figure;
                checkRecursive(c.children);
                if(result===null && c.isVisible()===true && c.hitTest(x,y)===true && $.inArray(c, figureToIgnore)===-1){
                    result = c;
                }
                return result===null; 
            });
        };
        checkRecursive( this.children);
        return result;
    },
    createCommand: function( request)
    {
      if(request===null){
          return null;
      }
      if(request.getPolicy() === draw2d.command.CommandType.MOVE)
      {
        if(!this.isDraggable()){
          return null;
        }
        return new draw2d.command.CommandMove(this);
      }
      if(request.getPolicy() === draw2d.command.CommandType.DELETE)
      {
        if(!this.isDeleteable()){
           return null;
        }
        return new draw2d.command.CommandDelete(this);
      }
      if(request.getPolicy() === draw2d.command.CommandType.RESIZE)
      {
        if(!this.isResizeable()){
           return null;
        }
        return new draw2d.command.CommandResize(this);
      }
      return null;
    },
    clone: function(cloneMetaData)
    {
        cloneMetaData = $.extend({exludeChildren:false},cloneMetaData);
        var clone = eval("new "+this.NAME+"();");
        var initialId = clone.id;
        clone.setPersistentAttributes( this.getPersistentAttributes());
        clone.id = initialId;
        if(cloneMetaData.exludeChildren===false) {
            clone.resetChildren();
            this.children.each(function (i, entry) {
                var child = entry.figure.clone();
                var locator = entry.locator.NAME ? eval("new " + entry.locator.NAME + "();") : null;
                clone.add(child, locator);
            });
        }
        return clone;
    },
    getPersistentAttributes: function()
    {
        var memento= {
            type  : this.NAME,
            id    : this.id,
            x     : this.getX(),
            y     : this.getY(),
            width : this.width,
            height: this.height,
            alpha : this.alpha,
            angle : this.rotationAngle,
           userData: $.extend(true,{},this.userData)
        };
        if(this.cssClass!==null){
            memento.cssClass= this.cssClass;
        }
        if(this.composite!==null){
            memento.composite = this.composite.getId();
        }
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this.id    = memento.id;
        this.setPosition( parseFloat(memento.x), parseFloat(memento.y));
        if(typeof memento.width !== "undefined"){
            this.width = parseFloat(memento.width);
        }
        if(typeof memento.height !== "undefined"){
            this.height= parseFloat(memento.height);
        }
        if(typeof memento.userData !== "undefined"){
            this.userData= memento.userData;
        }
        if(typeof memento.cssClass !== "undefined"){
            this.setCssClass(memento.cssClass);
        }
        if(typeof memento.alpha !== "undefined"){
            this.setAlpha(parseFloat(memento.alpha));
        }
        if(typeof memento.angle !== "undefined"){
            this.rotationAngle = parseFloat(memento.angle);
        }
        return this;
    }
});
draw2d.shape.node.Node = draw2d.Figure.extend({
	NAME : "draw2d.shape.node.Node",
    init: function( attr ,setter , getter) 
    {
      this.inputPorts = new draw2d.util.ArrayList();
      this.outputPorts= new draw2d.util.ArrayList();
      this.hybridPorts= new draw2d.util.ArrayList();
      this.persistPorts = true;
      this.portRelayoutRequired = true;
      this.cachedPorts = null;
      this._super(
              $.extend({width:50, height:50}, attr),
              $.extend({
                  persistPorts : this.setPersistPorts
              }, setter),
              $.extend({
                  persistPorts : this.getPersistPorts
              }, getter));
    },
    setPersistPorts: function(flag)
    {
        this.persistPorts = flag;
        this.fireEvent("change:persistPorts",{value:this.persistPorts});
        return this;
    },
    getPersistPorts: function()
    {
        return this.persistPorts;
    },
    toFront: function(figure)
    {
        this._super(figure);
        var _this = this;
        this.getPorts().each(function(i,port){
            port.getConnections().each(function(i,connection){
                connection.toFront(figure);
            });
            port.toFront(_this);
        });
        return this;
    },
    toBack: function(figure)
    {
        this.getPorts().each(function(i,port){
            port.getConnections().each(function(i,connection){
                connection.toBack(figure);
            });
            port.toBack(figure);
        });
        this._super(figure);
        return this;
    },
    setVisible: function(flag, duration)
    {
    	if(!flag){
    		this.getPorts().each(function(i,port){
    			port.__initialVisibilityState=port.isVisible();
    			port.setVisible(false, duration);
    		});
    	}
    	else{
    		this.getPorts().each(function(i,port){
    			if(typeof port.__initialVisibilityState !=="undefined"){
    				port.setVisible(port.__initialVisibilityState, duration);
    			}
    			else{
    				port.setVisible(true, duration);
    			}
    			delete port.__initialVisibilityState;
    		});
    	}
    	this._super(flag, duration);
    },
    getPorts: function(recursive)
    {
      if(typeof recursive === "boolean" && recursive===false){
          var ports = new draw2d.util.ArrayList();
          ports.addAll(this.inputPorts);
          ports.addAll(this.outputPorts);
          ports.addAll(this.hybridPorts);
          return ports;
      }
      if(this.cachedPorts===null ){
          this.cachedPorts = new draw2d.util.ArrayList();
          this.cachedPorts.addAll(this.inputPorts);
          this.cachedPorts.addAll(this.outputPorts);
          this.cachedPorts.addAll(this.hybridPorts);
          var _this = this;
          this.children.each(function(i,e){
              _this.cachedPorts.addAll( e.figure.getPorts());
          });
      }
      return this.cachedPorts;
    },
    getInputPorts: function()
    {
      return this.inputPorts
               .clone()
               .addAll(this.hybridPorts);
    },
    getOutputPorts: function()
    {
      return this.outputPorts
          .clone()
          .addAll(this.hybridPorts);
    },
    clone: function(cloneMetaData)
    {
        cloneMetaData = $.extend({excludePorts:false},cloneMetaData);
        var clone = this._super(cloneMetaData);
        if(cloneMetaData.excludePorts ===false) {
            clone.resetPorts();
            var ports = this.getPorts(false);
            ports.each(function (i, port) {
                var clonePort = port.clone();
                var locator = port.getLocator().clone();
                clone.addPort(clonePort, locator);
            });
        }
        return clone;
    },
    getPort: function( portName)
    {
    	var port = null;
        this.getPorts().each(function(i,e){
            if (e.getName() === portName) {
                port = e;
         		return false;
            }
        });
        return port;
    },
    getInputPort: function( portNameOrIndex)
    {
        if(typeof portNameOrIndex === "number"){
            return this.inputPorts.get(portNameOrIndex);
        }
        for ( var i = 0; i < this.inputPorts.getSize(); i++) {
            var port = this.inputPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }
        return null;
    },
    getOutputPort: function( portNameOrIndex)
    {
        if(typeof portNameOrIndex === "number"){
            return this.outputPorts.get(portNameOrIndex);
        }
         for ( var i = 0; i < this.outputPorts.getSize(); i++) {
            var port = this.outputPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }
        return null;
    },
    getHybridPort: function( portNameOrIndex)
    {
        if(typeof portNameOrIndex === "number"){
            return this.hybridPorts.get(portNameOrIndex);
        }
        for ( var i = 0; i < this.hybridPorts.getSize(); i++) {
            var port = this.hybridPorts.get(i);
            if (port.getName() === portNameOrIndex) {
                return port;
            }
        }
        return null;
    },
    addPort: function(port, locator)
    {
        if(!(port instanceof draw2d.Port)){
            throw "Argument is not typeof 'draw2d.Port'. \nFunction: draw2d.shape.node.Node#addPort";
        }
        if(this.cachedPorts !== null){
        	this.cachedPorts.add(port);
        };
        this.portRelayoutRequired=true;
        if (port instanceof draw2d.InputPort) {
            this.inputPorts.add(port);
        }
        else if(port instanceof draw2d.OutputPort){
            this.outputPorts.add(port);
        }
        else if(port instanceof draw2d.HybridPort){
            this.hybridPorts.add(port);
        }
        if((typeof locator !== "undefined") && (locator instanceof draw2d.layout.locator.Locator)){
            port.setLocator(locator);
        }
        port.setParent(this);
        port.setCanvas(this.canvas);
        port.setDeleteable(false);
        if (this.canvas !== null) {
            port.getShapeElement();
            this.canvas.registerPort(port);
        }
    },
    resetPorts: function()
    {
        var _this = this;
        this.getPorts().each(function(i,port){
            _this.removePort(port);
        });
        return this;
    },
    removePort: function(port)
    {
        this.portRelayoutRequired=true;
        this.cachedPorts = null;
        this.inputPorts.remove(port);
        this.outputPorts.remove(port);
        this.hybridPorts.remove(port);
        if (port.getCanvas() !== null) {
            port.getCanvas().unregisterPort(port);
            var connections = port.getConnections();
            for ( var i = 0; i < connections.getSize(); ++i) {
                port.getCanvas().remove(connections.get(i));
            }
        }
        port.setCanvas(null);
    },
    createPort: function(type, locator){
        var newPort = null;
        var count =0;
    	switch(type){
    	case "input":
    		newPort= draw2d.Configuration.factory.createInputPort(this);
    		count = this.inputPorts.getSize();
    		break;
    	case "output":
    		newPort= draw2d.Configuration.factory.createOutputPort(this);
            count = this.outputPorts.getSize();
    		break;
        case "hybrid":
            newPort= draw2d.Configuration.factory.createHybridPort(this);
            count = this.hybridPorts.getSize();
            break;
    	default:
            throw "Unknown type ["+type+"] of port requested";
    	}
   	    newPort.setName(type+count);
    	this.addPort(newPort, locator);
    	this.setDimension(this.width,this.height);
    	return newPort;
    },
    getConnections: function()
    {
        var connections = new draw2d.util.ArrayList();
        var ports = this.getPorts();
        for(var i=0; i<ports.getSize(); i++)
        {
          var port = ports.get(i);
          for (var c = 0, c_size = port.getConnections().getSize() ; c< c_size ; c++)
          {
              if(!connections.contains(port.getConnections().get(c)))
              {
                connections.add(port.getConnections().get(c));
              }
          }
        }
        return connections;
    },
    setCanvas: function(canvas)
    {
        var oldCanvas = this.canvas;
        this._super(canvas);
        var ports = this.getPorts();
        if (oldCanvas !== null) {
            ports.each(function(i,port){
                oldCanvas.unregisterPort(port);
            });
        }
        if (canvas !== null) {
            ports.each(function(i,port){
                port.setCanvas(canvas);
                canvas.registerPort(port);
            });
            this.setDimension(this.width,this.height);
        }
        else {
            ports.each(function(i,port){
                port.setCanvas(null);
            });
        }
    },
    setRotationAngle: function(angle)
    {
        this.portRelayoutRequired=true;
        this._super(angle);
        this.layoutPorts();
    },
    setDimension: function(w,h)
    {
        this.portRelayoutRequired=true;
        this._super(w,h);
    },
    onPortValueChanged: function(relatedPort)
    {
    },
     repaint: function(attributes)
     {
         if (this.repaintBlocked===true || this.shape === null){
             return;
         }
         this._super(attributes);
         this.layoutPorts();
     },
     layoutPorts: function()
    {
         if(this.portRelayoutRequired===false){
             return;
         }
         this.portRelayoutRequired=false;
         this.outputPorts.each(function(i, port){
             port.locator.relocate(i,port);
         });
         this.inputPorts.each(function(i, port){
             port.locator.relocate(i,port);
         });
         this.hybridPorts.each(function(i, port){
             port.locator.relocate(i,port);
         });
     },
    createCommand: function( request)
    {
        if(request===null){
            return null;
        }
        if(request.getPolicy() === draw2d.command.CommandType.ROTATE){
            return new draw2d.command.CommandRotate(this, (this.getRotationAngle()+90)%360);
        }
        return this._super(request);
    },
     getPersistentAttributes: function()
     {
         var memento = this._super();
         if(this.persistPorts===true){
             memento.ports = [];
             this.getPorts().each(function(i,port){
                 memento.ports.push($.extend(port.getPersistentAttributes(),{
                     name   : port.getName(),
                     port   : port.NAME,
                     locator: port.getLocator().NAME
                 }));
             });
         }
         return memento;
     },
     setPersistentAttributes: function(memento)
     {
         this._super(memento);
         if(typeof memento.ports !=="undefined"){
             this.persistPorts = true;
             this.resetPorts();
             $.each(memento.ports, $.proxy(function(i,e){
                 var port    =  eval("new "+e.port+"()");
                 var locator =  eval("new "+e.locator+"()");
                 port.setPersistentAttributes(e);
                 this.addPort(port, locator);
                 port.setName(e.name);
             },this));
         }
     }
});
draw2d.VectorFigure = draw2d.shape.node.Node.extend({
    NAME : "draw2d.VectorFigure",
    init: function( attr, setter, getter)
    {
        this.stroke = 1;
        this.radius = 0;
        this.bgColor= new draw2d.util.Color("#ffffff");
        this.color  = new draw2d.util.Color("#303030");
        this.dasharray = null;
        this.strokeBeforeGlow = this.stroke;
        this.glowIsActive = false;
        this._super( attr, 
            $.extend({
                dasharray : this.setDashArray,
                radius : this.setRadius,
                bgColor: this.setBackgroundColor,
                color  : this.setColor,
                stroke : this.setStroke
            }, setter),
            $.extend({
               dasharray: this.getDashArray,
               radius :   this.getRadius,
               bgColor:   this.getBackgroundColor,
               color  :   this.getColor,
               stroke :   this.getStroke
            }, getter)
        );
    },
     setRadius: function(radius)
     {
        this.radius = radius;
        this.repaint();
        this.fireEvent("change:radius",{value:this.radius});
        return this;
    },
    getRadius: function()
    {
        return this.radius;
    },
    setDashArray: function(dashPattern)
    {
        this.dasharray = dashPattern;
        this.repaint();
        this.fireEvent("change:dashArray",{value:this.dasharray});
        return this;
    },
    getDashArray: function()
    {
        return this.dasharray;
    },
    setGlow: function(flag)
    {
        if(flag === this.glowIsActive) {
            return this;
        }
        this.glowIsActive = flag;
        if(flag===true){
            this.strokeBeforeGlow = this.getStroke();
            this.setStroke(this.strokeBeforeGlow*2.5);
        }
        else {
            this.setStroke(this.strokeBeforeGlow);
        }
        return this;
    },
    repaint: function(attributes)
    {
        if (this.repaintBlocked===true || this.shape === null){
            return;
        }
        attributes= attributes || {};
        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();
        if(typeof attributes.stroke==="undefined"){
            if(this.color === null || this.stroke ===0){
                attributes.stroke = "none";
            }
            else {
                attributes.stroke = this.color.hash();
            }
        }
        draw2d.util.JSON.ensureDefault(attributes,"stroke-width" , this.stroke);
        draw2d.util.JSON.ensureDefault(attributes,"fill" ,this.bgColor.hash());
        draw2d.util.JSON.ensureDefault(attributes,"dasharray" , this.dasharray);
        this._super(attributes);
        return this;
    },
    setBackgroundColor: function(color)
    {
        this.bgColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:bgColor",{value:this.bgColor});
        return this;
    },
   getBackgroundColor: function()
   {
     return this.bgColor;
   },
   setStroke: function( w )
   {
     this.stroke=w;
     this.repaint();
     this.fireEvent("change:stroke",{value:this.stroke});
     return this;
   },
   getStroke: function( )
   {
     return this.stroke;
   },
   setColor: function( color)
   {
     this.color = new draw2d.util.Color(color);
     this.repaint();
     this.fireEvent("change:color",{value:this.color});
     return this;
   },
   getColor: function()
   {
     return this.color;
   },
   getPersistentAttributes: function()
   {
       var memento = $.extend(this._super(), {
           bgColor : this.bgColor.hash(),
           color   : this.color.hash(),
           stroke  : this.stroke,
           radius  : this.radius,
           dasharray : this.dasharray
       });
       return memento;
   },
   setPersistentAttributes: function(memento)
   {
       this._super(memento);
       if(typeof memento.radius !=="undefined"){
           this.setRadius(memento.radius);
        }
       if(typeof memento.bgColor !== "undefined"){
           this.setBackgroundColor(memento.bgColor);
       }
       if(typeof memento.color !== "undefined"){
           this.setColor(memento.color);
       }
       if(typeof memento.stroke !== "undefined" ){
           this.setStroke(memento.stroke===null?0:parseFloat(memento.stroke));
       }
       if(typeof memento.dasharray ==="string"){
           this.dasharray = memento.dasharray;
       }
       return this;
   }  
});
draw2d.shape.basic.Rectangle = draw2d.VectorFigure.extend({
    NAME : "draw2d.shape.basic.Rectangle",
    init: function( attr, setter, getter) {
       this.dasharray = null;
       this._super(
           $.extend({bgColor:"#a0a0a0", color:"#1B1B1B"},attr),
           $.extend({},{
               dash  : this.setDashArray,
               dasharray  : this.setDashArray
           }, setter),
           $.extend({},{
               dash  : this.getDashArray,
               dasharray  : this.getDashArray
           }, getter)
       );
       this.lastAppliedTransformation = "";
     },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }
        attributes =$.extend({},{
            width : this.getWidth(),
            height: this.getHeight(),
            r     : this.getRadius()
        },attributes);
        if(this.dasharray!==null){
            attributes["stroke-dasharray"]=this.dasharray;
        }
        this._super(attributes);
        return this;
    },
    applyTransformation: function()
    {
        var ts= "R"+this.rotationAngle;
        if(this.getRotationAngle()=== 90|| this.getRotationAngle()===270){
            var ratio = this.getHeight()/this.getWidth();
            ts = ts+"S"+ratio+","+1/ratio+","+(this.getAbsoluteX() +this.getWidth()/2)+","+(this.getAbsoluteY() +this.getHeight()/2);
        }
            this.shape.transform(ts);
            this.lastAppliedTransformation = ts;
        return this;
    },
    createShapeElement: function()
    {
       return this.canvas.paper.rect(this.getAbsoluteX(),this.getAbsoluteY(),this.getWidth(), this.getHeight());
    },
    setDashArray: function(pattern)
    {
        this.dasharray = pattern;
        this.repaint();
        this.fireEvent("change:dashArray",{value:this.dasharray});
        return this;
    },
    getDashArray: function(dashPattern)
    {
        return this.dasharray;
    },
    getPersistentAttributes: function()
    {
        var memento = this._super();
        if(this.dasharray!==null){
            memento.dasharray = this.dasharray;
        }
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.dasharray ==="string"){
            this.dasharray = memento.dasharray;
        }
        return this;
    }
});
draw2d.SetFigure = draw2d.shape.basic.Rectangle.extend({
    NAME : "draw2d.SetFigure",
    init: function( attr ,setter, getter)
    {
      this.svgNodes=null;
      this.originalWidth = null;
      this.originalHeight= null;
      this.scaleX = 1;
      this.scaleY = 1;
      this.strokeScale = true; 
      this._super( $.extend({ stroke:0, bgColor:null},attr),setter, getter );
    },
    setCanvas: function( canvas )
    {
      if(canvas===null && this.svgNodes!==null){
         this.svgNodes.remove();
         this.svgNodes=null;
      }
      this._super(canvas);
     },
     setCssClass: function(cssClass)
     {
         this._super(cssClass);
         if(this.svgNodes===null){
             return this;
         }
         if(this.cssClass===null){
             this.svgNodes.forEach(function(e){
                 e.node.removeAttribute("class");
             });
         }
         else{
             this.svgNodes.forEach(function(e){
                 e.node.setAttribute("class", cssClass);
             });
         }
         return this;
     },
    repaint: function(attributes)
    {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }
        if (this.originalWidth !== null) {
        	this.scaleX = this.width / this.originalWidth;
        	this.scaleY = this.height / this.originalHeight;
        }
        attributes= attributes || {};
        this.applyAlpha();
        this._super(attributes);
    },
    setVisible: function(flag, duration)
    {
        this._super(flag, duration);
        if(this.svgNodes!==null){
            if(duration){
                if (this.visible === true) {
                    this.svgNodes.forEach(function(shape){
                        $(shape.node).fadeIn(duration, function(){
                            shape.show();
                        });
                    });
                }
                else {
                    this.svgNodes.forEach(function(shape){
                        $(shape.node).fadeOut(duration, function(){
                            shape.hide();
                        });
                    });
                }
            }
            else {
                if (this.visible === true) {
                    this.svgNodes.show();
                }
                else {
                    this.svgNodes.hide();
                }
            }
        }
    },
    applyAlpha: function()
    {
        this.svgNodes.attr({opacity: this.alpha});
    },
    applyTransformation: function()
    {
        var s = 
        	"S"+this.scaleX+","+this.scaleY+",0,0 "+
        	"R"+this.rotationAngle+","+((this.getWidth()/2)|0)+","+((this.getHeight()/2)|0)+
        	"T" + this.getAbsoluteX() + "," + this.getAbsoluteY()+
            "";
    	this.svgNodes.transform(s);
        if(this.rotationAngle===90 || this.rotationAngle===270){
            var before  = this.svgNodes.getBBox(true);
            var ratio = before.height/before.width;
            var reverseRatio = before.width/before.height;
            var rs = "...S"+ratio+","+reverseRatio+","+(this.getAbsoluteX() +this.getWidth()/2)+","+(this.getAbsoluteY() +this.getHeight()/2);
        	this.svgNodes.transform(rs);
        }
    },
    toFront: function(figure)
    {
        if(this.composite instanceof draw2d.shape.composite.StrongComposite && (typeof figure !=="undefined")){
            var indexFigure = figure.getZOrder();
            var indexComposite= this.composite.getZOrder();
            if(indexFigure<indexComposite){
                figure = this.composite;
            }
        }
        if(typeof figure ==="undefined"){
            this.getShapeElement().toFront();
            if(this.svgNodes!==null){
                this.svgNodes.toFront();
            }
            if(this.canvas!==null){
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if(figures.remove(this)!==null){
                    figures.add(this);
                }else if(lines.remove(this)!==null){
                    lines.add(this);
                }
            }
        }
        else{
            if(this.svgNodes!==null){
                this.svgNodes.insertAfter(figure.getTopLevelShapeElement());
            }
            this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());
            if(this.canvas!==null){
                var figures = this.canvas.getFigures();
                var lines = this.canvas.getLines();
                if(figures.remove(this)!==null){
                    var index = figures.indexOf(figure);
                    figures.insertElementAt(this, index+1);
                }else if(lines.remove(this)!==null){
                    lines.add(this);
                }
            }
        }
        this.children.each(function(i,child){
            child.figure.toFront(figure);
        });
        var _this = this;
        this.getPorts().each(function(i,port){
            port.getConnections().each(function(i,connection){
                connection.toFront(figure);
            });
            port.toFront(_this);
        });
        this.selectionHandles.each(function(i,handle){
            handle.toFront();
        });
        return this;
    },
    toBack: function(figure)
    {
        if(this.composite instanceof draw2d.shape.composite.StrongComposite){
            this.toFront(this.composite);
            return;
        }
        if(this.canvas!==null){
            var figures = this.canvas.getFigures();
            var lines = this.canvas.getLines();
            if(figures.remove(this)!==null){
                figures.insertElementAt(this,0);
            }
            else if(lines.remove(this)!==null){
                lines.insertElementAt(this,0);
            }
        }
        this.children.each(function(i,child){
            child.figure.toBack(figure);
        }, true);
        if(this.svgNodes!==null){
            if(typeof figure !=="undefined"){
                this.svgNodes.insertBefore(figure.getShapeElement());
            }
            else{
                this.svgNodes.toBack();
            }
        }
        if(this.canvas!==null) {
            if (typeof figure !== "undefined") {
                this.getShapeElement().insertBefore(figure.getShapeElement());
            }
            else {
                this.getShapeElement().toBack();
            }
        }
        var _this = this;
        this.getPorts().each(function(i,port){
            port.getConnections().each(function(i,connection){
                connection.toFront(_this);
            });
            port.toFront(_this);
        });
        return this;
    },
    getTopLevelShapeElement: function()
    {
        if(this.svgNodes.length===0) {
            return this.shape;
        }
        return this.svgNodes;
    },
    createShapeElement: function()
    {
       var shape= this.canvas.paper.rect(this.getX(),this.getY(),this.getWidth(), this.getHeight());
       this.svgNodes = this.createSet();
       if(typeof this.svgNodes.forEach==="undefined"){
           var set = this.canvas.paper.set();
           set.push(this.svgNodes);
           this.svgNodes = set;
       }
       this.svgNodes.attr({"stroke-scale": this.strokeScale});
       this.setVisible(this.visible);
       this.setCssClass(this.cssClass);
       var bb = this.svgNodes.getBBox();
       this.originalWidth = bb.width;
       this.originalHeight= bb.height;
       return shape;
    },
    createSet: function()
    {
    	return this.canvas.paper.set(); 
    }
});
draw2d.SVGFigure = draw2d.SetFigure.extend({
    NAME : "draw2d.SVGFigure",
    init: function(attr, setter, getter)
    {
        this.svg = null;
        this._super(
            $.extend({},attr),
            $.extend({
                svg : this.setSVG
            },setter),
            $.extend({
                svg : this.getSVG
            },getter)
        );
    },
    createSet: function()
    {
        if(this.svg === null) {
            this.svg = this.getSVG();
        }
		return this.importSVG(this.canvas, this.svg);
	},
    getSVG: function()
    {
        return this.svg;
    },
    setSVG: function(svg, duration)
    {
        this.svg = svg;
        if(this.canvas !==null && this.svgNodes !==null){
            var newSVGNodes = this.createSet();
            if($.isNumeric(duration)) {
                newSVGNodes.hide();
                newSVGNodes.insertAfter(this.svgNodes);
                var oldSVG = this.svgNodes;
                this.svgNodes = newSVGNodes;
                this.applyTransformation();
                oldSVG.forEach(function ( shape) {
                    $(shape.node).fadeOut(duration, function () {
                        shape.remove();
                    });
                });
                newSVGNodes.forEach(function (shape) {
                    $(shape.node).fadeIn(duration);
                });
            }
            else {
                newSVGNodes.insertAfter(this.svgNodes);
                this.svgNodes.remove();
                this.svgNodes = newSVGNodes;
                this.applyTransformation();
            }
        }
        return this;
    },
    importSVG : function (canvas, rawSVG) 
    {
      var set = canvas.paper.set();
      try {
        if (typeof rawSVG === 'undefined'){
          throw 'No data was provided.';
        }
        var svgDOM= $(rawSVG);
        if(typeof this._dimensionReadFromJSON ==="undefined"){
            if(svgDOM.attr("width") && svgDOM.attr("height")){
                this.setDimension(parseFloat(svgDOM.attr("width")), parseFloat(svgDOM.attr("height")));
            }
            delete this._dimensionReadFromJSON;
        }
        var findStyle = new RegExp('([a-z0-9\-]+) ?: ?([^ ;]+)[ ;]?','gi');
        svgDOM.children().each(function(i,element){
          var shape=null;
          var style=null;
          var attr = { };
          var node = element.tagName;
          var index = node.indexOf(":");
          if(index != -1)
              node = node.substr(index+1);
          $(element.attributes).each(function() {
            switch(this.nodeName) {
              case 'stroke-dasharray':
                attr[this.nodeName] = '- ';
              break;
              case 'style':
                style = this.nodeValue;
              break;
              case 'id':
              case 'xml:space':
                  break;
              default:
                if(this.value){
                    attr[this.nodeName] = this.value;
                }
                else{
                    attr[this.nodeName] = this.nodeValue;
                }
              break;
            }
          });
          if ( style !== null){
            while(findStyle.exec(style)){
              attr[RegExp.$1] = RegExp.$2;
            }
          }
          if (typeof attr['stroke-width'] === 'undefined'){
              attr['stroke-width'] = (typeof attr.stroke === 'undefined' ? 0 : 1.2);
          }
          switch(node) {
            case 'rect':
              shape = canvas.paper.rect();
              if(typeof attr["rx"]!=="undefined") {
                  attr.r = parseInt(attr.rx);
                  delete attr.rx;
              }
              break;
            case 'circle':
              shape = canvas.paper.circle();
              break;
            case 'ellipse':
              shape = canvas.paper.ellipse();
              break;
            case 'path':
              attr.fill ="none";
              shape = canvas.paper.path(attr.d);
              break;
            case 'line':
              attr.d= "M "+attr.x1+" "+attr.y1+"L"+attr.x2+" "+attr.y2;
              attr.fill ="none";
              shape = canvas.paper.path(attr.d);
             break;
            case 'polyline':
              var path = attr.points;
              attr.d = "M "+path.replace(" "," L");
              shape = canvas.paper.path(attr.d);
              break;
            case 'polygon':
              shape = canvas.paper.polygon(attr.points);
              break;
            case 'image':
              shape = canvas.paper.image();
              break;
            case 'tspan':
            case 'text':
                if(element.childNodes.length>0){
                    var child = element.firstChild;
                    do {
                       switch(child.nodeType){
                            case 2:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                                return;
                            case 3:
                            	child = element;
                            	break;
                            case 1:
                        }
                        var subShape = canvas.paper.text(0,0,$(child).text());
                        var subAttr ={"x":parseFloat(child.attributes.x.value), "y":parseFloat(child.attributes.y.value)};
                        subAttr["text-anchor"] = "start";
                        if(typeof child.attributes["text-anchor"]!=="undefined"){
                            subAttr["text-anchor"] = child.attributes["text-anchor"].value;
                        }
                        else if(typeof attr["text-anchor"]!=="undefined"){
                            subAttr["text-anchor"] = attr["text-anchor"];
                        }
                        if(typeof child.attributes["font-size"]!=="undefined"){
                            subAttr["font-size"] = parseInt(child.attributes["font-size"].value);
                        }
                        else if(typeof attr["font-size"]!=="undefined"){
                            subAttr["font-size"] = parseInt(attr["font-size"]);
                        }
                        if(typeof child.attributes["font-family"]!=="undefined"){
                            subAttr["font-family"] = child.attributes["font-family"].value;
                        }
                        else if(typeof attr["font-family"]!=="undefined"){
                            subAttr["font-family"] = attr["font-family"];
                        }
                        subAttr["fill"] = "#000000";
                        if(typeof child.attributes["fill"]!=="undefined"){
                            subAttr["fill"] = child.attributes["fill"].value;
                        }
                        else if(typeof attr["fill"]!=="undefined"){
                            subAttr["fill"] = attr["fill"];
                        }
                        subAttr.y= subAttr.y+subShape.getBBox().height/2;
                        subShape.attr(subAttr);
                        set.push(subShape);
                        child = child.nextSibling;
                    }while(child && child.nodeType === 3); 
                }
                else{
                  shape = canvas.paper.text(0,0,$(element).html());
                  if(typeof attr["fill"]==="undefined")
                      attr["fill"] = "#000000";
                  if(typeof attr["text-anchor"]==="undefined")
                      attr["text-anchor"] = "start";
                  if(typeof attr["font-size"]!=="undefined")
                      attr["font-size"] = parseInt(attr["font-size"]);
                  if(typeof attr["font-family"]!=="undefined")
                      attr["font-family"] = parseInt(attr["font-family"]);
                  attr.y= parseFloat(attr.y)+shape.getBBox().height/2;
                }
              break;
          }
          if(shape!==null){
              shape.attr(attr);
              set.push(shape);
          }
        });
      } catch (error) {
        alert('The SVG data you entered was invalid! (' + error + ')');
      }
      return set;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.width !== "undefined"){
            this._dimensionReadFromJSON=true;
        }
        else if(typeof memento.height !== "undefined"){
            this._dimensionReadFromJSON=true;
        }
        return this;
    }  
});
draw2d.shape.basic.Oval = draw2d.VectorFigure.extend({
    NAME : "draw2d.shape.basic.Oval",
    init: function(attr, setter, getter ) 
    {
        this._super( 
                $.extend({
                    bgColor:"#C02B1D", 
                    color:"#1B1B1B"
                    },attr),
                $.extend({
                    center: this.setCenter
                    },setter),
                getter);
    },
   createShapeElement: function()
   {
     var halfW = this.getWidth()/2;
     var halfH = this.getHeight()/2;
     return this.canvas.paper.ellipse(this.getAbsoluteX()+halfW, this.getAbsoluteY()+halfH, halfW, halfH);
   },
   getCenter: function(){
       var w2= this.getWidth()/2;
       var h2= this.getHeight()/2;
       return this.getPosition().translate(w2,h2);
   },
   setCenter: function(x, y)
   {
       var pos = new draw2d.geo.Point(x,y);
       var w2= this.getWidth()/2;
       var h2= this.getHeight()/2;
       pos.translate(-w2,-h2);
       this.setPosition(pos);
       this.fireEvent("change:center",{value:{x:x,y:y}});
       return this;
   },
   repaint: function(attributes)
   {
       if(this.repaintBlocked===true || this.shape===null){
           return;
       }
       attributes= attributes || {};
       if(typeof attributes.rx === "undefined"){
           attributes.rx = this.width/2;
           attributes.ry = this.height/2;
       }
       if(typeof attributes.cx === "undefined"){
           attributes.cx = this.getAbsoluteX()+attributes.rx;
           attributes.cy = this.getAbsoluteY()+attributes.ry;
       }
       this._super(attributes);
   },
   intersectionWithLine: function(a1, a2)
   {
	   var rx = this.getWidth()/2;
	   var ry = this.getHeight()/2;
	   var result= new draw2d.util.ArrayList();
       var origin = new draw2d.geo.Point(a1.x, a1.y);
       var dir    = a2.subtract(a1);
       var center = new draw2d.geo.Point(this.getAbsoluteX()+rx, this.getAbsoluteY()+ry);
       var diff   = origin.subtract(center);
       var mDir   = new draw2d.geo.Point( dir.x/(rx*rx),  dir.y/(ry*ry)  );
       var mDiff  = new draw2d.geo.Point( diff.x/(rx*rx), diff.y/(ry*ry) );
       var a = dir.dot(mDir);
       var b = dir.dot(mDiff);
       var c = diff.dot(mDiff) - 1.0;
       var d = b*b - a*c;
       if ( d < 0 ) {
       } else if ( d > 0 ) {
           var root = Math.sqrt(d);
           var t_a  = (-b - root) / a;
           var t_b  = (-b + root) / a;
           if ( (t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b) ) {
               if ( (t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1) ){
               }
               else{            	   
                   ;
               }
           } else {
               if ( 0 <= t_a && t_a <= 1 )
                   result.add( a1.lerp(a2, t_a) );
               if ( 0 <= t_b && t_b <= 1 )
                   result.add( a1.lerp(a2, t_b) );
           }
       } else {
           var t = -b/a;
           if ( 0 <= t && t <= 1 ) {
               result.add( a1.lerp(a2, t) );
           } else {
           }
       }
       return result;
   }	 
});
draw2d.shape.basic.Circle = draw2d.shape.basic.Oval.extend({
    NAME : "draw2d.shape.basic.Circle", 
    init: function( attr, setter, getter)
    {
        this._super(
            attr,
            $.extend({
                diameter : this.setDiameter,
                radius   : this.setRadius
            },setter),
            $.extend({
                diameter : this.getDiameter,
                radius   : this.getRadius
            },getter));
        this.setKeepAspectRatio(true);
    },
    setDiameter: function(d)
    {
        var center = this.getCenter();
        this.setDimension(d,d);
        this.setCenter(center); 
        this.fireEvent("change:diameter", {value:d});
        return this;
    },
    getDiameter: function()
    {
        return this.getWidth();
    },
    setRadius: function(r)
    {
        this.setDiameter(r*2);
        this.fireEvent("change:radius", {value:r});
        return this;
    },
    getPersistentAttributes: function()
    {
        var memento =this._super();
        delete memento.radius;
        return memento;
    }
});
draw2d.shape.basic.Label= draw2d.SetFigure.extend({
	NAME : "draw2d.shape.basic.Label",
    FONT_FALLBACK:  {
      'Georgia'            :'Georgia, serif',
      'Palatino Linotype'  :'"Palatino Linotype", "Book Antiqua", Palatino, serif',
      'Times New Roman'    :'"Times New Roman", Times, serif',
      'Arial'              :'Arial, Helvetica, sans-serif',
      'Arial Black'        :'"Arial Black", Gadget, sans-serif',   
      'Comic Sans MS'      :'"Comic Sans MS", cursive, sans-serif',    
      'Impact'             :'Impact, Charcoal, sans-serif',
      'Lucida Sans Unicode':'"Lucida Sans Unicode", "Lucida Grande", sans-serif',  
      'Tahoma, Geneva'     :'Tahoma, Geneva, sans-seri',
      'Trebuchet MS'       :'"Trebuchet MS", Helvetica, sans-serif',
      'Verdana'            :'Verdana, Geneva, sans-serif',
      'Courier New'        :'"Courier New", Courier, monospace',
      'Lucida Console'     :'"Lucida Console", Monaco, monospace'},
    init: function(attr, setter, getter)
    {
        this.text = "";
        this.cachedWidth  = null;
        this.cachedHeight = null;
        this.cachedMinWidth  = null;
        this.cachedMinHeight = null;
        this.fontSize = 12;
        this.fontColor = new draw2d.util.Color("#080808");
        this.fontFamily = null;
        this.padding = {top:4, right:4, bottom:4,left:4};
        this.outlineStroke = 0;
        this.outlineColor = new draw2d.util.Color(null);
        this.bold = false;
        this.editor = null;
        this._super(
            $.extend({stroke:1, width:1,height:1,resizeable:false},attr),
            $.extend({
                text  : this.setText,
                editor : this.installEditor,
                outlineStroke  : this.setOutlineStroke,
                outlineColor  : this.setOutlineColor,
                fontFamily  : this.setFontFamily,
                fontSize  : this.setFontSize,
                fontColor  : this.setFontColor,
                padding  : this.setPadding,
                bold  : this.setBold
            }, setter),
            $.extend({
                text          : this.getText,
                outlineStroke : this.getOutlineStroke,
                outlineColor  : this.getOutlineColor,
                fontFamily    : this.getFontFamily,
                fontSize      : this.getFontSize,
                fontColor     : this.getFontColor,
                padding       : this.getPadding,
                bold          : this.isBold
            }, getter));
        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
        this.lastAppliedLabelRotation = "";
        this.lastAppliedTextAttributes= {};
    },
    createSet: function()
    {
    	return this.canvas.paper.text(0, 0, this.text);
    },
    setCanvas: function( canvas )
    {
        this.clearCache();
        this._super(canvas);
        this.clearCache();
    },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null || (this.parent && this.parent.repaintBlocked===true)){
            return;
        }
        var lattr = this.calculateTextAttr();
        lattr.text = this.text;        
        var attrDiff = draw2d.util.JSON.flatDiff(lattr, this.lastAppliedTextAttributes);
        this.lastAppliedTextAttributes= lattr;
        if(!$.isEmptyObject(attrDiff)){
            this.svgNodes.attr(lattr);
            this.svgNodes.attr({
                    x: (this.padding.left+this.stroke),
                    y: (this.svgNodes.getBBox(true).height/2 +this.padding.top + this.getStroke())
                });
        }
        this._super(attributes);
    },
    calculateTextAttr: function()
    {
        var lattr={"text-anchor":"start",
                   "font-size":this.fontSize,
                   "font-weight":(this.bold===true)?"bold":"normal",
                   fill: this.fontColor.hash(),
                   stroke : this.outlineColor.hash(),
                   "stroke-width": this.outlineStroke
                   };
        if(this.fontFamily!==null){
            lattr["font-family"] = this.fontFamily;
        }
        return lattr;
    },
    applyTransformation: function()
    {
        var ts= "R"+this.rotationAngle;
            this.shape.transform(ts);
            this.lastAppliedLabelRotation = ts;
        this.svgNodes.transform(
                "R" + this.rotationAngle+
                "T" + this.getAbsoluteX() + "," + this.getAbsoluteY());
        return this;
    },
    setFontSize: function( size)
    {
      this.clearCache();
      this.fontSize = size;
      this.repaint();
      this.fireEvent("change:fontSize",{value:this.fontSize});
      this.fireEvent("resize");
      var _this = this;
      this.editPolicy.each(function(i,e){
         if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
             e.moved(_this.canvas, _this);
         }
      });
      return this;
    },
    getFontSize: function( )
    {
      return this.fontSize;
    },
    setBold: function( bold)
    {
      this.clearCache();
      this.bold = bold;
      this.repaint();
      this.fireEvent("change:bold",{value:this.bold});
      this.fireEvent("resize");
      var _this = this;
      this.editPolicy.each(function(i,e){
         if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
             e.moved(_this.canvas, _this);
         }
      });
      return this;
    },
    isBold: function()
    {
        return this.bold;
    },
    setOutlineColor: function( color)
    {
      this.outlineColor = new draw2d.util.Color(color);
      this.repaint();
      this.fireEvent("change:outlineColor",{value:this.outlineColor});
      return this;
    },
    getOutlineColor: function()
    {
      return this.outlineColor;
    },
    setOutlineStroke: function( w )
    {
      this.outlineStroke=w;
      this.repaint();
      this.fireEvent("change:outlineStroke",{value:this.outlineStroke});
      return this;
    },
    getOutlineStroke: function( )
    {
      return this.outlineStroke;
    },
    setFontColor: function( color)
    {
      this.fontColor = new draw2d.util.Color(color);
      this.repaint();
      this.fireEvent("change:fontColor",{value:this.fontColor});
      return this;
    },
    getFontColor: function()
    {
      return this.fontColor;
    },
    setPadding: function( padding)
    {
      this.clearCache();
      if(typeof padding ==="number"){
          this.padding = {top:padding, right:padding, bottom:padding, left:padding};
      }
      else{
          $.extend(this.padding, padding);
      }
      this.repaint();
      this.fireEvent("change:padding",{value:this.padding});
      return this;
    },
    getPadding: function( )
    {
      return this.padding;
    },
    setFontFamily: function( font)
    {
      this.clearCache();
      if((typeof font!=="undefined") && font!==null && typeof this.FONT_FALLBACK[font] !== "undefined"){
          font=this.FONT_FALLBACK[font];
      }
      this.fontFamily = font;
      this.repaint();
      this.fireEvent("change:fontFamily",{value:this.fontFamily});
      return this;
    },
    getFontFamily: function(){
        return this.fontFamily;
    },
    setDimension: function( w, h)
    {
        this.clearCache();
        this._super(w,h);
        return this;
    },
    clearCache: function()
    {
        this.portRelayoutRequired=true;
        this.cachedMinWidth  = null;
        this.cachedMinHeight = null;
        this.cachedWidth=null;
        this.cachedHeight=null;
        this.lastAppliedTextAttributes= {};
        return this;
    },
    getMinWidth: function()
    {
        if (this.shape === null) {
            return 0;
        }
        if(this.cachedMinWidth=== null){
            this.cachedMinWidth= this.svgNodes.getBBox(true).width
                                +this.padding.left
                                +this.padding.right
                                +2*this.getStroke();
       }
        return this.cachedMinWidth;
    },
    getMinHeight: function()
    {
        if (this.shape === null) {
            return 0;
        }
        if(this.cachedMinHeight=== null){
            this.cachedMinHeight= this.svgNodes.getBBox(true).height
                                 +this.padding.top
                                 +this.padding.bottom
                                 +(2*this.getStroke());
        }
        return this.cachedMinHeight;
    },
    getWidth: function()
    {    
        if (this.shape === null) {
            return 0;
        }
        if(this.cachedWidth===null){
            if(this.resizeable===true){
                this.cachedWidth = Math.max(this.width, this.getMinWidth());
            }
            else{
                this.cachedWidth = this.getMinWidth();
            }
        }
        return this.cachedWidth;
    },
    getHeight: function()
    {
        if (this.shape === null) {
            return 0;
        }
        if(this.cachedHeight===null){
            this.cachedHeight = Math.max(this.height, this.getMinHeight());
        }
        return this.cachedHeight;
    },
    installEditor: function( editor )
    {
        if(typeof editor ==="string"){
            editor = eval("new "+editor+"()");
        }
        this.editor = editor;
        return this;
    },
    onDoubleClick: function()
    {
        if(this.editor!==null){
            this.editor.start(this);
        }
    },
    getText: function()
    {
      return this.text;
    },
    setText: function( text )
    {
      this.clearCache();
      this.text = text;
      this.repaint();
      var _this = this;
      this.editPolicy.each(function(i,e){
         if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
             e.moved(_this.canvas, _this);
         }
      });
      this.fireEvent("resize");
      this.fireEvent("change:text",{value:this.text});
      if(this.parent!==null){
          this.parent.repaint();
      }
      return this;
    },
    hitTest: function(x, y) 
    {
        if( this.rotationAngle === 0){
            return this._super(x,y); 
        }
        var matrix = this.shape.matrix;
        var points = this.getBoundingBox().getVertices();
        points.each(function(i,point){
            var x = matrix.x(point.x,point.y);
            var y = matrix.y(point.x,point.y);
            point.x=x;
            point.y=y;
        });
        var polySides=4;
        var i=0;
        var j=polySides-1 ;
        var oddNodes=false;
        for (i=0; i<polySides; i++) {
            var pi = points.get(i);
            var pj = points.get(j);
            if ((pi.y< y && pj.y>=y
            ||   pj.y< y && pi.y>=y)
            &&  (pi.x<=x || pj.x<=x)) {
              if (pi.x+(y-pi.y)/(pj.y-pi.y)*(pj.x-pi.x)<x) {
                oddNodes=!oddNodes; }}
            j=i; }
        return oddNodes; 
     },
     getPersistentAttributes: function()
     {
         var memento = this._super();
         memento.text = this.text;
         memento.outlineStroke = this.outlineStroke;
         memento.outlineColor = this.outlineColor.hash();
         memento.fontSize = this.fontSize;
         memento.fontColor = this.fontColor.hash();
         memento.fontFamily = this.fontFamily;
         if(this.editor !==null){
             memento.editor = this.editor.NAME;
         }
         return memento;
     },
     setPersistentAttributes: function(memento)
     {
         this._super(memento);
         if(typeof memento.text !=="undefined"){
             this.setText(memento.text);
         }
         if(typeof memento.outlineStroke !=="undefined"){
             this.setOutlineStroke(memento.outlineStroke);
         }
         if(typeof memento.outlineColor !=="undefined"){
             this.setOutlineColor(memento.outlineColor);
         }
         if(typeof memento.fontFamily !=="undefined"){
             this.setFontFamily(memento.fontFamily);
         }
         if(typeof memento.fontSize !=="undefined"){
             this.setFontSize(memento.fontSize);
         }
         if(typeof memento.fontColor !=="undefined"){
             this.setFontColor(memento.fontColor);
         }
         if(typeof memento.editor === "string"){
             this.installEditor( eval("new "+memento.editor+"()"));
         }
     }
});
draw2d.shape.basic.Text= draw2d.shape.basic.Label.extend({
	NAME : "draw2d.shape.basic.Text",
    init: function(attr, setter, getter)
    {
        this.cachedWrappedAttr = null;
        this._super($.extend({width:100, height:50, resizeable:true},attr), setter, getter);
        this.installEditPolicy(new draw2d.policy.figure.WidthSelectionFeedbackPolicy());
    },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }
       this.svgNodes.attr($.extend({},this.calculateTextAttr(),this.wrappedTextAttr(this.text, this.getWidth()-this.padding.left-this.padding.right)));
        this.svgNodes.attr({x:this.padding.left, y: this.getHeight()/2});
        draw2d.SetFigure.prototype.repaint.call(this,attributes);
    },
    setDimension: function( w, h)
    {
        this.clearCache();
        var attr = this.wrappedTextAttr(this.text, w);
        this.cachedMinWidth = Math.max(w,attr.width);
        this.cachedMinHeight= attr.height;
        draw2d.shape.node.Node.prototype.setDimension.call(this,this.cachedMinWidth, this.cachedMinHeight);
        this.fireEvent("change:dimension",{value:{width:this.cachedMinWidth, height:this.cachedMinHeight}});
        return this;
    },
    clearCache: function()
    {
        this._super();
        this.cachedWrappedAttr = null;
        return this;
    },
    getMinWidth: function()
    {
        if (this.shape === null) {
            return 0;
        }
        if(this.cachedMinWidth === null){
            var longestWord = this.text.split(" ").reduce(function(arg1,arg2){ return arg1.length > arg2.length ? arg1 : arg2; });
            var svgText = this.canvas.paper
                                     .text(0, 0, longestWord)
                                     .attr($.extend({},this.calculateTextAttr(),{text:longestWord}));
            this.cachedMinWidth= svgText.getBBox(true).width+this.padding.left+this.padding.right+2*this.getStroke();
            svgText.remove();
        }
        return this.cachedMinWidth;
    },
    wrappedTextAttr: function(text, width) 
    {
    	var words = text.split(" ");
        if(this.canvas ===null || words.length===0){
            return {text:text, width:width, height:20};
        }
        if(this.cachedWrappedAttr===null){
            var abc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            var svgText = this.canvas.paper.text(0, 0, "").attr($.extend({},this.calculateTextAttr(),{text:abc}));
            var letterWidth = svgText.getBBox(true).width / abc.length;
            var s = [words[0]], x=s[0].length*letterWidth;
            var w =null;
            for ( var i = 1; i < words.length; i++) {
            	w= words[i];
                var l = w.length* letterWidth;
                if ((x+l) > width) {
                    s.push("\n");
                    x = l;
                }
                else{
                    s.push(" ");
                    x += l;
                }
                s.push(w);
            }
            svgText.attr({text: s.join("")});
            var bbox = svgText.getBBox(true);
            svgText.remove();
            this.cachedWrappedAttr= {text: s.join(""), width:(Math.max(width,bbox.width)+this.padding.left+this.padding.right), height: (bbox.height+this.padding.top+this.padding.bottom)};
        }
        return this.cachedWrappedAttr;
     },
     getPersistentAttributes: function()
     {
         var memento = this._super();
         return memento;
     },
     setPersistentAttributes: function(memento)
     {
         this._super(memento);
         return this;
     }
});
draw2d.shape.basic.Line = draw2d.Figure.extend({
    NAME : "draw2d.shape.basic.Line",
    DEFAULT_COLOR : new draw2d.util.Color(0,0,0),
    init: function(attr, setter, getter) 
    {
        this.corona = 10;
        this.isGlowing = false;
        this.lineColor = this.DEFAULT_COLOR;
        this.stroke=1;
        this.outlineStroke = 0;
        this.outlineColor = new draw2d.util.Color(null);
        this.outlineVisible = false;
        this.draggedSegment = null;
        this.dasharray = null;
        this.start = new draw2d.geo.Point(30,30);
        this.end   = new draw2d.geo.Point(100,100);
        this.vertices = new draw2d.util.ArrayList();
        this.vertices.add(this.start.clone());
        this.vertices.add(this.end.clone());
        this._super(
             $.extend({
                deleteable:false,
                selectable:true
             },attr),
             $.extend({},{
                    start: this.setStartPosition,
                    startX: this.setStartX,
                    startY: this.setStartY,
                    end: this.setEndPosition,
                    endX: this.setEndX,
                    endY: this.setEndY,
                    vertices: this.setVertices,
                    outlineColor : this.setOutlineColor,
                    outlineStroke : this.setOutlineStroke,
                    color : this.setColor,
                    stroke : this.setStroke,
                    dasharray : this.setDashArray,
                    glow  : this.setGlow
                }, setter),
             $.extend({},{
                start:         this.getStartPosition,
                end:           this.getEndPosition,
                outlineColor:  this.getOutlineColor,
                outlineStroke: this.getOutlineStroke,
                stroke:        this.getStroke,
                color:         this.getColor,
                dasharray:     this.getDashArray,
                vertices:      this.getVertices
            }, getter));
            if(this.editPolicy.getSize()===0) {
                this.installEditPolicy(new draw2d.policy.line.LineSelectionFeedbackPolicy());
            }
    },
   setOutlineColor: function( color)
   {
     this.outlineColor = new draw2d.util.Color(color);
     this.repaint();
     this.fireEvent("change:outlineColor",{value:this.outlineColor});
     return this;
   },
   getOutlineColor: function()
   {
     return this.outlineColor;
   },
   setOutlineStroke: function( w )
   {
     this.outlineStroke=w;
     this.repaint();
     this.fireEvent("change:outlineStroke",{value:this.outlineStroke});
     return this;
   },
   getOutlineStroke: function()
   {
     return this.outlineStroke;
   },
    onDragStart: function(x, y, shiftKey, ctrlKey, isFaked )
    {
        var result = this._super(x,y,shiftKey, ctrlKey);
        if(result===true && isFaked!==true){
            this.draggedSegment =  {index: 0, start:this.start, end: this.end};
        }
        return result;
    },
   onDrag: function( dx, dy, dx2, dy2)
   {
       if(this.command ===null){
           return;
       }
       this.vertices.each(function(i,e){
           e.translate(dx2, dy2);
       });
       this.command.updateVertices(this.vertices.clone());
       this.start.translate(dx2, dy2);
       this.end.translate(dx2, dy2);
       this.svgPathString = null;
       this._super(dx, dy, dx2, dy2);
   },
   onDragEnd: function( x, y, shiftKey, ctrlKey)
   {
       this.isInDragDrop = false;
       this.draggedSegment = null;
       if(this.command===null){
           return;
       }
       var _this = this;
       this.canvas.getCommandStack().execute(this.command);
	   this.command = null;
	   this.isMoving = false;
	   this.editPolicy.each(function(i,e){
    	   if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
    		   e.onDragEnd(_this.canvas, _this, x, y, shiftKey, ctrlKey);
    	   }
	   });
       this.fireEvent("move",{figure:this, dx:0, dy:0});
       this.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
   },
   onClick: function()
   {
   },
   setDashArray: function(dashPattern)
   {
       this.dasharray = dashPattern;
       this.repaint();
       this.fireEvent("change:dashArray",{value:this.dasharray});
       return this;
   },
   getDashArray: function()
   {
       return this.dasharray;
   },
   setCoronaWidth: function( width)
   {
      this.corona = width;
      return this;
   },
   createShapeElement: function()
   {
     var set=  this.canvas.paper.set();
     set.push(this.canvas.paper.path("M"+this.start.x+" "+this.start.y+"L"+this.end.x+" "+this.end.y));
     set.push(this.canvas.paper.path("M"+this.start.x+" "+this.start.y+"L"+this.end.x+" "+this.end.y));
     set.node = set.items[1].node;
     this.outlineVisible = true;
     return set;
   },
   repaint: function(attributes)
   {
       if(this.repaintBlocked===true || this.shape===null){
           return;
       }
       if(typeof attributes === "undefined"){
           attributes = {"stroke":this.lineColor.hash(),
                         "stroke-width":this.stroke,
                         "path":["M",this.start.x,this.start.y,"L",this.end.x,this.end.y].join(" ")};
       }
       else{
           if(typeof attributes.path ==="undefined"){
    		   attributes.path =["M",this.start.x,this.start.y,"L",this.end.x,this.end.y].join(" ");
    	   }
           draw2d.util.JSON.ensureDefault(attributes,"stroke" ,this.lineColor.hash());
           draw2d.util.JSON.ensureDefault(attributes,"stroke-width" ,this.stroke);
       }
       draw2d.util.JSON.ensureDefault(attributes,"stroke-dasharray" ,this.dasharray);
       this._super(attributes);
       if(this.outlineStroke>0){
           this.shape.items[0].attr({"stroke-width":(this.outlineStroke+this.stroke), "stroke":this.outlineColor.hash()});
           if(this.outlineVisible===false)
               this.shape.items[0].show();
           this.outlineVisible = true;
       }
       else if(this.outlineVisible===true){
           this.shape.items[0].attr({"stroke-width":0, "stroke":"none"});
           this.shape.items[0].hide();
       }
   },
   toBack: function(figure )
   {
	   this._super(figure);
	   if(this.outlineVisible===true){
    	   this.shape.items[0].insertBefore(this.shape.items[1]);
	   }
       return this;
   },
   setGlow: function(flag)
   {
	   if(this.isGlowing===flag){
		   return;
	   }
	   if(flag===true){
		   this._lineColor = this.lineColor;
		   this._stroke = this.stroke;
	       this.setColor( new draw2d.util.Color("#3f72bf"));
	       this.setStroke((this.stroke*4)|0);
	   }
	   else{
	       this.setColor(this._lineColor);
	       this.setStroke(this._stroke);
	   }
	   this.isGlowing = flag;
	   return this;
   },
   isResizeable: function()
   {
     return true;
   },
   setStroke: function(w)
   {
     this.stroke=parseFloat(w);
     this.repaint();
     this.fireEvent("change:stroke",{value:this.stroke});
     return this;
   },
   getStroke: function( )
   {
     return this.stroke;
   },
   setColor: function( color)
   {
     this.lineColor = new draw2d.util.Color(color);
     this.repaint();
     this.fireEvent("change:color",{value:this.lineColor});
     return this;
   },
   getColor: function()
   {
     return this.lineColor;
   },
   translate: function(dx , dy )
   {
       this.vertices.each(function(i,e){
           e.translate(dx, dy);
       });
       this.start=this.vertices.first().clone();
       this.end=this.vertices.last().clone();
       var _this = this;
       this.editPolicy.each(function(i,e){
           if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
               e.moved(_this.canvas, _this);
           }
       });
       this.svgPathString = null;
       this.repaint();
       return this;
   },
   getBoundingBox: function()
   {
       var minX = Math.min.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.x;}));
       var minY = Math.min.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.y;}));
       var maxX = Math.max.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.x;}));
       var maxY = Math.max.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.y;}));
       var width = maxX - minX;
       var height= maxY - minY;
       return new draw2d.geo.Rectangle(minX, minY, width, height);
   },
   setStartPosition: function( x, y)
   {
     var pos = new draw2d.geo.Point(x,y);
     if(this.start.equals(pos)){
        return this;
     }
     this.start.setPosition(pos);
     this.vertices.first().setPosition(pos);
     this.repaint();
     var _this = this;
     this.editPolicy.each(function(i,e){
         if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
             e.moved(_this.canvas, _this);
         }
     });
     this.fireEvent("change:start",{value:this.start});
     return this;
  },
  setStartPoint: function(x,y){return this.setStartPosition(x,y);},
  setStartX: function(x)
  {
      this.setStartPoint(x, this.start.y);
  },
  setStartY: function(y)
  {
      this.setStartPoint(this.start.x, y);
  },
  setEndX: function(x)
  {
      this.setEndPoint(x, this.end.y);
  },
  setEndY: function(y)
  {
      this.setEndPoint(this.end.x, y);
  },
   setEndPosition: function(x, y)
   {
     var pos = new draw2d.geo.Point(x,y);
     if(this.end.equals(pos)){
        return this;
     }
     this.end.setPosition(pos);
     this.vertices.last().setPosition(pos);
     this.repaint();
     var _this = this;
     this.editPolicy.each(function(i,e){
         if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
             e.moved(_this.canvas, _this);
         }
     });
     this.fireEvent("change:end",{value:this.end});
     return this;
   },
   setEndPoint: function(x,y){return this.setEndPosition(x,y)},
   getStartX: function()
   {
     return this.start.x;
   },
   getStartY: function()
   {
     return this.start.y;
   },
   getStartPosition: function()
   {
     return this.start.clone();
   },
    getStartPoint: function(){return this.getStartPosition();},
   getEndX: function()
   {
     return this.end.x;
   },
   getEndY: function()
   {
     return this.end.y;
   },
   getEndPosition: function()
   {
     return this.end.clone();
   },
   getEndPoint: function(){return this.getEndPosition();},
    getX: function()
    {
        return this.getBoundingBox().x;
    },
    getY: function()
    {
        return this.getBoundingBox().y;
    },
   getVertex: function( index)
   {
       return this.vertices.get(index);
   },
    setVertex: function(index, x, y)
    {
        if(x instanceof draw2d.geo.Point){
            y = x.y;
            x = x.x;
        }
        var vertex = this.vertices.get(index);
        if (vertex === null || (vertex.x === x && vertex.y === y)) {
            return;
        }
        vertex.x = parseFloat(x);
        vertex.y = parseFloat(y);
        this.start=this.vertices.first().clone();
        this.end=this.vertices.last().clone();
        this.svgPathString = null;
        this.routingRequired=true;
        this.repaint();
        var _this = this;
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
   getVertices: function()
   {
       return this.vertices;
   },
   setVertices: function(vertices)
   {
       var _this = this;
       if($.isArray(vertices)){
           this.vertices= new draw2d.util.ArrayList();
           $.each(vertices,function(index, element){
                _this.vertices.add(new draw2d.geo.Point(element));
           });
       }
       else if (vertices instanceof draw2d.util.ArrayList){
           this.vertices= vertices.clone(true);
       }
       else{
           throw "invalid argument for Line.setVertices";
       }
       if(this.vertices.getSize()>1) {
           this.start = this.vertices.first().clone();
           this.end = this.vertices.last().clone();
       }
       this.svgPathString = null;
       this.repaint();
       if(!this.selectionHandles.isEmpty()){
           this.editPolicy.each(function(i, e) {
               if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                   e.onUnselect(_this.canvas, _this);
                   e.onSelect(_this.canvas, _this);
               }
           });
       }
       this.editPolicy.each(function(i, e) {
           if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
               e.moved(_this.canvas, _this);
           }
       });
       this.fireEvent("change:vertices",{value:this.vertices});
       return this;
   },
   getSegments: function()
   {
       var result = new draw2d.util.ArrayList();
       result.add({start: this.getStartPosition(), end: this.getEndPosition()});
       return result;
   },
   getLength: function()
   {
     return Math.sqrt((this.start.x-this.end.x)*(this.start.x-this.end.x)+(this.start.y-this.end.y)*(this.start.y-this.end.y));
   },
   getAngle: function()
   {
     var length = this.getLength();
     var angle = -(180/Math.PI) *Math.asin((this.start.y-this.end.y)/length);
     if(angle<0)
     {
        if(this.end.x<this.start.x){
          angle = Math.abs(angle) + 180;
        }
        else{
          angle = 360- Math.abs(angle);
        }
     }
     else
     {
        if(this.end.x<this.start.x){
          angle = 180-angle;
        }
     }
     return angle;
   },
   createCommand: function( request)
   {
     if(request.getPolicy() === draw2d.command.CommandType.MOVE){
         if(this.isDraggable()){
             return new draw2d.command.CommandMoveVertices(this);
          }
     }
     if(request.getPolicy() === draw2d.command.CommandType.DELETE){
        if(this.isDeleteable()){
            return new draw2d.command.CommandDelete(this);
        }
     }
       if(request.getPolicy() === draw2d.command.CommandType.MOVE_BASEPOINT){
           if(this.isDraggable()){
               return new draw2d.command.CommandMoveVertex(this);
           }
       }
       return null;
   },
    installEditPolicy: function(policy)
    {
        if(!(policy instanceof draw2d.policy.line.LineSelectionFeedbackPolicy) && policy instanceof draw2d.policy.figure.SelectionFeedbackPolicy){
            return;
        }
        this._super(policy);
    },
   hitTest: function( px, py)
   {
     return draw2d.shape.basic.Line.hit(this.corona+ this.stroke, this.start.x,this.start.y, this.end.x, this.end.y, px,py);
   },
    pointProjection: function( px, py)
    {
        var pt =  new draw2d.geo.Point(px,py);
        var p1=this.getStartPosition();
        var p2=this.getEndPosition();
        return draw2d.geo.Line.pointProjection(p1.x,p1.y,p2.x,p2.y,pt.x,pt.y);
    },
    lerp: function(percentage)
    {
        var p1=this.getStartPosition();
        var p2=this.getEndPosition();
        percentage = Math.min(1,Math.max(0,percentage));
        return new draw2d.geo.Point(p1.x+(p2.x-p1.x)*percentage,p1.y+(p2.y-p1.y)*percentage);
    },
   intersection: function (other)
   {
       var result = new draw2d.util.ArrayList();
       if(other === this){
           return result;
       }
       var segments1= this.getSegments();
       var segments2= other.getSegments();
       segments1.each(function(i, s1){
           segments2.each(function(j, s2){
               var p= draw2d.shape.basic.Line.intersection(s1.start, s1.end, s2.start, s2.end);
               if(p!==null){
                   result.add(p);
               }
           });
       });
       return result;
   },
   getPersistentAttributes: function()
   {
       var memento = this._super();
       delete memento.x;
       delete memento.y;
       delete memento.width;
       delete memento.height;
       memento.stroke = this.stroke;
       memento.color  = this.getColor().hash();
       memento.outlineStroke = this.outlineStroke;
       memento.outlineColor = this.outlineColor.hash();
       if(this.dasharray!==null){
           memento.dasharray = this.dasharray;
       }
       if(this.editPolicy.getSize()>0){
           memento.policy = this.editPolicy.first().NAME;
       }
       memento.vertex = [];
       this.getVertices().each(function(i,e){
           memento.vertex.push({x:e.x, y:e.y});
       });
       return memento;
   },
   setPersistentAttributes: function(memento)
   {
       this._super(memento);
       if(typeof memento.dasharray ==="string"){
           this.dasharray = memento.dasharray;
       }
       if(typeof memento.stroke !=="undefined"){
           this.setStroke(parseFloat(memento.stroke));
       }
       if(typeof memento.color !=="undefined"){
           this.setColor(memento.color);
       }
       if(typeof memento.outlineStroke !=="undefined"){
           this.setOutlineStroke(memento.outlineStroke);
       }
       if(typeof memento.outlineColor !=="undefined"){
           this.setOutlineColor(memento.outlineColor);
       }
       if(typeof memento.policy !=="undefined"){
           try{
               this.installEditPolicy(eval("new "+memento.policy +"()" ));
           }
           catch(exc){
               debug.warn("Unable to install edit policy '"+memento.policy+"' forced by "+this.NAME+".setPersistendAttributes. Using default.");
           }
       }
       if($.isArray(memento.vertex) && memento.vertex.length>1) {
           this.setVertices(memento.vertex);
       }
   }
});
draw2d.shape.basic.Line.intersection = function(a1, a2, b1, b2) {
    var result=null;
    var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if ( u_b != 0 ) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
            result = new draw2d.geo.Point((a1.x + ua * (a2.x - a1.x))|0, (a1.y + ua * (a2.y - a1.y))|0);
            result.justTouching=( 0 == ua || ua == 1 || 0 == ub || ub == 1 );
        }
    }
    return result;
};
draw2d.shape.basic.Line.hit= function( coronaWidth, X1, Y1,  X2,  Y2, px, py)
{
    return draw2d.geo.Line.distance(X1, Y1,  X2,  Y2, px, py)<coronaWidth;
};
draw2d.shape.basic.PolyLine = draw2d.shape.basic.Line.extend({
	NAME : "draw2d.shape.basic.PolyLine",
    init: function( attr, setter, getter )
    {
      this.svgPathString = null;
      this.oldPoint=null;
      this.router = null;
      this.routingRequired = true;
      this.lineSegments = new draw2d.util.ArrayList();
      this.radius = "";
      this._super(
         $.extend(
              {
                  router:new draw2d.layout.connection.VertexRouter()
              },attr),
         $.extend({},{
             router : this.setRouter,
             radius : this.setRadius
        }, setter),
        $.extend({},{
            router: this.getRouter,
            radius: this.getRadius
        }, getter)
      );
    },
     setRadius: function(radius)
     {
        this.radius = radius;
        this.svgPathString =null;
        this.repaint();
        this.fireEvent("change:radius",{value:this.radius});
        return this;
    },
    getRadius: function()
    {
        return this.radius;
    },
    setStartPoint: function( x, y)
    {
        if(this.vertices.getSize()>0){
            this.vertices.first().setPosition(x,y);
        }
        else{
            this.vertices.add(new draw2d.geo.Point(x,y));
        }
		this.start = this.vertices.first().clone();
		    this.calculatePath({startMoved:true, endMoved:false});
        this.repaint();
        var _this = this;
		this.editPolicy.each(function(i, e) {
			if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
				e.moved(_this.canvas, _this);
			}
		});
        this.fireEvent("change:start",{value:this.start});
		return this;
    },
    setEndPoint: function(x, y)
    {
        if(this.vertices.getSize()>1){
            this.vertices.last().setPosition(x,y);
        }
        else{
            this.vertices.add(new draw2d.geo.Point(x,y));
        }
        this.end = this.vertices.last().clone();
        if(this.isInDragDrop===false)
            this.calculatePath({startMoved:false, endMoved:true});
        this.repaint();
        var _this = this;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:end",{value:this.end});
        return this;
    },
    addVertex: function(x, y)
    {
        this.vertices.add(new draw2d.geo.Point(x,y));
        this.start=this.vertices.first().clone();
        this.end=this.vertices.last().clone();
        this.svgPathString = null;
        this.repaint();
        if(!this.selectionHandles.isEmpty()){
            var _this = this;
            this.editPolicy.each(function(i, e) {
                if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
                    e.onUnselect(_this.canvas, _this);
                    e.onSelect(_this.canvas, _this);
                }
            });
        }
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
    insertVertexAt: function(index, x, y)
    {
        var vertex = new draw2d.geo.Point(x,y);
        this.vertices.insertElementAt(vertex,index);
        this.start=this.vertices.first().clone();
        this.end=this.vertices.last().clone();
        this.svgPathString = null;
        this.repaint();
        if(!this.selectionHandles.isEmpty()){
            var _this = this;
	        this.editPolicy.each(function(i, e) {
	            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
	                e.onUnselect(_this.canvas, _this);
	                e.onSelect(_this.canvas, _this);
	            }
	        });
        }
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
    removeVertexAt: function(index)
    {
        var removedPoint = this.vertices.removeElementAt(index);
        this.start=this.vertices.first().clone();
        this.end=this.vertices.last().clone();
        this.svgPathString = null;
        this.repaint();
        if(!this.selectionHandles.isEmpty()){
            var _this = this;
	        this.editPolicy.each(function(i, e) {
	            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
	                e.onUnselect(_this.canvas, _this);
	                e.onSelect(_this.canvas, _this);
	            }
	        });
        }
        this.fireEvent("change:vertices",{value:this.vertices});
        return removedPoint;
    },
    setRouter: function(router)
    {
      if(this.router !==null){
          this.router.onUninstall(this);
      }
      if(typeof router ==="undefined" || router===null){
          this.router = new draw2d.layout.connection.DirectRouter();
      }
      else{
          this.router = router;
      }
      this.router.onInstall(this);
      this.routingRequired =true;
      this.repaint();
      this.fireEvent("change:router",{value:this.router});
      return this;
    },
    getRouter: function()
    {
      return this.router;
    },
    calculatePath: function(routingHints)
    {
        routingHints = routingHints ||{};
        if(this.shape===null){
            return;
        }
        this.svgPathString = null;
        routingHints.oldVertices = this.vertices;
        this.oldPoint=null;
        this.lineSegments = new draw2d.util.ArrayList();
        this.vertices     = new draw2d.util.ArrayList();
        this.router.route(this, routingHints);
        this.routingRequired=false;
        this.fireEvent("routed");
        this.fireEvent("change:route",{});
     },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
          return this;
        }
        if(this.svgPathString===null || this.routingRequired===true){
          this.calculatePath();
        }
        if (typeof attributes === "undefined") {
            attributes = {};
        }
        attributes.path=this.svgPathString;
        draw2d.util.JSON.ensureDefault(attributes,"stroke-linecap" , "round");
        draw2d.util.JSON.ensureDefault(attributes,"stroke-linejoin", "round");
        return this._super( attributes);
    },
    getSegments: function()
    {
        return this.lineSegments;
    },
    addPoint: function( p, y)
    {
      if(typeof y!=="undefined"){
          p = new draw2d.geo.Point(p, y);
      }
      this.vertices.add(p);
      if(this.oldPoint!==null){
        this.lineSegments.add({
            start: this.oldPoint,
            end:p
        });
      }
      this.svgPathString=null;
      this.oldPoint = p;
    },
    onDragStart: function(x, y, shiftKey, ctrlKey, isFaked )
    {
        var result = this._super(x,y,shiftKey, ctrlKey, isFaked);
        if(result===true && isFaked!==true){
            this.draggedSegment =  this.hitSegment(x,y);
        }
        return result;
    },
    getLength: function()
    {
        var result = 0;
        for(var i = 0; i< this.lineSegments.getSize();i++) {
            var segment = this.lineSegments.get(i);
            var p1 = segment.start;
            var p2 = segment.end;
            result += Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
        }
        return result;
    },
    setVertices: function(vertices)
    {
        this.router.verticesSet(this);
        this._super(vertices);
    },
    pointProjection: function( px, py)
    {
        var result=null,
            projection=null,
            p1=null,
            p2 = null,
            segment=null;
        var lastDist = Number.MAX_SAFE_INTEGER;
        var pt = new draw2d.geo.Point(px,py);
        for(var i = 0; i< this.lineSegments.getSize();i++) {
            segment = this.lineSegments.get(i);
            p1 = segment.start;
            p2 = segment.end;
            projection= draw2d.geo.Line.pointProjection(p1.x,p1.y,p2.x,p2.y,pt.x,pt.y);
            if(projection!==null) {
                var dist = projection.distance(pt);
                if (result == null || dist < lastDist) {
                    result = projection;
                    result.index=i;
                    lastDist = dist;
                }
            }
        }
        if (result !== null) {
            var length = 0;
            var segment;
            for(var i = 0; i< result.index;i++) {
                segment = this.lineSegments.get(i);
                length += segment.start.distance(segment.end);
            }
            segment = this.lineSegments.get(result.index);
            p1 = segment.start;
            p2 = segment.end;
            length +=  p1.distance(p2)*draw2d.geo.Line.inverseLerp(p2.x,p2.y,p1.x,p1.y,result.x,result.y);
            result.percentage=(1.0/this.getLength())*length;
        }
        return result;
    },
    lerp: function(percentage)
    {
        var length = this.getLength()*percentage;
        var lastValidLength=length;
        var segment=null,p1=null,p2=null;
        for(var i = 0; i< this.lineSegments.getSize();i++) {
            segment = this.lineSegments.get(i);
            p1 = segment.start;
            p2 = segment.end;
            length = length-p1.distance(p2);
            if(length<=0){
                percentage = 1.0/p1.distance(p2)*lastValidLength;
                return new draw2d.geo.Point(p1.x+(p2.x-p1.x)*percentage,p1.y+(p2.y-p1.y)*percentage)
            }
            lastValidLength=length;
        }
        return p2;
    },
     hitSegment: function( px, py)
     {
       for(var i = 0; i< this.lineSegments.getSize();i++){
          var segment = this.lineSegments.get(i);
          if(draw2d.shape.basic.Line.hit(this.corona+this.stroke, segment.start.x,segment.start.y,segment.end.x, segment.end.y, px,py)){
            return {index: i, start:segment.start, end: segment.end};
          }
       }
       return null;
     },
    hitTest: function( px, py)
    {
      return this.hitSegment(px,py) !== null;
    },
    createCommand: function(request)
    {
      if(request.getPolicy() === draw2d.command.CommandType.DELETE){
        if(this.isDeleteable()===true){
          return new draw2d.command.CommandDelete(this);
        }
      }
      else if(request.getPolicy() === draw2d.command.CommandType.MOVE_VERTEX){
          if(this.isResizeable()===true){
              return new draw2d.command.CommandMoveVertex(this);
            }
      }
      else if(request.getPolicy() === draw2d.command.CommandType.MOVE_VERTICES){
          if(this.isResizeable()===true){
              return new draw2d.command.CommandMoveVertices(this);
            }
      }
      return this._super(request);
    },
    getPersistentAttributes: function()
    {   
        var memento=  $.extend( this._super() ,{
            router : this.router.NAME,
            radius : this.radius
        });
        memento = this.router.getPersistentAttributes(this, memento);
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.router !=="undefined"){
            try{
                this.setRouter(eval("new "+memento.router+"()"));
            }
            catch(exc){
                debug.warn("Unable to install router '"+memento.router+"' forced by "+this.NAME+".setPersistendAttributes. Using default");
            }
        }
        if(typeof memento.radius !=="undefined"){
            this.setRadius(memento.radius);
        }
        this.router.setPersistentAttributes(this, memento);
        if(this.vertices.getSize()>1) {
            this.start = this.vertices.first().clone();
            this.end = this.vertices.last().clone();
        }
    }
});
draw2d.shape.basic.Image = draw2d.shape.node.Node.extend({
    NAME : "draw2d.shape.basic.Image",
    init: function(attr, setter, getter)
    {
        this._super(attr, 
        $.extend({
            path  : this.setPath
        }, setter),
        $.extend({
            path : this.getPath
        }, getter));
    },
    setPath: function(path){
        this.path = path;
        if(this.shape!==null){
            this.shape.attr({src:this.path});
        }
        this.fireEvent("change:path",{value:this.path});
        return this;
    },
    getPath: function()
    {
        return this.path;
    },
    repaint: function(attributes)
    {
        if (this.repaintBlocked===true || this.shape === null){
            return this;
        }
        attributes= attributes || {};
        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();
        attributes.width = this.getWidth();
        attributes.height = this.getHeight();
        attributes.src = this.path;
        $(this.shape.node).css({ display: "inline-block", "width":attributes.width, "height":attributes.height});
        this._super(attributes);
        return this;
    },
    createShapeElement: function()
    {
       return this.canvas.paper.image(this.path,this.getX(),this.getY(),this.getWidth(), this.getHeight());
    },
    getPersistentAttributes: function()
    {
        return $.extend( this._super(),{
            path : this.path
        });
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.path !=="undefined"){
            this.setPath(memento.path);
        }
    }
});
draw2d.shape.basic.Polygon = draw2d.VectorFigure.extend({
    NAME: "draw2d.shape.basic.Polygon",
    init: function(attr, setter, getter )
    {
        this.minX = 0;
        this.minY = 0;
        this.maxX = 0;
        this.maxY = 0;
        this.vertices   = new draw2d.util.ArrayList();
        this._super(attr, setter, getter);
        if(this.vertices.getSize()===0){
            var w= this.width;
            var h= this.height;
            var pos= this.getPosition();
            this.addVertex(new draw2d.geo.Point(0,0) );
            this.addVertex(new draw2d.geo.Point(w,0) );
            this.addVertex(new draw2d.geo.Point(w,h) );
            this.setPosition(pos);
        }
        this.svgPathString=null;
        this.installEditPolicy(new draw2d.policy.figure.VertexSelectionFeedbackPolicy());
    },
     setRadius: function(radius)
     {
        this.svgPathString =null;
        this._super(radius);
        this.fireEvent("change:radius",{value:radius});
        return this;
    },
    createShapeElement: function()
    {
        return this.canvas.paper.path("M0 10L100 100");
    },
    calculatePath: function()
    {
        var radius = this.getRadius();
        var path = [];
        if(radius === 0){
            var length = this.vertices.getSize();
            var p = this.vertices.get(0);
            path.push("M",p.x," ", p.y);
            for(var i=1;i<length;i++){
                  p = this.vertices.get(i);
                  path.push("L", p.x, " ", p.y);
            }
            path.push("Z");
        }
        else{
            length = this.vertices.getSize();
            var start = this.vertices.first();
            var end   = this.vertices.last();
            if(start.equals(end)){
                length = length-1;
                end = this.vertices.get(length-1);
            }
            var begin   = draw2d.geo.Util.insetPoint(start,end, radius);
            path.push("M", begin.x, ",", begin.y);
            for( var i=0 ;i<length;i++){
                  start = this.vertices.get(i);
                  end   = this.vertices.get((i+1)%length);
                  modStart = draw2d.geo.Util.insetPoint(start,end, radius);
                  modEnd   = draw2d.geo.Util.insetPoint(end,start,radius);
                  path.push("Q",start.x,",",start.y," ", modStart.x, ", ", modStart.y);
                  path.push("L", modEnd.x, ",", modEnd.y);
            }
        }
        this.svgPathString = path.join("");
        return this;
    },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }
        if(this.svgPathString===null){
            this.calculatePath();
        }
        attributes= attributes || {};
        draw2d.util.JSON.ensureDefault(attributes,"path" ,this.svgPathString);
        this._super(attributes);
    },
    translate: function(dx , dy )
    {
        var _this = this;
        dx = this.x+dx;
        dy = this.y+dy;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                var newPos = e.adjustPosition(_this,dx,dy);
                dx = newPos.x;
                dy = newPos.y;
            }
        });
        dx = dx-this.x;
        dy = dy-this.y;
        this.vertices.each(function(i,e){
            e.translate(dx,dy);
        });
        this.svgPathString = null;
        this.updateBoundingBox();
        this.repaint();
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("move",{figure:this, dx:dx, dy:dy});
        this.fireEvent("change:x",{value:this.x});
        this.fireEvent("change:y",{value:this.y});
        return this;
    },
    setPosition: function(x, y)
    {
        if (x instanceof draw2d.geo.Point) {
            y = x.y;
            x = x.x;
        }
        this.svgPathString = null;
        var dx = x-this.minX;
        var dy = y-this.minY;
        this.translate(dx,dy);
        this.x = x;
        this.y = y;
        return this;
    },
    setDimension: function(w, h)
    {
        var oldWidth = this.width;
        var oldHeight= this.height;
        this._super(w,h);
        var fracWidth  = (1/oldWidth)*this.width;
        var fracHeight = (1/oldHeight)*this.height;
        var thisX = this.x;
        var thisY = this.y;
        this.vertices.each(function(i,e){
            var diffX = (e.getX()-thisX)*fracWidth;
            var diffY = (e.getY()-thisY)*fracHeight;
            e.setPosition(thisX+diffX,thisY+diffY);
        });
        this.svgPathString = null;
        this.repaint();
        this.fireEvent("change:dimension",{value:{width:this.width, height:this.height}});
        return this;
    },
    getVertices: function()
    {
        return this.vertices;
    },
    getVertex: function( index)
    {
        return this.vertices.get(index);
    },
    resetVertices: function()
    {
        this.vertices = new draw2d.util.ArrayList();
        this.svgPathString = null;
        this.repaint();
        this.updateBoundingBox();
        var _this = this;
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
    },
    setVertex: function(index, x, y)
    {
        var vertex = this.vertices.get(index);
        if (vertex === null || (vertex.x === x && vertex.y === y)) {
            return this;
        }
        vertex.x = parseFloat(x);
        vertex.y = parseFloat(y);
        this.svgPathString = null;
        this.repaint();
        this.updateBoundingBox();
        var _this = this;
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
    addVertex: function( x, y)
    {
        this.vertices.add(new draw2d.geo.Point(x,y));
        this.svgPathString = null;
        this.repaint();
        this.updateBoundingBox();
        var _this = this;
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
    insertVertexAt: function(index, x, y)
    {
        this.vertices.insertElementAt(new draw2d.geo.Point(x,y),index);
        this.svgPathString = null;
        this.repaint();
        this.updateBoundingBox();
        if(!this.selectionHandles.isEmpty()){
            var _this = this;
	        this.editPolicy.each(function(i, e) {
	            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
	                e.onUnselect(_this.canvas, _this);
	                e.onSelect(_this.canvas, _this);
	            }
	        });
        }
        this.fireEvent("change:vertices",{value:this.vertices});
        return this;
    },
    removeVertexAt: function(index)
    {
        if(this.vertices.getSize()<=3){
            return null;
        }
        var vertex = this.vertices.removeElementAt(index);
        this.svgPathString = null;
        this.repaint();
        this.updateBoundingBox();
        if(!this.selectionHandles.isEmpty()){
            var _this = this;
	        this.editPolicy.each(function(i, e) {
	            if (e instanceof draw2d.policy.figure.SelectionFeedbackPolicy) {
	                e.onUnselect(_this.canvas, _this);
	                e.onSelect(_this.canvas, _this);
	            }
	        });
        }
        this.fireEvent("change:vertices",{value:this.vertices});
        return vertex;
    },
    setRotationAngle: function(angle)
    {
        this.rotationAngle = 360%angle;
        var radian =  angle / (180/Math.PI);
        var center = this.getBoundingBox().getCenter();
        var rotate = function(x, y, xm, ym, radian) {
            var cos = Math.cos,
                sin = Math.sin;
                return {x: (x - xm) * cos(radian) - (y - ym) * sin(radian)   + xm,
                        y: (x - xm) * sin(radian) + (y - ym) * cos(radian)   + ym};
        };
        this.vertices.each(function(i,e){
            var rot =rotate(e.x,e.y,center.x,center.y,radian);
            e.setPosition(rot.x,rot.y);
        });
        this.updateBoundingBox();
        var _this = this;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                e.moved(_this.canvas, _this);
            }
        });
        this.repaint();
        this.fireEvent("change:angle",{value:this.rotationAngle});
        return this;
    },
    updateBoundingBox: function()
    {
        if(this.vertices.isEmpty()){
            this.minX = this.x;
            this.minY = this.y;
            this.maxX = this.x+this.width;
            this.maxY = this.y+this.height;
        }
        else{
            this.minX = this.x= Math.min.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.x;}));
            this.minY = this.y= Math.min.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.y;}));
            this.maxX = Math.max.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.x;}));
            this.maxY = Math.max.apply(Math,$.map(this.vertices.asArray(),function(n,i){return n.y;}));
            this.width = this.maxX - this.minX;
            this.height= this.maxY - this.minY;
        }
    },
    createCommand: function(request)
    {
      if(request.getPolicy() === draw2d.command.CommandType.MOVE_VERTEX){
          if(this.isResizeable()===true){
              return new draw2d.command.CommandMoveVertex(this);
            }
      }
      return this._super(request);
    },
    getPersistentAttributes: function()
    {   
        var memento = this._super();
        memento.vertices = [];
        this.vertices.each(function(i,e){
            memento.vertices.push({x:e.x, y:e.y});
        });
        return memento;
    },
    setPersistentAttributes: function( memento)
    {
        this._super(memento);
        if(typeof memento.vertices !=="undefined"){
            this.vertices = new draw2d.util.ArrayList();
            var _this = this;
            $.each(memento.vertices, function(i,point){
                _this.addVertex(point);
            });
        }
    }
});
draw2d.shape.composite.Composite = draw2d.SetFigure.extend({
    NAME : "draw2d.shape.composite.Composite",
    init: function( attr, setter, getter) 
    {
      this._super($.extend({stroke:1,"color": "#f0f0f0"},attr), setter, getter);
    },
    onDoubleClick: function()
    {
    },
    isMemberSelectable: function( figure, selectable)
    {
        return selectable;
    },
    isMemberDraggable: function( figure, draggable)
    {
        return draggable;
    },
    setCanvas: function( canvas ) 
    {
        this._super(canvas);
        if(canvas!==null){
            this.toBack();
        }
    }
});
draw2d.shape.composite.StrongComposite = draw2d.shape.composite.Composite.extend({
    NAME : "draw2d.shape.composite.StrongComposite",
    init: function( attr, setter, getter) 
    {
        this.assignedFigures = new draw2d.util.ArrayList();
        this._super(attr, setter, getter);
    },
    contains: function(containedFigure)
    {
        for(var i= 0,len=this.assignedFigures.getSize(); i<len;i++){
            var child = this.assignedFigures.get(i);
            if(child===containedFigure || child.contains(containedFigure)) {
                return true;
            }
        }
        return this._super(containedFigure);
    },
    assignFigure: function(figure)
    {
        return this;
    },
    unassignFigure: function(figure)
    {
        return this;
    },
    getAssignedFigures: function()
    {
        return this.assignedFigures;
    },
    onDrop: function(dropTarget, x, y, shiftKey, ctrlKey)
    {
    },
    onCatch: function(droppedFigure, x, y, shiftKey, ctrlKey)
    {
    },
     toFront: function(figure)
     {
         this._super(figure);
         var figures = this.getAssignedFigures().clone();
         figures.sort(function(a,b){
             return a.getZOrder()>b.getZOrder()?-1:1;
         });
         var _this = this;
         figures.each(function(i,f){
             f.toFront(_this);
         });
         return this;
     },
     toBack: function(figure)
     {
         this._super(figure);
         var figures = this.getAssignedFigures().clone();
         figures.sort(function(a,b){
             return a.getZOrder()>b.getZOrder()?-1:1;
         });
         var _this = this;
         figures.each(function(i,f){
             f.toBack(_this);
         });
         return this;
     }     
});
draw2d.shape.composite.Group = draw2d.shape.composite.StrongComposite.extend({
    NAME : "draw2d.shape.composite.Group",
    init: function( attr, setter, getter) 
    {
        this._super($.extend({bgColor:null, color:null, resizeable:false},attr), setter, getter);
        this.stickFigures = false;
    },
    isMemberSelectable: function( figure, selectable)
    {
        return false;
    },
    isMemberDraggable: function( figure, draggable)
    {
        return false;
    },
    setPosition: function(x, y)
    {
        var oldX = this.x;
        var oldY = this.y;
        this._super(x,y);
        var dx = this.x-oldX;
        var dy = this.y-oldY;
        if(dx ===0 && dy===0 ){
            return this;
        }
        if(this.stickFigures===false){
            this.assignedFigures.each(function(i,figure){
                figure.translate(dx,dy);
            });
        }
        return this;
    },
    assignFigure: function(figure)
    {
        if(!this.assignedFigures.contains(figure)){
            var _this = this;
            this.stickFigures=true;
            if(this.assignedFigures.isEmpty()===true){
                this.setBoundingBox(figure.getBoundingBox());
            }
            else{
                this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
            }
            this.assignedFigures.add(figure);
            figure.setComposite(this);
            figure.setSelectionAdapter(function(){
                return _this;
            });
            this.stickFigures=false;
        }
        return this;
    },
    unassignFigure: function(figure)
    {
        if(this.assignedFigures.contains(figure)){
            this.stickFigures=true;
            figure.setComposite(null);
            figure.setSelectionAdapter(null);
            this.assignedFigures.remove(figure);
            if(!this.assignedFigures.isEmpty()){
                var box = this.assignedFigures.first().getBoundingBox();
                this.assignedFigures.each(function(i,figure){
                    box.merge(figure.getBoundingBox());
                });
                this.setBoundingBox(box);
            }
            this.stickFigures=false;
        }
        return this;
    },
    createCommand: function( request)
    {
        if(request===null){
            return null;
        }
        if(request.getPolicy() === draw2d.command.CommandType.DELETE)
        {
            if(!this.isDeleteable()){
                return null;
            }
            return new draw2d.command.CommandDeleteGroup(this);
        }
        return this._super(request);
    }
});
draw2d.shape.composite.Jailhouse = draw2d.shape.composite.StrongComposite.extend({
    NAME : "draw2d.shape.composite.Jailhouse",
    init: function( attr, setter, getter) 
    {
      this.policy = new draw2d.policy.figure.RegionEditPolicy(0,0,10,10);
      this._super($.extend({bgColor:"#f0f0f0",color:"#333333"},attr), setter, getter);
      this.stickFigures = false;
    },
    setDimension: function(w, h)
    {
        this._super(w,h);
        this.policy.setBoundingBox(this.getAbsoluteBounds());
    },
    setPosition: function(x, y)
    {
        var oldX = this.x;
        var oldY = this.y;
        this._super(x,y);
        var dx = this.x-oldX;
        var dy = this.y-oldY;
        if(dx ===0 && dy===0 ){
            return this;
        }
        this.policy.setBoundingBox(this.getAbsoluteBounds());
        if(this.stickFigures===false){
            this.assignedFigures.each(function(i,figure){
                figure.translate(dx,dy);
            });
        }
        return this;
    },
    assignFigure: function(figure)
    {
        if(!this.assignedFigures.contains(figure) && figure!==this){
            this.stickFigures=true;
            this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
            this.assignedFigures.add(figure);
            figure.setComposite(this);
            figure.installEditPolicy(this.policy);
            figure.toFront(this);
            this.stickFigures=false;
        }
        return this;
    },
    unassignFigure: function(figure)
    {
        if(this.assignedFigures.contains(figure)){
            this.stickFigures=true;
            figure.setComposite(null);
            figure.uninstallEditPolicy(this.policy);
            this.assignedFigures.remove(figure);
            if(!this.assignedFigures.isEmpty()){
                var box = this.assignedFigures.first().getBoundingBox();
                this.assignedFigures.each(function(i,figure){
                    box.merge(figure.getBoundingBox());
                });
                this.setBoundingBox(box);
            }
            this.stickFigures=false;
        }
        return this;
    },
    onCatch: function(droppedFigure, x, y, shiftKey, ctrlKey)
    {
        this.getCanvas().getCommandStack().execute(new draw2d.command.CommandAssignFigure(droppedFigure, this));
    },
     getMinWidth: function()
     {
         var width=0;
         this.assignedFigures.each(function(i,figure){
             width = Math.max(width,figure.getBoundingBox().getRight());
         });
         return width-this.getAbsoluteX();
     },
     getMinHeight: function()
     {
         var height=0;
         this.assignedFigures.each(function(i,figure){
             height = Math.max(height,figure.getBoundingBox().getBottom());
         });
         return height-this.getAbsoluteY();
     }
});
draw2d.shape.composite.WeakComposite = draw2d.shape.composite.Composite.extend({
    NAME : "draw2d.shape.composite.WeakComposite",
    init: function( attr, setter, getter)
    {
       this._super(attr, setter, getter);
    }
});
draw2d.shape.composite.Raft = draw2d.shape.composite.WeakComposite.extend({
    NAME : "draw2d.shape.composite.Raft",
    init: function( attr, setter, getter)
    {
      this.aboardFigures = new draw2d.util.ArrayList();
      this._super($.extend({bgColor:"#f0f0f0", color:"#1B1B1B"},attr), setter, getter);
    },
    onDragStart: function(x, y, shiftKey, ctrlKey )
    {
        this._super(x,y,shiftKey,ctrlKey);
        this.aboardFigures=new draw2d.util.ArrayList();
        this.getAboardFigures(this.isInDragDrop);
        return true;
    },
    setPosition: function(x, y, dontApplyToChildren)
    {
        var oldX = this.x;
        var oldY = this.y;
        var aboardedFigures = (dontApplyToChildren)?draw2d.util.ArrayList.EMPTY_LIST:this.getAboardFigures(this.isInDragDrop===false);
        this._super(x,y);
        var dx = this.x-oldX;
        var dy = this.y-oldY;
        if(dx ===0 && dy===0 ){
            return this;
        }
        if(this.canvas!==null) {
            aboardedFigures = aboardedFigures.clone();
            this.canvas.getLines().each(function (i, line) {
                if (line instanceof draw2d.Connection) {
                    if (aboardedFigures.contains(line.getSource().getRoot()) && aboardedFigures.contains(line.getTarget().getRoot())) {
                        aboardedFigures.add(line);
                    }
                }
            });
        }
        aboardedFigures.each(function(i,figure){
            figure.translate(dx,dy);
        });
        return this;
    },
    onDrag: function( dx,  dy, dx2, dy2, shiftKey, ctrlKey)
    {
        var _this = this;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                var newPos = e.adjustPosition(_this,_this.ox+dx,_this.oy+dy);
                if(newPos) {
                    dx = newPos.x - _this.ox;
                    dy = newPos.y - _this.oy;
                }
            }
        });
        var newPos = new draw2d.geo.Point(this.ox+dx, this.oy+dy);
        if(this.getCanSnapToHelper()){
            newPos = this.getCanvas().snapToHelper(this, newPos);
        }
        this.setPosition(newPos.x, newPos.y, shiftKey);
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                e.onDrag(_this.canvas, _this);
            }
        });
        this.fireEvent("drag",{dx:dx, dy:dy, dx2:dx2, dy2:dy2, shiftKey:shiftKey, ctrlKey:ctrlKey});
    },
    getAboardFigures: function(recalculate)
    {
        if(recalculate===true && this.canvas !==null){
            var raftBoundingBox = this.getBoundingBox();
            var zIndex = this.getZOrder();
            this.aboardFigures=new draw2d.util.ArrayList();
            var _this = this;
            this.getCanvas().getFigures().each(function(i,figure){
                if(figure !==_this && figure.isSelectable() === true && figure.getBoundingBox().isInside(raftBoundingBox)){
                    if(_this.getNextComposite(figure)!==_this){
                        return;
                    }
                    if(figure.getZOrder()> zIndex){
                        _this.aboardFigures.add(figure);
                    }
                }
            });
        }
        return this.aboardFigures;
    },
    getNextComposite: function(figureToTest)
    {
        var nextComposite = null;
        this.getCanvas().getFigures().each(function(i, figure){
            if(figureToTest === figure){
                return;
            }
            if(figure instanceof draw2d.shape.composite.Composite){
                if(nextComposite!==null && nextComposite.getZOrder() > figure.getZOrder()){
                    return;
                }
                if(figure.getBoundingBox().contains(figureToTest.getBoundingBox())){
                    nextComposite = figure;
                }
            }
        });
        return nextComposite;
    }
});
draw2d.Connection = draw2d.shape.basic.PolyLine.extend({
    NAME : "draw2d.Connection",
    init: function( attr, setter, getter)
    {
      this.sourcePort = null;
      this.targetPort = null;
      this.oldPoint=null;
      this.sourceDecorator = null; 
      this.targetDecorator = null; 
      this.sourceDecoratorNode = null;
      this.targetDecoratorNode=null;
      this.isMoving=false;
      var _this = this;
      this.moveListener = function( figure)
      {
          if(figure===_this.sourcePort){
            _this.setStartPoint(_this.sourcePort.getAbsoluteX(), _this.sourcePort.getAbsoluteY());
          }
          else{
            _this.setEndPoint(_this.targetPort.getAbsoluteX(), _this.targetPort.getAbsoluteY());
          }
       };
      this._super(
          $.extend({
              color: "#129CE4",
              stroke:2,
              radius:3
          },attr) ,
          $.extend({
              sourceDecorator : this.setSourceDecorator,
              targetDecorator : this.setTargetDecorator,
              source : this.setSource,
              target : this.setTarget
         },setter),
          $.extend({
              sourceDecorator: this.getSourceDecorator,
              targetDecorator: this.getTargetDecorator,
              source: this.getSource,
              target: this.getTarget
         },getter)
      );
   },
    disconnect: function()
    {
        if (this.sourcePort!== null) {
            this.sourcePort.off(this.moveListener);
            this.sourcePort.connections.remove(this);
            this.sourcePort.fireEvent("disconnect", {port: this.sourcePort, connection:this});
            if(this.canvas!==null){
                this.canvas.fireEvent("disconnect", {"port": this.sourcePort, "connection":this});
            }
            this.sourcePort.onDisconnect(this);
            this.fireSourcePortRouteEvent();
        }
        if (this.targetPort!== null) {
            this.targetPort.off(this.moveListener);
            this.targetPort.connections.remove(this);
            this.targetPort.fireEvent("disconnect", {port: this.targetPort, connection:this});
            if(this.canvas!==null){
                this.canvas.fireEvent("disconnect", {"port": this.targetPort, "connection":this});
            }
            this.targetPort.onDisconnect(this);
            this.fireTargetPortRouteEvent();
        }
    },
    reconnect: function()
    {
        if (this.sourcePort !== null) {
            this.sourcePort.on("move",this.moveListener);
            this.sourcePort.connections.add(this);
            this.sourcePort.fireEvent("connect", {port: this.sourcePort, connection:this});
            if(this.canvas!==null){
                this.canvas.fireEvent("connect", {"port": this.sourcePort, "connection":this});
            }
            this.sourcePort.onConnect(this);
            this.fireSourcePortRouteEvent();
        }
        if (this.targetPort !== null) {
            this.targetPort.on("move",this.moveListener);
            this.targetPort.connections.add(this);
            this.targetPort.fireEvent("connect", {port: this.targetPort, connection:this});
            if(this.canvas!==null){
                this.canvas.fireEvent("connect", {"port": this.targetPort, "connection":this});
            }
            this.targetPort.onConnect(this);
            this.fireTargetPortRouteEvent();
        }
        this.routingRequired =true;
        this.repaint();
    },
    isResizeable: function()
    {
        return this.isDraggable();
    },
    add: function(child, locator)
    {
        if(!(locator instanceof draw2d.layout.locator.ConnectionLocator)){
           throw "Locator must implement the class draw2d.layout.locator.ConnectionLocator"; 
        }
        this._super(child, locator);
    },
    setSourceDecorator: function( decorator)
    {
      this.sourceDecorator = decorator;
      this.routingRequired = true;
      if(this.sourceDecoratorNode!==null){
          this.sourceDecoratorNode.remove();
          this.sourceDecoratorNode=null;
      }
      this.repaint();
    },
    getSourceDecorator: function()
    {
      return this.sourceDecorator;
    },
    setTargetDecorator: function( decorator)
    {
      this.targetDecorator = decorator;
      this.routingRequired =true;
      if(this.targetDecoratorNode!==null){
          this.targetDecoratorNode.remove();
          this.targetDecoratorNode=null;
      }      
      this.repaint();
    },
    getTargetDecorator: function()
    {
      return this.targetDecorator;
    },
    calculatePath: function(routingHints)
    {
        if(this.sourcePort===null || this.targetPort===null){
            return this;
        }
        this._super(routingHints);
        if(this.shape!==null) {
            var z1 = this.sourcePort.getZOrder();
            var z2 = this.targetPort.getZOrder();
            z1 < z2 ? this.toBack(this.sourcePort) : this.toBack(this.targetPort);
        }
        return this;
    },
    repaint: function(attributes)
    {
      if(this.repaintBlocked===true || this.shape===null){
          return;
      }
      if(this.sourcePort===null || this.targetPort===null){
          return;
      }
      this._super(attributes);
        if(this.targetDecorator!==null && this.targetDecoratorNode===null){
	      	this.targetDecoratorNode= this.targetDecorator.paint(this.getCanvas().paper);
	    }
	    if(this.sourceDecorator!==null && this.sourceDecoratorNode===null){
	      	this.sourceDecoratorNode= this.sourceDecorator.paint(this.getCanvas().paper);
	    }
        var _this = this;
	    if(this.sourceDecoratorNode!==null){
	    	var start = this.getVertices().first();
	  	    this.sourceDecoratorNode.transform("r"+this.getStartAngle()+"," + start.x + "," + start.y +" t" + start.x + "," + start.y);
	  	    this.sourceDecoratorNode.attr({"stroke":"#"+this.lineColor.hex(), opacity:this.alpha});
            this.sourceDecoratorNode.forEach(function(shape){
                shape.node.setAttribute("class",_this.cssClass!==null?_this.cssClass:"");
            });
	    }
        if(this.targetDecoratorNode!==null){
	    	var end = this.getVertices().last();
            this.targetDecoratorNode.transform("r"+this.getEndAngle()+"," + end.x + "," + end.y+" t" + end.x + "," + end.y);
            this.targetDecoratorNode.attr({"stroke":"#"+this.lineColor.hex(), opacity:this.alpha});
            this.targetDecoratorNode.forEach(function(shape){
                shape.node.setAttribute("class",_this.cssClass!==null?_this.cssClass:"");
            });
        }
    },
    getAbsoluteX: function()
    {
        return 0;
    },
    getAbsoluteY: function()
    {
        return 0;
    },
    postProcess: function(postProcessCache)
    {
    	this.router.postProcess(this, this.getCanvas(), postProcessCache);
    },
    onDrag: function( dx, dy, dx2, dy2)
    {
        if(this.command ===null){
            return;
        }
        this.router.onDrag(this, dx, dy, dx2, dy2);
        this.command.updateVertices(this.getVertices().clone());
        var _this = this;
        this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                e.onDrag(_this.canvas, _this);
            }
        });
       this.svgPathString = null;
       this.repaint();
        this.editPolicy.each(function(i, e) {
            if (e instanceof draw2d.policy.figure.DragDropEditPolicy) {
                e.moved(_this.canvas, _this);
            }
        });
        this.fireEvent("move",{figure:this, dx:dx, dy:dx});
    },
    toFront: function(figure)
    {
        this._super(figure);
        if( this.shape!==null) {
            if (this.targetDecoratorNode !== null) {
                this.targetDecoratorNode.insertAfter(this.shape);
            }
            if (this.sourceDecoratorNode !== null) {
                this.sourceDecoratorNode.insertAfter(this.shape);
            }
        }
        return this;
    },
    toBack: function(figure )
    {
        this._super(figure);
        if( this.shape!==null) {
            if (this.targetDecoratorNode !== null) {
                this.targetDecoratorNode.insertAfter(this.shape);
            }
            if (this.sourceDecoratorNode !== null) {
                this.sourceDecoratorNode.insertAfter(this.shape);
            }
        }
        return this;
    },
    getStartPoint: function( refPoint)
     {
      if(this.isMoving===false){
          if(refPoint){
              return this.sourcePort.getConnectionAnchorLocation(refPoint, this);
          }
          return this.sourcePort.getConnectionAnchorLocation(this.targetPort.getConnectionAnchorReferencePoint(this), this);
      }
      return this._super();
     },
     getEndPoint: function(refPoint)
     {
      if(this.isMoving===false){
          if(refPoint){
              return this.targetPort.getConnectionAnchorLocation(refPoint, this);
          }
         return this.targetPort.getConnectionAnchorLocation(this.sourcePort.getConnectionAnchorReferencePoint(this), this);
      }
      return this._super();
     },
    setSource: function( port)
    {
      if(this.sourcePort!==null){
        this.sourcePort.off(this.moveListener);
        this.sourcePort.connections.remove(this);
        this.sourcePort.fireEvent("disconnect", {port: this.sourcePort, connection:this});
        if(this.canvas!==null){
            this.canvas.fireEvent("disconnect", {"port": this.sourcePort, "connection":this});
        }
        this.sourcePort.onDisconnect(this);
      }
      this.sourcePort = port;
      if(this.sourcePort===null){
        return;
      }
      this.routingRequired = true;
      this.fireSourcePortRouteEvent();
      this.sourcePort.connections.add(this);
      this.sourcePort.on("move",this.moveListener);
      if(this.canvas!==null){
          this.canvas.fireEvent("connect", {"port":this.sourcePort, "connection":this});
      }
      this.sourcePort.fireEvent("connect", {port: this.sourcePort, connection:this});
      this.sourcePort.onConnect(this);
      this.setStartPoint(port.getAbsoluteX(), port.getAbsoluteY());
      this.fireEvent("connect", {"port":this.sourcePort, "connection":this});
    },
    getSource: function()
    {
      return this.sourcePort;
    },
    setTarget: function( port)
    {
      if(this.targetPort!==null){
        this.targetPort.off(this.moveListener);
        this.targetPort.connections.remove(this);
        this.targetPort.fireEvent("disconnect", {port: this.targetPort, connection:this});
        if(this.canvas!==null){
            this.canvas.fireEvent("disconnect", {"port": this.targetPort, "connection":this});
        }
        this.targetPort.onDisconnect(this);
      }
      this.targetPort = port;
      if(this.targetPort===null){
        return;
      }
      this.routingRequired = true;
      this.fireTargetPortRouteEvent();
      this.targetPort.connections.add(this);
      this.targetPort.on("move",this.moveListener);
      if(this.canvas!==null){
         this.canvas.fireEvent("connect", {"port": this.targetPort, "connection":this});
      }
      this.targetPort.fireEvent("connect", {port: this.targetPort, connection:this});
      this.targetPort.onConnect(this);
      this.setEndPoint(port.getAbsoluteX(), port.getAbsoluteY());
      this.fireEvent("connect", {"port":this.targetPort, "connection":this});
    },
    getTarget: function()
    {
      return this.targetPort;
    },
    sharingPorts: function(other){
        return this.sourcePort== other.sourcePort ||
               this.sourcePort== other.targetPort ||
               this.targetPort== other.sourcePort ||
               this.targetPort== other.targetPort;
    },
    setCanvas: function( canvas )
    {
       if(this.canvas === canvas){
           return; 
       }
       var notiCanvas = this.canvas==null? canvas: this.canvas;
       this._super(canvas);
        if(canvas !==null &&  draw2d.Connection.DROP_FILTER === null ){
            draw2d.Connection.DROP_FILTER =  canvas.paper.createFilter();
            draw2d.Connection.DROP_FILTER.element.setAttribute("width",  "250%");
            draw2d.Connection.DROP_FILTER.element.setAttribute("height", "250%");
            draw2d.Connection.DROP_FILTER.createShadow(1,1,2, 0.3);
        }
        if(this.sourceDecoratorNode!==null){
           this.sourceDecoratorNode.remove();
           this.sourceDecoratorNode=null;
       }
       if(this.targetDecoratorNode!==null){
           this.targetDecoratorNode.remove();
           this.targetDecoratorNode=null;
       }
       if(this.canvas===null){
           if(this.sourcePort!==null){
               this.sourcePort.off(this.moveListener);
               notiCanvas.fireEvent("disconnect", {"port": this.sourcePort, "connection":this});
               this.sourcePort.onDisconnect(this);
           }
           if(this.targetPort!==null){
               this.targetPort.off(this.moveListener);
               notiCanvas.fireEvent("disconnect", {"port": this.targetPort, "connection":this});
               this.targetPort.onDisconnect(this);
           }
       }
       else{
           this.shape.items[0].filter(draw2d.Connection.DROP_FILTER);
           if(this.sourcePort!==null){
               this.sourcePort.on("move",this.moveListener);
               this.canvas.fireEvent("connect", {"port":this.sourcePort, "connection":this});
               this.sourcePort.onConnect(this);
           }
           if(this.targetPort!==null){
               this.targetPort.on("move",this.moveListener);
               this.canvas.fireEvent("connect", {"port": this.targetPort, "connection":this});
               this.targetPort.onConnect(this);
           }
       }
    },
    getStartAngle: function()
    {
    	if( this.lineSegments.getSize()===0){
    		return 0;
    	}
      var p1 = this.lineSegments.get(0).start;
      var p2 = this.lineSegments.get(0).end;
      if(this.router instanceof draw2d.layout.connection.SplineConnectionRouter)
      {
       p2 = this.lineSegments.get(5).end;
      }
      var length = Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
      var angle = -(180/Math.PI) *Math.asin((p1.y-p2.y)/length);
      if(angle<0)
      {
         if(p2.x<p1.x){
           angle = Math.abs(angle) + 180;
         }
         else{
           angle = 360- Math.abs(angle);
         }
      }
      else
      {
         if(p2.x<p1.x){
           angle = 180-angle;
         }
      }
      return angle;
    },
    getEndAngle: function()
    {
      if (this.lineSegments.getSize() === 0) {
        return 90;
      }
      var p1 = this.lineSegments.get(this.lineSegments.getSize()-1).end;
      var p2 = this.lineSegments.get(this.lineSegments.getSize()-1).start;
      if(this.router instanceof draw2d.layout.connection.SplineConnectionRouter)
      {
       p2 = this.lineSegments.get(this.lineSegments.getSize()-5).end;
      }
      var length = Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
      var angle = -(180/Math.PI) *Math.asin((p1.y-p2.y)/length);
      if(angle<0)
      {
         if(p2.x<p1.x){
           angle = Math.abs(angle) + 180;
         }
         else{
           angle = 360- Math.abs(angle);
         }
      }
      else
      {
         if(p2.x<p1.x){
           angle = 180-angle;
         }
      }
      return angle;
    },
    fireSourcePortRouteEvent: function()
    {
       this.sourcePort.getConnections().each(function(i,conn){
           conn.routingRequired = true;
           conn.repaint();
       });
    },
    fireTargetPortRouteEvent: function()
    {
       this.targetPort.getConnections().each(function(i,conn){
           conn.routingRequired = true;
           conn.repaint();
       });
    },
    createCommand: function( request)
    {
        if(request.getPolicy() === draw2d.command.CommandType.MOVE){
            if(this.isDraggable()){
                return new draw2d.command.CommandMoveVertices(this);
            }
        }
        if(request.getPolicy() === draw2d.command.CommandType.MOVE_BASEPOINT) {
          return new draw2d.command.CommandReconnect(this);
        }
        return this._super(request);
    },
    getPersistentAttributes: function()
    {
        var memento = this._super();
        var parentNode = this.getSource().getParent();
        while(parentNode.getParent()!==null){
        	parentNode = parentNode.getParent();
        }
        memento.source = {
                  node:parentNode.getId(),
                  port: this.getSource().getName()
                };
        var parentNode = this.getTarget().getParent();
        while(parentNode.getParent()!==null){
        	parentNode = parentNode.getParent();
        }
        memento.target = {
                  node:parentNode.getId(),
                  port:this.getTarget().getName()
                };
        if(this.sourceDecorator!==null){
            memento.source.decoration = this.sourceDecorator.NAME;
        }
        if(this.targetDecorator!==null){
            memento.target.decoration = this.targetDecorator.NAME;
        }
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.target.decoration !=="undefined" && memento.target.decoration!=null){
            this.setTargetDecorator( eval("new "+memento.target.decoration));
        }
        if(typeof memento.source.decoration !=="undefined" && memento.source.decoration!=null){
            this.setSourceDecorator( eval("new "+memento.source.decoration));
        }
    }
});
draw2d.Connection.DROP_FILTER = null;
draw2d.VectorFigure = draw2d.shape.node.Node.extend({
    NAME : "draw2d.VectorFigure",
    init: function( attr, setter, getter)
    {
        this.stroke = 1;
        this.radius = 0;
        this.bgColor= new draw2d.util.Color("#ffffff");
        this.color  = new draw2d.util.Color("#303030");
        this.dasharray = null;
        this.strokeBeforeGlow = this.stroke;
        this.glowIsActive = false;
        this._super( attr, 
            $.extend({
                dasharray : this.setDashArray,
                radius : this.setRadius,
                bgColor: this.setBackgroundColor,
                color  : this.setColor,
                stroke : this.setStroke
            }, setter),
            $.extend({
               dasharray: this.getDashArray,
               radius :   this.getRadius,
               bgColor:   this.getBackgroundColor,
               color  :   this.getColor,
               stroke :   this.getStroke
            }, getter)
        );
    },
     setRadius: function(radius)
     {
        this.radius = radius;
        this.repaint();
        this.fireEvent("change:radius",{value:this.radius});
        return this;
    },
    getRadius: function()
    {
        return this.radius;
    },
    setDashArray: function(dashPattern)
    {
        this.dasharray = dashPattern;
        this.repaint();
        this.fireEvent("change:dashArray",{value:this.dasharray});
        return this;
    },
    getDashArray: function()
    {
        return this.dasharray;
    },
    setGlow: function(flag)
    {
        if(flag === this.glowIsActive) {
            return this;
        }
        this.glowIsActive = flag;
        if(flag===true){
            this.strokeBeforeGlow = this.getStroke();
            this.setStroke(this.strokeBeforeGlow*2.5);
        }
        else {
            this.setStroke(this.strokeBeforeGlow);
        }
        return this;
    },
    repaint: function(attributes)
    {
        if (this.repaintBlocked===true || this.shape === null){
            return;
        }
        attributes= attributes || {};
        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();
        if(typeof attributes.stroke==="undefined"){
            if(this.color === null || this.stroke ===0){
                attributes.stroke = "none";
            }
            else {
                attributes.stroke = this.color.hash();
            }
        }
        draw2d.util.JSON.ensureDefault(attributes,"stroke-width" , this.stroke);
        draw2d.util.JSON.ensureDefault(attributes,"fill" ,this.bgColor.hash());
        draw2d.util.JSON.ensureDefault(attributes,"dasharray" , this.dasharray);
        this._super(attributes);
        return this;
    },
    setBackgroundColor: function(color)
    {
        this.bgColor = new draw2d.util.Color(color);
        this.repaint();
        this.fireEvent("change:bgColor",{value:this.bgColor});
        return this;
    },
   getBackgroundColor: function()
   {
     return this.bgColor;
   },
   setStroke: function( w )
   {
     this.stroke=w;
     this.repaint();
     this.fireEvent("change:stroke",{value:this.stroke});
     return this;
   },
   getStroke: function( )
   {
     return this.stroke;
   },
   setColor: function( color)
   {
     this.color = new draw2d.util.Color(color);
     this.repaint();
     this.fireEvent("change:color",{value:this.color});
     return this;
   },
   getColor: function()
   {
     return this.color;
   },
   getPersistentAttributes: function()
   {
       var memento = $.extend(this._super(), {
           bgColor : this.bgColor.hash(),
           color   : this.color.hash(),
           stroke  : this.stroke,
           radius  : this.radius,
           dasharray : this.dasharray
       });
       return memento;
   },
   setPersistentAttributes: function(memento)
   {
       this._super(memento);
       if(typeof memento.radius !=="undefined"){
           this.setRadius(memento.radius);
        }
       if(typeof memento.bgColor !== "undefined"){
           this.setBackgroundColor(memento.bgColor);
       }
       if(typeof memento.color !== "undefined"){
           this.setColor(memento.color);
       }
       if(typeof memento.stroke !== "undefined" ){
           this.setStroke(memento.stroke===null?0:parseFloat(memento.stroke));
       }
       if(typeof memento.dasharray ==="string"){
           this.dasharray = memento.dasharray;
       }
       return this;
   }  
});
draw2d.ResizeHandle = draw2d.shape.basic.Rectangle.extend({
    NAME : "draw2d.ResizeHandle",
    init: function( figure , type) {
      this._super({bgColor:"#FDFDFD", stroke:0.5, color:"#a0a0a0", radius:1});
      this.isResizeHandle=true;
      this.owner = figure;
      this.type = type;
      this.command = null;
      this.commandMove=null;
      this.commandResize=null;
      this.useGradient = true; 
      this.setSelectable(false);
      this.setDimension(); 
    },
    getSnapToDirection: function()
    {
      switch(this.type)
      {
        case 1:
         return draw2d.SnapToHelper.NORTH_WEST;
        case 2:
         return draw2d.SnapToHelper.NORTH;
        case 3:
         return draw2d.SnapToHelper.NORTH_EAST;
        case 4:
         return draw2d.SnapToHelper.EAST;
        case 5:
         return draw2d.SnapToHelper.SOUTH_EAST;
        case 6:
         return draw2d.SnapToHelper.SOUTH;
        case 7:
         return draw2d.SnapToHelper.SOUTH_WEST;
        case 8:
         return draw2d.SnapToHelper.WEST;
        case 9:
         return draw2d.SnapToHelper.NSEW;
        default :
         return draw2d.SnapToHelper.EAST;
      }
    },
    createShapeElement: function()
    {
       var shape= this._super();
       shape.node.setAttribute("type",this.type);
       this.updateCursor(shape);
       return shape;
    },
    updateCursor: function(shape)
    {
        if(shape===null){
            return this;
        }
        if(this.isDraggable()===false){
            shape.attr({"cursor":"default"});
            return this;
        }
        switch(this.type)
        {
          case 1:
              shape.attr({"cursor":"nw-resize"});
              break;
          case 2:
              shape.attr({"cursor":"n-resize"});
              break;
          case 3:
              shape.attr({"cursor":"ne-resize"});
              break;
          case 4:
              shape.attr({"cursor":"e-resize"});
              break;
          case 5:
              shape.attr({"cursor":"se-resize"});
              break;
          case 6:
              shape.attr({"cursor":"s-resize"});
              break;
          case 7:
              shape.attr({"cursor":"sw-resize"});
              break;
          case 8:
              shape.attr({"cursor":"w-resize"});
              break;
          default:
              shape.attr({"cursor":"move"});
              break;
        }
        return this;
    },
    setDraggable: function(flag)
    {
      this._super(flag);
      this.updateCursor(this.shape);
      return this;
    },
    onDragStart: function(x, y, shiftKey, ctrlKey)
    {
        if (!this.isDraggable()) {
            return false;
        }
        this.ox = this.getAbsoluteX();
        this.oy = this.getAbsoluteY();
        this.commandMove = this.owner.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE));
        this.commandResize = this.owner.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.RESIZE));
        return true;
    },
    onDrag: function(dx, dy, dx2, dy2)
    {
        if (this.isDraggable() === false) {
            return;
        }
        var oldX = this.getAbsoluteX();
        var oldY = this.getAbsoluteY();
        this._super(dx, dy, dx2, dy2);
        var diffX = this.getAbsoluteX() - oldX;
        var diffY = this.getAbsoluteY() - oldY;
        var obj = this.owner;
        var objPosX   = obj.getAbsoluteX();
        var objPosY   = obj.getAbsoluteY();
        var objWidth  = obj.getWidth();
        var objHeight = obj.getHeight();
        var newX=null;
        var newY=null;
        var corrPos=null;
        switch(this.type) {
        case 1:
            obj.setDimension(objWidth - diffX, objHeight - diffY);
            newX=objPosX + (objWidth - obj.getWidth());
            newY=objPosY + (objHeight - obj.getHeight());
            obj.setPosition(newX, newY);
            break;
        case 2:
            obj.setDimension(objWidth, objHeight - diffY);
            newX= objPosX;
            newY= objPosY + (objHeight - obj.getHeight());
            obj.setPosition(newX, newY);
            break;
        case 3:
            obj.setDimension(objWidth + diffX, objHeight - diffY);
            newX= objPosX;
            newY= objPosY + (objHeight - obj.getHeight());
            obj.setPosition(newX, newY);
            break;
        case 4:
            obj.setDimension(objWidth + diffX, objHeight);
            break;
        case 5:
            obj.setDimension(objWidth + diffX, objHeight + diffY);
            break;
        case 6:
            obj.setDimension(objWidth, objHeight + diffY);
            break;
        case 7:
            obj.setDimension(objWidth - diffX, objHeight + diffY);
            newX=objPosX + (objWidth - obj.getWidth());
            newY=objPosY;
            obj.setPosition(newX, newY);
            break;
        case 8:
            obj.setDimension(objWidth - diffX, objHeight);
            newX = objPosX + (objWidth - obj.getWidth());
            newY = objPosY;
            obj.setPosition(newX, newY);
            break;
        }
        if(newX!==null){
            corrPos = obj.getPosition();
            if(corrPos.x!==newX || corrPos.y!==newY){
                obj.setDimension(obj.getWidth() - (corrPos.x-newX), obj.getHeight()- (corrPos.y-newY));
            }
        }
    },
    onDragEnd: function(x, y, shiftKey, ctrlKey)
    {
        if (!this.isDraggable()) {
            return;
        }
        if (this.commandMove !== null) {
            this.commandMove.setPosition(this.owner.getX(), this.owner.getY());
            this.canvas.getCommandStack().execute(this.commandMove);
            this.commandMove = null;
        }
        if (this.commandResize !== null) {
            this.commandResize.setDimension(this.owner.getWidth(), this.owner.getHeight());
            this.canvas.getCommandStack().execute(this.commandResize);
            this.commandResize = null;
        }
    },
    setPosition: function(x, y) {
        if (x instanceof draw2d.geo.Point) {
            this.x = x.x;
            this.y = x.y;
        }
        else {
            this.x = x;
            this.y = y;
        }
        if (this.repaintBlocked===true || this.shape === null){
            return this;
        }
        this.shape.attr({x:this.x, y:this.y});
    },
    setDimension: function(width, height)
    {
    	if(typeof height !=="undefined"){
    		this._super(width, height);
    	}
    	else{
	        if(draw2d.isTouchDevice){
	        	this._super(15,15);
	        }
	        else{
	        	this._super(8,8);
	        }
    	}
        var offset= this.getWidth();
        var offset2 = offset/2;
        switch(this.type)
        {
          case 1:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset,offset));
            break;
          case 2:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset2,offset));
            break;
          case 3:
            this.setSnapToGridAnchor(new draw2d.geo.Point(0,offset));
            break;
          case 4:
            this.setSnapToGridAnchor(new draw2d.geo.Point(0,offset2));
            break;
          case 5:
            this.setSnapToGridAnchor(new draw2d.geo.Point(0,0));
            break;
          case 6:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset2,0));
            break;
          case 7:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset,0));
            break;
          case 8:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset,offset2));
            break;
          case 9:
            this.setSnapToGridAnchor(new draw2d.geo.Point(offset2,offset2));
            break;
        }
        return this;
    },
    show: function(canvas)
    {
      this.setCanvas(canvas);
      if(canvas !==null &&  draw2d.ResizeHandle.DROP_FILTER === null ){
          draw2d.ResizeHandle.DROP_FILTER =  canvas.paper.createFilter();
          draw2d.ResizeHandle.DROP_FILTER.element.setAttribute("width",  "250%");
          draw2d.ResizeHandle.DROP_FILTER.element.setAttribute("height", "250%");
          draw2d.ResizeHandle.DROP_FILTER.createShadow(1,1,2, 0.3);
      }
      this.shape.filter(draw2d.ResizeHandle.DROP_FILTER);
      this.canvas.resizeHandles.add(this);
      this.shape.insertAfter(this.owner.getShapeElement());
      this.repaint();
      return this;
    },
    hide: function()
    {
      if(this.shape===null){
        return;
      }
      this.canvas.resizeHandles.remove(this);
      this.setCanvas(null);
      return this;
    },
     setBackgroundColor: function(color)
     {
         color = new draw2d.util.Color(color);
         this.bgGradient= "90-"+color.darker(0.2).hash()+"-"+color.hash();
         this._super(color);
         return this;
     },
     repaint: function(attributes)
     {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }
        attributes= attributes || {};
        if(this.bgColor.hash()==="none"){
            attributes.fill="none";
        }
        else if(this.getAlpha()<0.9 || this.useGradient===false){
            attributes.fill=this.bgColor.hash();
        }
        else{
            attributes.fill=this.bgGradient;
        }
        this._super(attributes);
    },
    supportsSnapToHelper: function()
    {
    	return true;
    },
    onKeyDown: function(keyCode, ctrl)
    {
      this.canvas.onKeyDown(keyCode,ctrl);
    },
    fireEvent: function(event, args)
    {
    }
});
draw2d.ResizeHandle.DROP_FILTER = null;
draw2d.shape.basic.LineResizeHandle = draw2d.shape.basic.Circle.extend({
    NAME : "draw2d.shape.basic.LineResizeHandle",
    init: function(figure, index)
    {
        this._super();
        this.owner = figure;
        this.index = index;
        this.isResizeHandle=true;
        if (draw2d.isTouchDevice) {
            this.setDimension(20, 20);
        }
        else {
            this.setDimension(10, 10);
        }
        this.setBackgroundColor("#5bcaff");
        this.setStroke(1);
        this.setSelectable(false);
        this.currentTarget = null;
    },
    createShapeElement: function()
    {
        var shape= this._super();
        shape.attr({"cursor":"move"});
        return shape;
     },
      setBackgroundColor: function(color)
      {
          color = new draw2d.util.Color(color);
          this.bgGradient= "r(.4,.3)"+color.hash()+"-"+color.darker(0.1).hash()+":60-"+color.darker(0.2).hash();
          this._super(color);
          this.setColor(color.darker(0.3));
          return this;
      },
    getRelatedPort: function()
    {
      return null;
    },
    getOppositePort: function()
    {
      return null;
    },
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }
        attributes= attributes || {};
        if(this.bgColor.hash()==="none"){
            attributes.fill=this.bgColor.hash();
        }
        else if(this.getAlpha()<0.9){
            attributes.fill=this.bgColor.hash();
        }
        else{
            attributes.fill=this.bgGradient;
        }
        this._super(attributes);
    },
    onDragStart: function(x, y, shiftKey, ctrlKey)
    {
        this.command = this.owner.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_BASEPOINT));
        if(this.command !==null){
            this.command.setIndex(this.index);
        }
        this.setAlpha(0.2);
        this.shape.attr({"cursor":"crosshair"});
        this.fireEvent("dragstart",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        return true;
    },
    onDrag: function(dx, dy, dx2, dy2)
    {
        this.setPosition(this.x + dx2, this.y + dy2);
        var port = this.getOppositePort();
        var target = port!==null?port.getCanvas().getBestFigure(this.getX(), this.getY(), [this, this.owner]): null;
        if (target !== this.currentTarget) {
            if (this.currentTarget !== null) {
                this.currentTarget.onDragLeave(port);
                this.currentTarget.setGlow(false);
                this.currentTarget.fireEvent("dragLeave", {draggingElement:port});
            }
            if (target !== null) {
                this.currentTarget = target.delegateTarget(port);
                if(this.currentTarget!==null){
                    this.currentTarget.setGlow(true);
                    this.currentTarget.onDragEnter(port); 
                    this.currentTarget.fireEvent("dragEnter", {draggingElement:port});
                }
            }
        }
        return true;
    },
    onDragEnd: function( x, y, shiftKey, ctrlKey)
    {
        if (!this.isDraggable()) {
            return false;
        }
        this.shape.attr({"cursor":"move"});
        var port = this.getOppositePort();
        if (port !== null) {
            if (this.currentTarget !== null) {
                this.onDrop(this.currentTarget, x, y, shiftKey, ctrlKey);
                this.currentTarget.onDragLeave(port);
                this.currentTarget.setGlow(false);
                this.currentTarget.fireEvent("dragLeave", {draggingElement:port});
                this.currentTarget.onCatch(this, x, y, shiftKey, ctrlKey);
                this.currentTarget = null;
            }
        }
        this.owner.isMoving=false;
        if (this.owner instanceof draw2d.Connection) {
            if (this.command !== null) {
                this.command.cancel();
            }
        }
        else {
            if (this.command !== null) {
                this.getCanvas().getCommandStack().execute(this.command);
            }
        }
        this.command = null;
        this.setAlpha(1);
        this.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
    },
    relocate: function()
    {
        return this;
    },
    supportsSnapToHelper: function()
    {
      if(this.owner instanceof draw2d.Connection){
        return false;
      }
      return true;
    },
    show: function(canvas, x, y)
    {
      this.setCanvas(canvas);
      this.shape.toFront();
      this.canvas.resizeHandles.add(this);
    },
    hide: function()
    {
      if(this.shape===null){
        return;
      }
      this.canvas.resizeHandles.remove(this);
      this.setCanvas(null);
    },
    onKeyDown: function(keyCode, ctrl)
    {
      this.canvas.onKeyDown(keyCode,ctrl);
    }
});
draw2d.shape.basic.LineStartResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME : "draw2d.shape.basic.LineStartResizeHandle",
    init: function( figure)
    {
        this._super(figure, 0);
    },
    getRelatedPort: function()
    {
    	if(this.owner instanceof draw2d.Connection)
    		return this.owner.getSource();
    	return null;
    },
    getOppositePort: function()
    {
    	if(this.owner instanceof draw2d.Connection)
         return this.owner.getTarget();
    	return null;
    },
    onDrag: function( dx, dy, dx2, dy2)
    {
      this._super(dx, dy, dx2, dy2);
      var objPos = this.owner.getStartPoint();
      objPos.translate(dx2, dy2);
      if(this.command!==null) {
          this.command.updatePosition(objPos);
      }
      this.owner.setStartPoint(objPos);
      this.owner.isMoving = true;
      return true;
    },
    onDrop: function( dropTarget, x, y, shiftKey, ctrlKey)
    {
    	this.owner.isMoving=false;
      if(this.owner instanceof draw2d.Connection && this.command !==null) {
         this.command.setNewPorts(dropTarget, this.owner.getTarget());
         this.getCanvas().getCommandStack().execute(this.command);
      }
      this.command = null;
    },
    relocate: function()
    {
        var resizeWidthHalf = this.getWidth()/2;
        var resizeHeightHalf= this.getHeight()/2;
        var anchor   = this.owner.getStartPoint();
        this.setPosition(anchor.x-resizeWidthHalf,anchor.y-resizeHeightHalf);
        return this;
    }
});
draw2d.shape.basic.LineEndResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME : "draw2d.shape.basic.LineEndResizeHandle",
    init: function( figure)
    {
        this._super(figure, figure.getVertices().getSize()-1);
    },
    getRelatedPort: function()
    {
    	if(this.owner instanceof draw2d.Connection){
         return this.owner.getTarget();
    	}
    	return null;
    },
    getOppositePort: function()
    {
    	if(this.owner instanceof draw2d.Connection) {
         return this.owner.getSource();
    	}
    	return null;
    },
    onDrag: function( dx, dy, dx2, dy2)
    {
        this._super(dx,dy, dx2, dy2);
        var objPos = this.owner.getEndPoint().clone();
        objPos.translate(dx2, dy2);
        if(this.command!==null) {
            this.command.updatePosition(objPos);
        }
        this.owner.setEndPoint(objPos);
        this.owner.isMoving = true;
        return true;
    },
    onDrop: function( dropTarget, x, y, shiftKey, ctrlKey)
    {
    	this.owner.isMoving=false;
      if(this.owner instanceof draw2d.Connection && this.command !==null){
         this.command.setNewPorts(this.owner.getSource(),dropTarget);
         this.getCanvas().getCommandStack().execute(this.command);
      }
      this.command = null;
    },
    relocate: function(){
        var resizeWidthHalf = this.getWidth()/2;
        var resizeHeightHalf= this.getHeight()/2;
        var anchor   = this.owner.getEndPoint();
        this.setPosition(anchor.x-resizeWidthHalf,anchor.y-resizeHeightHalf);
        return this;
    }    
});
draw2d.shape.basic.VertexResizeHandle = draw2d.ResizeHandle.extend({
    NAME : "draw2d.shape.basic.VertexResizeHandle",
    SNAP_THRESHOLD   : 3,
    LINE_COLOR       : "#1387E6",
    FADEOUT_DURATION : 300,
    init: function( figure, index)
    {
        this._super(figure);
        this.index = index;
        this.isDead = false;
    },
    onDoubleClick: function()
    {
       	var cmd  = new draw2d.command.CommandRemoveVertex(this.owner, this.index );
        this.getCanvas().getCommandStack().execute(cmd);
        this.isDead = true;
    },
    onDragStart: function(x,y, shiftKey, ctrlKey)
    {
    	if(this.isDead===true){
    		return;
    	}
        this._super();
        this.command = this.getCanvas().getPrimarySelection().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.MOVE_VERTEX));
        if(this.command!=null){
            this.command.setIndex(this.index);
            this.setAlpha(0.2);
            this.shape.attr({"cursor":"crosshair"});
        }
        this.vertex = this.owner.getVertex(this.index).clone();
        this.fireEvent("dragstart",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        return true;
    },
    onDrag: function(dx, dy, dx2, dy2)
    {
        if (this.isDead===true || this.command == null) {
            return;
        }
        this.setPosition(this.x+dx2, this.y+dy2);
        this.vertex.translate(dx2, dy2);
        var newPos = this.vertex.clone();
        if(this.getCanSnapToHelper()){
            newPos = this.getCanvas().snapToHelper(this, newPos);
        }
        this.owner.setVertex(this.index, newPos.x, newPos.y);
        this.command.updatePosition(this.vertex.x, this.vertex.y);
    },
    onDragEnd: function( x, y, shiftKey, ctrlKey)
    {
        if (this.isDead===true || this.command===null) {
            return;
        }
        this.shape.attr({"cursor":"move"});
        var stack = this.getCanvas().getCommandStack();
        stack.startTransaction();
        try{
	        stack.execute(this.command);
	        this.command = null;
	        var angle = this.getEnclosingAngle();
	        if(angle>178){
	           	var cmd  = new draw2d.command.CommandRemoveVertex(this.owner, this.index );
	            stack.execute(cmd);
	        }
        }
        finally{
        	stack.commitTransaction();
        }
        this.setAlpha(1);
        this.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
    },
    relocate: function()
    {
        var resizeWidthHalf = this.getWidth()/2;
        var resizeHeightHalf= this.getHeight()/2;
        var anchor = this.owner.getVertex(this.index);
  		this.setPosition(anchor.x-resizeWidthHalf,anchor.y-resizeHeightHalf);
    },
    getEnclosingAngle: function()
    {
        var points = this.owner.getVertices();
        var trans  = this.vertex.getScaled(-1);
        var size = points.getSize();
        var left   = points.get((this.index-1 +size)%size).translated(trans); 
        var right  = points.get((this.index+1)%size).translated(trans);       
        var dot = left.dot(right);
        var acos = Math.acos(dot/(left.length() * right.length()));
        return acos*180/Math.PI;
    }
});
draw2d.shape.basic.GhostVertexResizeHandle = draw2d.shape.basic.LineResizeHandle.extend({
    NAME : "draw2d.shape.basic.GhostVertexResizeHandle",
    init: function( figure, precursorIndex)
    {
        this.maxOpacity = 0.35;
        this._super(figure);
        this.precursorIndex = precursorIndex;
        this.setAlpha(this.maxOpacity);
    },
    createShapeElement: function()
    {
        var shape= this._super();
        shape.attr({"cursor":"pointer"});
        return shape;
     },
     setAlpha: function( percent)
     {
       percent = Math.min(this.maxOpacity,Math.max(0,parseFloat(percent)));
       this._super(percent);
       return this;
     },
    onClick: function()
    {
    	var cmd  = new draw2d.command.CommandAddVertex(this.owner, this.precursorIndex+1,this.getAbsoluteX() + this.getWidth()/2, this.getAbsoluteY() + this.getHeight()/2 );
        this.getCanvas().getCommandStack().execute(cmd);
    },
    onDragStart: function(x, y, shiftKey, ctrlKey)
    {
        return true;
    },
    onDrag: function(dx, dy, dx2, dy2)
    {
        return true;
    },
    onDragEnd: function(x, y, shiftKey, ctrlKey)
    {
        this.fireEvent("dragend",{x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        return true;
    },
    relocate: function()
    {
        var p1 = this.owner.getVertices().get(this.precursorIndex);
        var p2 = this.owner.getVertices().get(this.precursorIndex+1);
        var x = ((p2.x - p1.x) / 2 + p1.x - this.getWidth()/2);
        var y = ((p2.y - p1.y) / 2 + p1.y - this.getHeight()/2);
  		this.setPosition(x,y);
    }    
});
draw2d.Port = draw2d.shape.basic.Circle.extend({
    NAME : "draw2d.Port",
    DEFAULT_BORDER_COLOR:new draw2d.util.Color("#1B1B1B"),
    MAX_SAFE_INTEGER : 9007199254740991,
    init: function( attr, setter, getter)
    {
        var _this = this;
        this.locator = null;
        this.lighterBgColor =null;
        this.name = null;
        this._super($.extend({
                bgColor: "#4f6870",
                stroke:1,
                diameter:draw2d.isTouchDevice?25:10,
                color:"#1B1B1B",
                selectable:false
            },attr),
            setter,
            getter);
        this.ox = this.x;
        this.oy = this.y;
        this.coronaWidth = 5; 
        this.corona = null; 
        this.useGradient = true;
        this.preferredConnectionDirection = null;
        this.connections = new draw2d.util.ArrayList();
        this.moveListener = function( emitter, event){
            _this.repaint();
            _this.fireEvent("move",{figure:_this, dx:0, dy:0});
        };
        this.connectionAnchor = new draw2d.layout.anchor.ConnectionAnchor(this);
        this.value = null; 
        this.maxFanOut = this.MAX_SAFE_INTEGER;
        this.setCanSnapToHelper(false);
        this.editPolicy.each(function(i, policy){
            _this.uninstallEditPolicy(policy);
        });
        this.installEditPolicy(new draw2d.policy.port.IntrusivePortsFeedbackPolicy());
        this.portSelectionAdapter = function(){
            return _this;
        };
    },
    getSelectionAdapter: function()
    {
        return this.portSelectionAdapter;
    },
    setMaxFanOut: function(count)
    {
        this.maxFanOut = Math.max(1,count);
        this.fireEvent("change:maxFanOut", {value:this.maxFanOut});
        return this;
    },
    getMaxFanOut: function()
    {
        return this.maxFanOut;
    },
    setConnectionAnchor: function( anchor)
    {
        if(typeof anchor ==="undefined" || anchor===null){
    		anchor = new draw2d.layout.anchor.ConnectionAnchor( );
    	}
        this.connectionAnchor = anchor;
        this.connectionAnchor.setOwner(this);
        this.fireEvent("move",{figure:this, dx:0, dy:0});
        return this;
    },
    getConnectionAnchorLocation: function(referencePoint, inquiringConnection)
    {
    	return this.connectionAnchor.getLocation(referencePoint, inquiringConnection);
    },
    getConnectionAnchorReferencePoint: function(inquiringConnection)
    {
    	return this.connectionAnchor.getReferencePoint(inquiringConnection);
    },
    getConnectionDirection: function( peerPort)
    {
        if(typeof this.preferredConnectionDirection==="undefined" || this.preferredConnectionDirection===null){
            return this.getParent().getBoundingBox().getDirection(this.getAbsolutePosition());
        }
        return this.preferredConnectionDirection;
    },
    setConnectionDirection: function(direction)
    {
        this.preferredConnectionDirection = direction;
        this.fireEvent("move",{figure:this, dx:0, dy:0});
        return this;
    },
    setLocator: function(locator)
    {
        this.locator = locator;
        return this;
    },
    getLocator: function()
    {
        return this.locator;
    },
     setBackgroundColor: function(color)
     {
        this._super(color);
        this.lighterBgColor=this.bgColor.lighter(0.3).hash();
        return this;
     },
    setValue: function(value)
    {
        this.value = value;
        if(this.getParent()!==null){
           this.getParent().onPortValueChanged(this);
        }
        this.fireEvent("change:value", {value:this.value});
        return this;
    },
    getValue: function()
    {
        return this.value;
    },
     repaint: function(attributes)
     {
         if(this.repaintBlocked===true || this.shape===null){
             return;
         }
         attributes= attributes || {};
         attributes.cx = this.getAbsoluteX();
         attributes.cy = this.getAbsoluteY();
         attributes.rx = this.width/2;
         attributes.ry = attributes.rx;
         attributes.cursor = "move";
         if(this.getAlpha()<0.9 || this.useGradient===false){
             attributes.fill=this.bgColor.hash();
         }
         else{
             attributes.fill = ["90",this.bgColor.hash(),this.lighterBgColor].join("-");
         }
         this._super(attributes);
     },
    onMouseEnter: function()
    {
        this._oldstroke = this.getStroke();
        this.setStroke(2);
    },
    onMouseLeave: function()
    {
        this.setStroke(this._oldstroke);
    },
    getConnections: function()
    {
      return this.connections;
    },
    setParent: function(parent)
    {
        if(this.parent!==null){
            this.parent.off(this.moveListener);
        }
        this._super(parent);
        if(this.parent!==null) {
          this.parent.on("move",this.moveListener);
        }
    },
    getCoronaWidth: function()
    {
       return this.coronaWidth;
    },
    setCoronaWidth: function( width)
    {
       this.coronaWidth = width;
    },
    onDragStart: function(x, y, shiftKey, ctrlKey)
    {
        if(this.getConnections().getSize() >= this.maxFanOut){
            return false;
        }
        var _this = this;
        this.ox = this.x;
        this.oy = this.y;
         var canStartDrag = true;
         this.editPolicy.each(function(i,e){
            if(e instanceof draw2d.policy.figure.DragDropEditPolicy){
                canStartDrag = canStartDrag && e.onDragStart(_this.canvas, _this, x, y, shiftKey, ctrlKey);
            }
         });
         return canStartDrag;
    },
    onDrag: function(dx, dy, dx2, dy2)
    {
        this._super( dx, dy);
    },
    onDragEnd: function(x, y, shiftKey, ctrlKey)
    {
      this.setAlpha(1.0);
      this.setPosition(this.ox,this.oy);
    },
    onDrop: function(dropTarget, x, y, shiftKey, ctrlKey)
    {
    },
    onConnect: function(connection)
    {
    },
    onDisconnect: function(connection)
    {
    },
    getName: function()
    {
      return this.name;
    },
    setName: function( name)
    {
      this.name=name;
    },
    hitTest: function ( iX , iY, corona)
    {
        var x   = this.getAbsoluteX()-this.coronaWidth-this.getWidth()/2;
        var y   = this.getAbsoluteY()-this.coronaWidth-this.getHeight()/2;
        var iX2 = x + this.getWidth()  + (this.coronaWidth*2);
        var iY2 = y + this.getHeight() + (this.coronaWidth*2);
        return (iX >= x && iX <= iX2 && iY >= y && iY <= iY2);
    },
    setGlow: function( flag)
    {
      if(flag===true && this.corona===null)
      {
    	  this.corona = new draw2d.Corona();
    	  this.corona.setDimension(this.getWidth()+(this.getCoronaWidth()*2),this.getWidth()+(this.getCoronaWidth()*2));
          this.corona.setPosition(this.getAbsoluteX()-this.getCoronaWidth()-this.getWidth()/2, this.getAbsoluteY()-this.getCoronaWidth()-this.getHeight()/2);
          this.corona.setCanvas(this.getCanvas());
          this.corona.getShapeElement();
          this.corona.repaint();
      }
      else if(flag===false && this.corona!==null)
      {
    	  this.corona.setCanvas(null);
    	  this.corona = null;
      }
      return this;
    },
    createCommand: function(request)
    {
       if(request.getPolicy() === draw2d.command.CommandType.MOVE) {
         if(!this.isDraggable()){
            return null;
         }
         return new draw2d.command.CommandMovePort(this);
       }
       return null;
    },
    fireEvent: function(event, args)
    {
        if (this.isInDragDrop === true && event!=="drag") {
            return;
        }
        this._super(event,args);
    },
    getPersistentAttributes: function()
    {
       var memento= this._super();
        memento.maxFanOut = this.maxFanOut;
        memento.name      = this.name;
        delete memento.x;
        delete memento.y;
        delete memento.ports;
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.maxFanOut !== "undefined"){
            if(typeof memento.maxFanOut ==="number"){
                this.maxFanOut = memento.maxFanOut;
            }
            else {
                this.maxFanOut = Math.max(1, parseInt(memento.maxFanOut));
            }
        }
        if(typeof memento.name !== "undefined") {
            this.setName( memento.name);
        }
        return this;
    }
});
draw2d.Corona = draw2d.shape.basic.Circle.extend({
    init: function()
    {
        this._super();
        this.setAlpha(0.3);
        this.setBackgroundColor(new  draw2d.util.Color(178,225,255));
        this.setColor(new draw2d.util.Color(102,182,252));
    },
    setAlpha: function(percent)
    {
        this._super(Math.min(0.3, percent));
        this.setDeleteable(false);
        this.setDraggable(false);
        this.setResizeable(false);
        this.setSelectable(false);
        return this;
    }
});
draw2d.InputPort = draw2d.Port.extend({
    NAME : "draw2d.InputPort",
    init: function( attr, setter, getter)
    {
        this._super( attr, setter, getter);
        this.locator=new draw2d.layout.locator.InputPortLocator();
    },
    createCommand: function( request)
    {
       if(request.getPolicy() === draw2d.command.CommandType.CONNECT)  {
           return new draw2d.command.CommandConnect(request.source, request.target, request.source, request.router);
       }
       return this._super(request);
    }
});
draw2d.OutputPort = draw2d.Port.extend({
    NAME : "draw2d.OutputPort",
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
        this.locator=new draw2d.layout.locator.OutputPortLocator();
    },
    createCommand: function(request)
    {
       if(request.getPolicy() === draw2d.command.CommandType.CONNECT){
           return new draw2d.command.CommandConnect(request.target, request.source, request.source, request.router);
       }
       return this._super(request);
    }
});
draw2d.HybridPort = draw2d.Port.extend({
    NAME : "draw2d.HybridPort",
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
        this.locator=new draw2d.layout.locator.InputPortLocator();
    },
    createCommand: function(request)
    {
       if(request.getPolicy() === draw2d.command.CommandType.CONNECT) {
         if(request.source.getParent().getId() === request.target.getParent().getId()){
            return null;
         }    
         if (request.source instanceof draw2d.InputPort) {
            return new draw2d.command.CommandConnect(request.target, request.source, request.source, request.router);
         }
         else if (request.source instanceof draw2d.OutputPort) {
            return new draw2d.command.CommandConnect(request.source, request.target, request.source, request.router);
         }
         else if (request.source instanceof draw2d.HybridPort) {
            return new draw2d.command.CommandConnect(request.target,request.source, request.source, request.router);
         }
         return null;
       }
       return this._super(request);
    }
});
draw2d.layout.anchor.ConnectionAnchor = Class.extend({
    NAME : "draw2d.layout.anchor.ConnectionAnchor",
    init: function(owner)
    {
        this.owner = owner;
    },
    getLocation: function(reference, inquiringConnection)
    {
       return this.getReferencePoint(inquiringConnection);
    },
    getOwner: function()
    {
       return this.owner;
    },
    setOwner: function( owner)
    {
    	if(typeof owner ==="undefined"){
    		throw "Missing parameter for 'owner' in ConnectionAnchor.setOwner";
    	}
        this.owner=owner;
    },
    getBox: function()
    {
      return this.getOwner().getAbsoluteBounds();
    },
    getReferencePoint: function(inquiringConnection)
    {
       return this.getOwner().getAbsolutePosition();
    }
});
draw2d.layout.anchor.ChopboxConnectionAnchor = draw2d.layout.anchor.ConnectionAnchor.extend({
	NAME : "draw2d.layout.anchor.ChopboxConnectionAnchor",
	init: function(owner)
	{
		this._super(owner);
	},
	getLocation: function(reference, inquiringConnection)
	{
		var r = new draw2d.geo.Rectangle(0,0);
		r.setBounds(this.getBox());
		r.translate(-1, -1);
		r.resize(1, 1);
		var center = r.getCenter();
		if (r.isEmpty()	|| (reference.x === center.x && reference.y === center.y)){
			return center; 
		}
		var dx = reference.x - center.x;
		var dy = reference.y - center.y;
		var scale = 0.5 / Math.max(Math.abs(dx) / r.w, Math.abs(dy)	/ r.h);
		dx *= scale;
		dy *= scale;
		center.translate( dx, dy);
		return center;
	},
	getBox: function()
	{
		return this.getOwner().getParent().getBoundingBox();
	},
	getReferencePoint: function(inquiringConnection)
	{
		return this.getBox().getCenter();
	}
});
draw2d.shape.layout.Layout= draw2d.shape.basic.Rectangle.extend({
	NAME : "draw2d.shape.layout.Layout",
    init: function(attr, setter, getter )
    {
        this.padding = {top:0, right:0, bottom:0,left:0};
        this._super($.extend({bgColor:null, radius:0, stroke:0},attr),
            $.extend({
                padding  : this.setPadding
            }, setter),
            $.extend({
                padding  : this.getPadding
            }, getter));
        var _this = this;
        this.resizeListener = function(figure){
            if(_this.getParent() instanceof draw2d.shape.layout.Layout){
                _this.fireEvent("resize");
            }
            else {
                _this.setDimension(1,1);
                _this.fireEvent("resize");
            }
        };
        this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
    },
    add: function(child, locator, index)
    {
       this._super(child, locator, index);
       child.on("resize",this.resizeListener);
       child.on("change:visibility", this.resizeListener);
       child.visible =  child.visible && this.visible;
       return this;
    },
    remove: function(child)
    {
       var r= this._super(child);
       child.off(this.resizeListener);
       this.setDimension(1,1);
       return r;
    },
    setPadding: function( padding)
    {
        if(typeof padding ==="number"){
            this.padding = {top:padding, right:padding, bottom:padding, left:padding};
        }
        else{
            $.extend(this.padding, padding);
        }
        this.fireEvent("change:padding",{value:this.padding});
        this.setDimension(1,1);
        return this;
    },
    getPadding: function( )
    {
        return this.padding;
    },
    setVisible: function(flag)
    {
        this.children.each(function(i,e){
            e.figure.setVisible(flag)
        });
        this._super(flag);
        this.setDimension(1,1);
        return this;
    },
    createCommand: function( request)
    {
        if(request.getPolicy() === draw2d.command.CommandType.ROTATE){
            return null;
        }
        return this._super(request);
    }
});
draw2d.shape.layout.HorizontalLayout= draw2d.shape.layout.Layout.extend({
	NAME : "draw2d.shape.layout.HorizontalLayout",
    init: function(attr, setter, getter)
    {
        this.gap = 0;
        var _this = this;
        this.locator ={ 
                translate: function(figure, diff){
                    figure.setPosition(figure.x+diff.x,figure.y+diff.y);
                },
                bind: function(){},
                unbind: function(){},
                relocate: function(index, target)
                {
                    var stroke = _this.getStroke();
                    var yPos = stroke+_this.padding.top;
                    var xPos = stroke+_this.padding.left; 
                    for (var i=0;i<index;i++){
                        var child = _this.children.get(i).figure;
                        if(child.isVisible()){
                            xPos += child.getWidth()+_this.gap;
                        }
                    }
                    target.setPosition(xPos,yPos);
                 }
        };
        this._super(
                $.extend({width:1, height:1, gap:0},attr),
                $.extend({
                    gap : this.setGap
                },setter),
                $.extend({
                    gap : this.getGap
                },getter));
   },
    add: function(child, locator, index)
    {
        this._super(child, this.locator, index);
        this.setDimension(1,1);
        return this;
    },
   setGap: function(gap)
   {
       this.gap = gap;
       this.setDimension(1,1);
       return this;
   },
   getGap: function()
   {
       return this.gap;
   },
    getMinWidth: function()
    {
        var _this = this;
        var width=this.stroke*2+this.padding.left+this.padding.right;
        var gap = 0;
        this.children.each(function(i,e){
            if(e.figure.isVisible()){
                width += (e.figure.isResizeable()?e.figure.getMinWidth():e.figure.getWidth()+gap);
                gap = _this.gap;
            }
        });
        return width;
    },
    getMinHeight: function()
    {
        var markup=(this.stroke*2)+this.padding.top+this.padding.bottom;
        var height=0;
        this.children.each(function(i,e){
            height = Math.max(height,(e.figure.isResizeable()? e.figure.getMinHeight(): e.figure.getHeight()));
        });
        return height+markup;
    },
    setDimension: function( w, h)
    {
        this._super(w,h);
        var diff = this.width-this.getMinWidth();
        if(diff>0){
            diff = (diff/this.children.getSize())|0;
            this.children.each(function(i,e){
                if(e.figure.isResizeable()===true){
                    e.figure.setDimension(e.figure.getMinWidth()+diff,e.figure.getHeight());
                }
            });
        }
        else{
            var minHeight = this.getMinHeight();
            this.children.each(function(i,e){
                if(e.figure.isResizeable()===true){
                    e.figure.setDimension(1,minHeight);
                }
            });
        }
        return this;
    },
    getPersistentAttributes: function()
    {
        var memento = this._super();
        memento.gap = this.gap;
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.gap ==="number"){
            this.gap = memento.gap;
        }
        return this;
    }
});
draw2d.shape.layout.VerticalLayout= draw2d.shape.layout.Layout.extend({
	NAME : "draw2d.shape.layout.VerticalLayout",
    init: function(attr, setter, getter)
    {
        this.gap = 0;
        var _this = this;
        this.locator = {
            translate: function(figure, diff){
                figure.setPosition(figure.x+diff.x,figure.y+diff.y);
            },
            bind: function(){},
            unbind: function(){},
            relocate: function(index, target)
            {
                var stroke = _this.getStroke();
                var yPos =stroke+ _this.padding.top; 
                var xPos =_this.padding.left;
                for (var i=0;i<index;i++) {
                    var child = _this.children.get(i).figure;
                    if (child.isVisible()){
                        yPos += child.getHeight() + _this.gap;
                    }
                }
                target.setPosition(xPos,yPos);
             }
        };
        this._super(
                $.extend({width:10, height:10},attr),
                $.extend({
                    gap : this.setGap
                },setter),
                $.extend({
                    gap: this.getGap
                },getter));
    },
    add: function(child, locator, index)
    {
        this._super(child, this.locator, index);
        this.setDimension(1,1);
        return this;
    },
    setGap: function(gap)
    {
        this.gap = gap;
        this.setDimension(1,1);
    },
    getMinWidth: function()
    {
        var markup=(this.stroke*2)+this.padding.left+this.padding.right;
        var width=10;
        this.children.each(function(i,e){
        	if(e.figure.isVisible())
        		width = Math.max(width, e.figure.isResizeable()? e.figure.getMinWidth(): e.figure.getWidth());
        });
        return width+markup;
    },
    getMinHeight: function()
    {
        var _this = this;
    	var gap = 0;
        var markup=(this.stroke*2)+this.padding.top+this.padding.bottom;
        var height=0;
        this.children.each(function(i,e){
        	if(e.figure.isVisible()){
        		height += ((e.figure.isResizeable()?e.figure.getMinHeight():e.figure.getHeight())+gap);
        		gap = _this.gap;
        	}
        });
        return height+markup;
    },
    setDimension: function( w, h)
    {
        this._super(w,h);
        var width=this.width-this.padding.left-this.padding.right;
        if (width === this._recursiveWidth) {
            return this;
        }
        this._recursiveWidth = width;
        this.children.each(function(i,e){
            if(e.figure.isResizeable() && e.figure.isVisible()){
                e.figure.setDimension(width,e.figure.getMinHeight());
            }
        });
        delete this._recursiveWidth;
        return this;
    },
    getPersistentAttributes: function()
    {
        var memento = this._super();
        memento.gap = this.gap;
        return memento;
    },
    setPersistentAttributes: function(memento)
    {
        this._super(memento);
        if(typeof memento.gap ==="number"){
            this.gap = memento.gap;
        }
        return this;
    }
});
draw2d.shape.layout.TableLayout= draw2d.shape.layout.Layout.extend({
	NAME : "draw2d.shape.layout.TableLayout",
	DUMMY_CELL : {
	               getMinHeight: function(){return 1;},
	               getMinWidth:  function(){return 1;},
	               off:          function(){}
                 },
    init: function(attr, setter, getter)
    {
        var _this = this;
        this.cellLocator = {
            relocate: function(index, figure){ 
                if(_this.repaintBlocked===true){
                    return;
                }
                var cell= figure.__cell;
                var layout = _this.getCellLayout(cell.row,cell.column);
                var outerWidth = _this.getWidth();
                var minWidth   = _this.getMinWidth();
                var widthOffset =0;
                if(outerWidth!=minWidth){
                	widthOffset= ((outerWidth-minWidth)/ _this.layoutInfos[0].length)*cell.column;
                }
                var width  = figure.getWidth();
                var height = figure.getHeight();
            	var x = layout.x+_this.padding.left+layout.padding.left+widthOffset;
            	var y = layout.y+_this.padding.top +layout.padding.top;
                if(figure.isResizeable()){
                	var w = Math.max(figure.getMinWidth() , layout.w-(layout.padding.left+layout.padding.right)+widthOffset);
                	var h = Math.max(figure.getMinHeight(), layout.h-(layout.padding.top+layout.padding.bottom));
                	figure.setDimension(w,h);
                }
                else{
                	switch(layout.valign){
                	case "middle":
                		y=y+ (layout.h-height)/2;
                		break;
                	case "bottom":
                		y=y+ (layout.h-height);
                		break;
                	}
                	switch(layout.align){
                	case "center":
                		x=x+ (layout.w-width)/2+(widthOffset/2);
                		break;
                	case "right":
                		x=x+ (layout.w-width)+widthOffset;
                		break;
                	}                	
                }
                figure.setPosition(x, y);
            },
            bind: function(){},
            unbind: function(){},
            translate: function(figure, diff){
                figure.setPosition(figure.x+diff.x,figure.y+diff.y);
            }
        };
        this.padding = {top:4, right:4, bottom:4,left:4};
        this.grid = [];
        this.layoutInfos = [];
        this.layoutInfos[0]=[];
        this.layoutInfos[0][0]={x:0, y:0, w:1, h:1, valign:"top", align:"left"};
        this._super(
                $.extend({stroke:1, resizeable:false},attr),
                $.extend({
                    padding  : this.setPadding
                }, setter),
                $.extend({
                    padding  : this.getPadding
                }, getter));
    },
    setCellPadding: function(row, column, padding)
    {
    	var layout = this.getCellLayout(row, column);
    	if(layout===null){
    		return this;
    	}
    	if(typeof padding ==="number"){
          layout.padding = {top:padding, right:padding, bottom:padding, left:padding};
    	}
    	else{
          $.extend(layout.padding, padding);
    	}
        this.calculateLayout();
    	this.setDimension(1,1);
    	return this;
    },
    getCellPadding: function(row, column )
    {
        var layout = this.getCellLayout(row, column);
    	if(layout===null || typeof layout.padding==="undefined"){
    		return {top:0, right:0, bottom:0, left:0};
    	}
    	return layout.padding;
    },
    setPadding: function( padding)
    {
        if(typeof padding ==="number"){
            this.padding = {top:padding, right:padding, bottom:padding, left:padding };
        }
        else{
            $.extend(this.padding, padding);
        }
        this.calculateLayout();
        this.setDimension(1,1);
        this.fireEvent("change:padding",{value:this.padding});
        return this;
    },
    getPadding: function( )
    {
      return this.padding;
    },
    setCanvas: function(canvas)
    {
         this._super(canvas);  
         this.calculateLayout();
         this.setDimension(2,2);
        return this;
    },
    add: function(child, locator, index)
    {
        this._super(child, locator, index);
        this.setDimension(1,1);
        return this;
    },
    removeRow: function(index)
    {
        var _this = this;
    	var removedRow = this.grid.splice(index, 1);
    	removedRow[0].forEach(function(figure){
    		_this.remove(figure);
    	});
    	this.calculateLayout();
    	this.setDimension(2,2);
        return removedRow;
    },
    addRow: function ()
    {
        var figuresToAdd = [];
        var _this = this;
    	var args = Array.prototype.slice.call(arguments); 
    	var rowCount    = this.grid.length+1;
    	var columnCount = this.grid.length>0?Math.max(this.grid[0].length, args.length):args.length;
    	var row = [];
    	args.forEach(function(figure, index){
    		if(typeof figure ==="string"){
    		    figure = new draw2d.shape.basic.Label({text:figure});
    		}
    		row.push(figure);
    		figuresToAdd.push(figure);
    	});
    	this.grid.push(row);
    	this.grid.forEach(function(row, index){
    	    var missingColumns = columnCount-row.length;
    	    for(var i=0;i<missingColumns;i++){
    	        row.push(_this.DUMMY_CELL);
    	    }
    	});
        var orig = this.repaintBlocked;
    	this.repaintBlocked=true;
        figuresToAdd.forEach(function(figure){
            _this.add(figure, _this.cellLocator);
        });
        this.repaintBlocked = orig;
        this.calculateLayout();
        this.setDimension(1,1);
    	return this;
    },
    getMinWidth: function()
    {
        if(this.canvas===null ||this.layoutInfos.length===0){
            return 10;
        }
    	var bottom     = this.layoutInfos[this.layoutInfos.length-1];
    	var layout= bottom[bottom.length-1];
    	return layout.w+layout.x+this.padding.left+this.padding.right;
    },
    getMinHeight: function()
    {
        if(this.canvas===null ||this.layoutInfos.length===0){
            return 10;
        }
        var bottom     = this.layoutInfos[this.layoutInfos.length-1];
    	var layout= bottom[bottom.length-1];
    	return layout.h+layout.y+ this.padding.top+this.padding.bottom;
    },
    setCellVerticalAlign: function(row, column, valign){
       	var layout = this.getCellLayout(row, column);
    	if(layout===null){
    		return; 
    	}
    	switch(valign){
	    	case "top":
	    	case "middle":
	    	case "bottom":
	    		layout.valign = valign;
	            this.calculateLayout();
	            this.setDimension(1,1);
    	}
        return this;
    },
     getCellVerticalAlign: function(row, column){
        var layout = this.getCellLayout(row, column);
        if(layout===null){
            return "top";
        }
        return layout.valign;
    },
    setCellAlign: function(row, column, align){
    	var layout = this.getCellLayout(row, column);
    	if(layout===null){
    		return; 
    	}
    	switch(align){
	    	case "left":
	    	case "center":
	    	case "right":
	    		layout.align = align;
	            this.calculateLayout();
	            this.setDimension(1,1);
    	}
        return this;
    },
    getCellAlign: function(row, column){
        var layout = this.getCellLayout(row, column);
        if(layout===null){
            return "left";
        }
        return layout.align;
    },
    getCellLayout: function(row, column)
    {
    	if(row<0 || column<0){
    		return null; 
    	}
    	if(row >= this.layoutInfos.length){
    		return null; 
    	}
    	var layouts = this.layoutInfos[row];
    	if(column >= layouts.length){
    		return null; 
    	}
    	return layouts[column];
    },
    calculateLayout: function()
    {
    	var _this = this;
    	var rowCount    = this.grid.length;
    	var columnCount = this.grid.length>0?this.grid[0].length:0;
    	var newLayoutInfos = [];
        for (var row=0;row<rowCount;row++) {
        	newLayoutInfos[row]=[];
        	for (var column=0;column<columnCount;column++) {
        		newLayoutInfos[row][column]={width:0, height:0, x:0, y:0, valign:this.getCellVerticalAlign(row, column), align:this.getCellAlign(row, column), padding: this.getCellPadding(row, column)};
	         }
        }
        var layoutWidths = new Array(columnCount+1).join('0').split('').map(parseFloat);
        var layoutHeights= new Array(rowCount+1).join('0').split('').map(parseFloat);
        this.grid.forEach(function(figures, row){
        	for(var column=0; column<columnCount; column++){
        		var layout = newLayoutInfos[row][column];
        		var figure = figures[column];
                figure.__cell = {row:row, column:column};
                layoutHeights[row]   = Math.max(layoutHeights[row]  , figure.getMinHeight() +layout.padding.top + layout.padding.bottom);
                layoutWidths[column] = Math.max(layoutWidths[column], figure.getMinWidth()  +layout.padding.left+ layout.padding.right );
        	}
        });
        var x=0, y=0;
        for (row=0;row<rowCount;row++) {
       		for(column=0;column<columnCount;column++) {
       			var layout = newLayoutInfos[row][column];
       			layout.w = layoutWidths[column];
       			layout.h = layoutHeights[row];
       			layout.x = x;
       			layout.y = y;
       			x = x+layout.w;
	        }
       		y= y+layoutHeights[row];
       		x=0;
        }
        this.layoutInfos = newLayoutInfos;
        return this;
    }
});
draw2d.shape.layout.FlexGridLayout= draw2d.shape.layout.Layout.extend({
	NAME : "draw2d.shape.layout.FlexGridLayout",
    init: function(attr, setter, getter)
    {
        var _this = this;
        this.cellLocator = {
            relocate: function(index, figure){ 
                if(_this.gridDef.layoutRequired===true){
                    _this._layout();
                }
                var cell = figure.__cellConstraint;
                var x = cell.x;
                var y = cell.y;
                if(figure.isResizeable()){
                    figure.setDimension( 
                            Math.max(figure.getMinWidth() , cell.width),
                            Math.max(figure.getMinHeight(), cell.height));
                }
                else{
                    switch(cell.valign){
                    case "middle":
                        y=y+ (cell.height-figure.getHeight())/2;
                        break;
                    case "bottom":
                        y=y+ (cell.height-figure.getHeight());
                        break;
                    }
                    switch(cell.align){
                    case "center":
                        x=x+ (cell.width-figure.getWidth())/2;
                        break;
                    case "right":
                        x=x+ (cell.width-figure.getWidth());
                        break;
                    }                   
                }
                figure.setPosition(x, y);
            },
            bind: function(){},
            unbind: function(){},
            translate: function(figure, diff){
                figure.setPosition(figure.x+diff.x,figure.y+diff.y);
            }
        };
        this.debug=false;
        this.gridDef={
            debugLines : [],
            def_cols  : [],
            def_rows  : [],
            min_height: [],
            min_width : [],      
            minGridWidth:10,
            minGridHeight:10,
            hResizeable:false,
            vResizeable:false,
            layoutRequired:true
        };
        this._super(
                $.extend({stroke:2},attr),
                $.extend({
                }, setter),
                $.extend({
                }, getter));
        this.resizeListener = function(figure)
        {
            _this.gridDef.layoutRequired=true;
            if(_this.getParent() instanceof draw2d.shape.layout.Layout){
                _this.fireEvent("resize");
            }
            else {
                _this.setDimension(
                        _this.gridDef.hResizeable===true?_this.getWidth():1,
                        _this.gridDef.vResizeable===true?_this.getHeight():1
                        );
            }
        };
        var rows   = attr.rows.split(",");
        var columns= attr.columns.split(",");
        for(var i=0;i<columns.length;i++){
            this.gridDef.def_cols[i]=this.cellWidthFromDef(columns[i]);
        }
        for(var i=0;i<rows.length;i++){
            this.gridDef.def_rows[i]=this.cellWidthFromDef(rows[i]);
        }
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());
    },
    add: function(figure, cellConstraint){
        figure.__cellConstraint=  $.extend({},{row:0, col:0, rowspan:1, colspan:1, align:"left", valign:"top", width:1, height:1}, cellConstraint);
        this._super(figure, this.cellLocator);
        this._layout();
    },
    getMinWidth: function()
    {
        return this.gridDef.minGridWidth;
    },
    getMinHeight: function()
    {
        return this.gridDef.minGridHeight;
    },
    setCanvas: function(canvas){
        this.gridDef.layoutRequired=true;
        this._super(canvas);
        return this;
    },
    repaint: function(attributes){
        if (this.repaintBlocked===true || this.shape === null){
            return this;
        }
        this._super(attributes);
        if(this.debug){
            this.paintDebugGrid();
        }
        return this;
    },
    setDimension: function(w,h)
    {
        if(this.gridDef.layoutRequired===true){
            this._layout();
        }
        this._super(w,h);
        this.gridDef.layoutRequired=true;
        this.repaint();
        return this;
    },
    _layout: function()
    {
       this.gridDef.layoutRequired=false;
       var figures = this.getChildren();
       this.gridDef.min_height = this.gridDef.def_rows.slice(0);
       this.gridDef.min_width  = this.gridDef.def_cols.slice(0);
       for(var i=0;i<figures.getSize();i++){
           var figure = figures.get(i);
           var cell = figure.__cellConstraint;
           this.gridDef.min_width[cell.col]=Math.max(this.gridDef.min_width[cell.col],figure.getMinWidth());
       		if(cell.rowspan>1){
       			var eHeight = figure.getMinHeight();         
       			var cHeight = this.cellHeight(cell.row,cell.row+cell.rowspan);
       		    if(cHeight<eHeight){
       		        var diff= eHeight-cHeight;
       		     this.gridDef.min_height[cell.row+cell.rowspan-1] = this.gridDef.min_height[cell.row+cell.rowspan-1]+diff;
       		    }
       		}
       		else{
       		 this.gridDef.min_height[cell.row]=Math.max(this.gridDef.min_height[cell.row],figure.getMinHeight());
    	   	}
       }
       this.gridDef.minGridWidth =this._getGridWidth();
       this.gridDef.minGridHeight=this._getGridHeight();
       var gridHeight = this._getGridHeight();
       for ( var i = 0; i < this.gridDef.def_rows.length; i++) {
           if (this.gridDef.def_rows[i] === -1){
               this.gridDef.min_height[i] = this.gridDef.min_height[i] +Math.max(0,this.getHeight() - gridHeight);
               this.gridDef.vResizeable=true;
               break;
           }
       }
       var gridWidth= this._getGridWidth();
       for(var i=0;i<this.gridDef.def_cols.length;i++){
           if(this.gridDef.def_cols[i] === -1){
               this.gridDef.min_width[i]= this.gridDef.min_width[i]+Math.max(0,this.getWidth()-gridWidth);
               this.gridDef.hResizeable=true;
      	       break;
       	   }
       }
       for(var i=0;i<figures.getSize();i++) {
           var cell = figures.get(i).__cellConstraint;
     	   cell.width  = this.cellWidth(cell.col ,cell.col+cell.colspan);
     	   cell.height = this.cellHeight(cell.row,cell.row+cell.rowspan);
           cell.x   = this.cellX(cell.col);
           cell.y   = this.cellY(cell.row);
       }
        return this;
    },
    cellX: function(col )
    {
        var r=0;
    	for(var i=0;i<col;i++){
    	 r= r+this.gridDef.min_width[i];
    	}
    	return r;
    },
    cellY: function(row )
    {
        var r=0;
    	for(var i=0;i<row;i++){
    	    r= r+this.gridDef.min_height[i];
    	}
    	return r;
    },
    cellWidth: function(from, to)
    {
    	var r =0;
    	for(var i=from;i<to;i++){
    	    r= r+this.gridDef.min_width[i];
    	}
        return r;
    },
    cellHeight: function(from, to)
    {
    	var r =0;
    	for(var i=from;i<to;i++){
    	    r= r+this.gridDef.min_height[i];
    	}
    	return r;
    },
    paintDebugGrid: function()
    {
        for(var i=0;i<this.gridDef.debugLines.length;i++)
            this.gridDef.debugLines[i].remove();
        this.gridDef.debugLines= [];
    	var gridHeight=this._getGridHeight();
    	var gridWidth=this._getGridWidth();
    	var posX = this.getAbsoluteX();
    	var posY = this.getAbsoluteY();
        var x=posX;
        for(var i=0;i<=this.gridDef.min_width.length;i++)
        {
           var newLine =  this.canvas.paper.path("M "+x+" " + posY + " l 0 " + gridHeight) .attr({"stroke":"#FF0000","stroke-width":1});
           this.gridDef.debugLines.push(newLine);
           if(i<this.gridDef.min_width.length)
    	       x=x+this.gridDef.min_width[i];
        }
        var y=posY;
        for(var i=0;i<=this.gridDef.min_height.length;i++)
        {
            var newLine =  this.canvas.paper.path("M "+posX+" " + y + " l " + gridWidth + " 0") .attr({"stroke":"#FF0000","stroke-width":1});
            this.gridDef.debugLines.push(newLine);
            if(i<this.gridDef.min_height.length)
    	       y=y+this.gridDef.min_height[i];
        }
    },
    _getGridWidth: function()
    {
        var gridWidth=0;
        for(var i=0;i<this.gridDef.min_width.length;i++) {
            gridWidth = gridWidth + this.gridDef.min_width[i];
        }
        return gridWidth;
    },
    _getGridHeight: function()
    {
        var gridHeight=0;
        for(var i=0;i<this.gridDef.min_height.length;i++) {
            gridHeight = gridHeight + this.gridDef.min_height[i];
        }
        return gridHeight;
    },
    cellWidthFromDef: function( def)
    {
      var pattern = new RegExp("(\\d+)(?:px)?");
      var match = def.match(pattern);
      if (match!=null) {
          return parseInt(match[1]);
      }
      pattern = new RegExp("p(?:ref)?");
      match = def.match(pattern);
      if (match!=null) {
          return 0;
      }
      pattern = new RegExp("g(?:row)?");
      match = def.match(pattern);
      if (match!=null){
        this.autoResize=false;
        return -1;
      }
      return 0;
    }
});
draw2d.shape.layout.StackLayout= draw2d.shape.layout.Layout.extend({
	NAME : "draw2d.shape.layout.StackLayout",
    init: function(attr, setter, getter)
    {
        this.visibleLayer = 0;
        this.locator = new draw2d.layout.locator.XYAbsPortLocator(0,0);
        this._super(
                $.extend({resizeable:true, width:10, height:10},attr),
                $.extend({}, setter),
                $.extend({}, getter));
        this.resizeListener = function(figure){ };
        this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());
    },
    setVisibleLayer: function(visibleLayer, duration){
        this.getChildren().get(this.visibleLayer).setVisible(false, duration);
        this.visibleLayer = Math.min(this.getChildren().getSize()-1,Math.max(0,visibleLayer));
        this.getChildren().get(this.visibleLayer).setVisible(true, duration);
        return this;
    },
    getVisibleLayer: function(){
        return this.visibleLayer;
    },
    add: function(child, locator, index)
    {
        child.hitTest = function(){return false};
        this.getChildren().each(function(i, c){
            c.setVisible(false);
        });
        this.visibleLayer = this.getChildren().getSize();
        return this._super(child, this.locator, index);
    },
    setVisible: function(flag)
    {
        draw2d.shape.basic.Rectangle.prototype.setVisible.call(this,flag);
        return this;
    },
    getMinWidth: function()
    {
        var markup=(this.stroke*2)+this.padding.left+this.padding.right;
        var width=10;
        this.children.each(function(i,e){
        		width = Math.max(width, e.figure.isResizeable()? e.figure.getMinWidth(): e.figure.getWidth());
        });
        return width+markup;
    },
    getMinHeight: function()
    {
        var markup=(this.stroke*2)+this.padding.top+this.padding.bottom;
        var height=10;
        this.children.each(function(i,e){
            height = Math.max(height, e.figure.isResizeable()? e.figure.getMinHeight(): e.figure.getHeight());
        });
        return height+markup;
    },
    setDimension: function( w, h)
    {
        this._super(w,h);
        var width=this.width-this.padding.left-this.padding.right;
        var height=this.height-this.padding.top-this.padding.bottom;
        if (width === this._recursiveWidth && height === this._recursiveHeight) {
            return this;
        }
        this._recursiveHeight= height;
        this._recursiveWidth = width;
        this.children.each(function(i,e){
            if(e.figure.isResizeable()){
                e.figure.setDimension(width,height);
            }
        });
        delete this._recursiveHeight;
        delete this._recursiveWidth;
        return this;
    }
});
draw2d.ui.LabelEditor = Class.extend({
    NAME : "draw2d.ui.LabelEditor",
    init: function(listener)
    {
        this.configuration = $.extend({onCommit: function(){}, onCancel: function(){}, text:"Value"},listener);
     },
    start: function( label)
    {
        var newText = prompt(this.configuration.text, label.getText());
        if(newText){
            var cmd =new draw2d.command.CommandAttr(label, {text:newText});
            label.getCanvas().getCommandStack().execute(cmd);
            this.configuration.onCommit(label.getText());
        }
        else{
            this.configuration.onCancel();
        }
    }
});
draw2d.ui.LabelInplaceEditor =  draw2d.ui.LabelEditor.extend({
    NAME: "draw2d.ui.LabelInplaceEditor",
    init: function(listener)
    {
        this._super();
        this.listener = $.extend({onCommit: function(){}, onCancel: function(){}},listener);
    },
    start: function( label)
    {
        this.label = label;
        this.commitCallback = $.proxy(this.commit,this);
        $("body").bind("click",this.commitCallback);
        this.html = $('<input id="inplaceeditor">');
        this.html.val(label.getText());
        this.html.hide();
        $("body").append(this.html);
        this.html.autoResize({animate:false});
        this.html.bind("keyup",$.proxy(function(e){
            switch (e.which) {
            case 13:
                 this.commit();
                 break;
            case 27:
                this.cancel();
                 break;
           }
         },this));
         this.html.bind("blur",this.commitCallback);
         this.html.bind("click",function(e){
             e.stopPropagation();
             e.preventDefault();
         });
        var canvas = this.label.getCanvas();
        var bb = this.label.getBoundingBox();
        bb.setPosition(canvas.fromCanvasToDocumentCoordinate(bb.x,bb.y));
        var scrollDiv = canvas.getScrollArea();
        if(scrollDiv.is($("body"))){
           bb.translate(canvas.getScrollLeft(), canvas.getScrollTop());
        }
        bb.translate(-1,-1);
        bb.resize(2,2);
        this.html.css({position:"absolute","top": bb.y, "left":bb.x, "min-width":bb.w*(1/canvas.getZoom()), "height":Math.max(25,bb.h*(1/canvas.getZoom()))});
        this.html.fadeIn($.proxy(function(){
            this.html.focus();
        },this));
    },
    commit: function()
    {
        this.html.unbind("blur",this.commitCallback);
        $("body").unbind("click",this.commitCallback);
        var label = this.html.val();
        var cmd =new draw2d.command.CommandAttr(this.label, {text:label});
        this.label.getCanvas().getCommandStack().execute(cmd);
        this.html.fadeOut($.proxy(function(){
            this.html.remove();
            this.html = null;
            this.listener.onCommit(this.label.getText());
        },this));
    },
    cancel: function()
    {
        this.html.unbind("blur",this.commitCallback);
        $("body").unbind("click",this.commitCallback);
        this.html.fadeOut($.proxy(function(){
            this.html.remove();
            this.html = null;
            this.listener.onCancel();
        },this));
    }
});
draw2d.decoration.connection.Decorator = Class.extend({
	NAME : "draw2d.decoration.connection.Decorator",
	init: function(width, height) {
        if(typeof width === "undefined" || width<1){
            this.width  = 20;
        }
        else{
            this.width = width;
        }
        if(typeof height === "undefined" || height<1){
            this.height = 15;
        }
        else{
            this.height = height;
        }
		this.color = new draw2d.util.Color(0, 0, 0);
		this.backgroundColor = new  draw2d.util.Color(250, 250, 250);
	},
	paint: function(paper) {
	},
	setColor: function(c) {
		this.color = new draw2d.util.Color(c);
		return this;
	},
	setBackgroundColor: function(c) {
		this.backgroundColor = new draw2d.util.Color(c);
		return this;
	},
    setDimension: function( width, height)
    {
        this.width=width;
        this.height=height;
        return this;
    }
});
draw2d.io.Reader = Class.extend({
    init: function(){
    },
    unmarshal: function(canvas, document){
    }
});
draw2d.io.Writer = Class.extend({
    init: function(){
    },
    marshal: function(canvas, resultCallback){
        if(typeof resultCallback !== "function"){
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }
        resultCallback("", "");
    },
    formatXml: function(xml) {
        var formatted = '';
        var reg = new RegExp("(>)(<)(\/*)","g");
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function(index, node) {
            var indent = 0;
            if (node.match( new RegExp(".+<\/\w[^>]*>$") )) {
                indent = 0;
            } else if (node.match( new RegExp("^<\/\w") )) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match( new RegExp("^<\w[^>]*[^\/]>.*$") )) {
                indent = 1;
            } else {
                indent = 0;
            }
            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }
            formatted += padding + node + '\r\n';
            pad += indent;
        });
        return formatted;
    }
});
draw2d.io.svg.Writer = draw2d.io.Writer.extend({
    init: function(){
        this._super();
    },
    marshal: function(canvas, callback){
        if(typeof callback !== "function"){
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }
        var s =canvas.getPrimarySelection();
        canvas.setCurrentSelection(null);
        var svg = canvas.getHtmlContainer().html()
                     .replace(/>\s+/g, ">")
                     .replace(/\s+</g, "<");
        svg = this.formatXml(svg);
        svg = svg.replace(/<desc>.*<\/desc>/g,"<desc>Create with draw2d JS graph library and RaphaelJS</desc>");
        canvas.setCurrentSelection(s);
    	var base64Content = draw2d.util.Base64.encode(svg);
    	callback( svg, base64Content);
    }
});
draw2d.io.png.Writer = draw2d.io.Writer.extend({
    init: function(){
        this._super();
    },
    marshal: function(canvas, resultCallback, cropBoundingBox){
        if(typeof resultCallback !== "function"){
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }
        var svg = "";
        if(canvas instanceof draw2d.Figure){
            var origPos = canvas.getPosition();
            canvas.setPosition(1,1);
            svg =   "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" >"
                  + canvas.shape.node.outerHTML
                  + "</svg>";
            canvas.setPosition(origPos);
            canvas.initialWidth = canvas.getWidth()+2;
            canvas.initialHeight= canvas.getHeight()+2;
        }
        else {
            canvas.hideDecoration();
            svg = canvas.getHtmlContainer().html().replace(/>\s+/g, ">").replace(/\s+</g, "<");
            if(!svg.includes("http://www.w3.org/1999/xlink")) {
                svg = svg.replace("<svg ", "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" ");
            }
        }
        if(document.all){
            svg = svg.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
        }
        canvasDomNode= $('<canvas id="canvas_png_export_for_draw2d" style="display:none"></canvas>');
        $('body').append(canvasDomNode);
        fullSizeCanvas = $("#canvas_png_export_for_draw2d")[0];
        fullSizeCanvas.width = canvas.initialWidth;
        fullSizeCanvas.height = canvas.initialHeight;
        canvg("canvas_png_export_for_draw2d", svg, { 
            ignoreMouse: true, 
            ignoreAnimation: true,
            renderCallback: function(){
                try{
                    if(canvas instanceof draw2d.Canvas)
                        canvas.showDecoration();
                    if(typeof cropBoundingBox!=="undefined"){
                          var sourceX = cropBoundingBox.x;
                          var sourceY = cropBoundingBox.y;
                          var sourceWidth = cropBoundingBox.w;
                          var sourceHeight = cropBoundingBox.h;
                          croppedCanvas = document.createElement('canvas');
                          croppedCanvas.width = sourceWidth;
                          croppedCanvas.height = sourceHeight;
                          croppedCanvas.getContext("2d").drawImage(fullSizeCanvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0,sourceWidth, sourceHeight);
                          var dataUrl = croppedCanvas.toDataURL("image/png");
                          var base64Image = dataUrl.replace("data:image/png;base64,","");
                          resultCallback(dataUrl, base64Image);
                    }
                    else{
                        var img = fullSizeCanvas.toDataURL("image/png");
                        resultCallback(img,img.replace("data:image/png;base64,",""));
                    }
                }
                finally{
                    canvasDomNode.remove();
                }
           }
        }) ;   
    }
});
draw2d.io.json.Writer = draw2d.io.Writer.extend({
    init: function()
    {
        this._super();
    },
    marshal: function(canvas, resultCallback)
    {
        if(typeof resultCallback !== "function"){
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }
        var result = [];
        canvas.getFigures().each(function(i, figure){
            result.push(figure.getPersistentAttributes());
        });
        canvas.getLines().each(function(i, element){
            result.push(element.getPersistentAttributes());
        });
    	var base64Content = draw2d.util.Base64.encode(JSON.stringify(result, null, 2));
    	resultCallback(result, base64Content);
    }
});
draw2d.io.json.Reader = draw2d.io.Reader.extend({
    NAME : "draw2d.io.json.Reader",
    init: function(){
        this._super();
    },
    unmarshal: function(canvas, json){
        var _this = this;
        var result = new draw2d.util.ArrayList();
        if(typeof json ==="string"){
            json = JSON.parse(json);
        }
        var node=null;
        $.each(json, $.proxy(function(i, element){
            try{
                var o = _this.createFigureFromType(element.type);
                var source= null;
                var target=null;
                for(i in element){
                    var val = element[i];
                    if(i === "source"){
                        node = canvas.getFigure(val.node);
                        if(node===null){
                            throw "Source figure with id '"+val.node+"' not found";
                        }
                        source = node.getPort(val.port);
                        if(source===null){
                            throw "Unable to find source port '"+val.port+"' at figure '"+val.node+"' to unmarschal '"+element.type+"'";
                        }
                    }
                    else if (i === "target"){
                        node = canvas.getFigure(val.node);
                        if(node===null){
                            throw "Target figure with id '"+val.node+"' not found";
                        }
                        target = node.getPort(val.port);
                        if(target===null){
                            throw "Unable to find target port '"+val.port+"' at figure '"+val.node+"' to unmarschal '"+element.type+"'";
                        }
                    }
                }
                if(source!==null && target!==null){
                    o.setSource(source);
                    o.setTarget(target);
                }
                o.setPersistentAttributes(element);
                canvas.add(o);
                result.add(o);
            }
            catch(exc){
                debug.error(element,"Unable to instantiate figure type '"+element.type+"' with id '"+element.id+"' during unmarshal by "+this.NAME+". Skipping figure..");
                debug.error(exc);
                debug.warn(element);
            }
        },this));
        $.each(json, $.proxy(function(i, element){
            if(typeof element.composite !== "undefined"){
               var figure = canvas.getFigure(element.id);
               if(figure===null){
                   figure =canvas.getLine(element.id);
               }
               var group = canvas.getFigure(element.composite);
               group.assignFigure(figure);
            }
        },this));
        canvas.calculateConnectionIntersection();
        canvas.getLines().each(function(i,line){
            line.svgPathString=null;
            line.repaint();
        });
        canvas.linesToRepaintAfterDragDrop = canvas.getLines().clone();
        canvas.showDecoration();
        return result;
    },
    createFigureFromType:function(type)
    {
        return eval("new "+type+"()");
    }
});




// avoid iPad bounce effect during DragDrop
//
document.ontouchmove = function(e){e.preventDefault();};

// hide context menu
//document.oncontextmenu = function() {return false;};


// hacking RaphaelJS to support groups of elements
//
(function() {
    Raphael.fn.group = function(f, g) {
        var enabled = document.getElementsByTagName("svg").length > 0;
        if (!enabled) {
            // return a stub for VML compatibility
            return {
                add : function() {
                    // intentionally left blank
                }
            };
        }
      var i;
      this.svg = "http://www.w3.org/2000/svg";
      this.defs = document.getElementsByTagName("defs")[f];
      this.svgcanv = document.getElementsByTagName("svg")[f];
      this.group = document.createElementNS(this.svg, "g");
      for(i = 0;i < g.length;i++) {
        this.group.appendChild(g[i].node);
      }
      this.svgcanv.appendChild(this.group);
      this.group.translate = function(c, a) {
        this.setAttribute("transform", "translate(" + c + "," + a + ") scale(" + this.getAttr("scale").x + "," + this.getAttr("scale").y + ")");
      };
      this.group.rotate = function(c, a, e) {
        this.setAttribute("transform", "translate(" + this.getAttr("translate").x + "," + this.getAttr("translate").y + ") scale(" + this.getAttr("scale").x + "," + this.getAttr("scale").y + ") rotate(" + c + "," + a + "," + e + ")");
      };
      this.group.scale = function(c, a) {
        this.setAttribute("transform", "scale(" + c + "," + a + ") translate(" + this.getAttr("translate").x + "," + this.getAttr("translate").y + ")");
      };
      this.group.push = function(c) {
        this.appendChild(c.node);
      };
      this.group.getAttr = function(c) {
        this.previous = this.getAttribute("transform") ? this.getAttribute("transform") : "";
        var a = [], e, h, j;
        a = this.previous.split(" ");
        for(i = 0;i < a.length;i++) {
          if(a[i].substring(0, 1) == "t") {
            var d = a[i], b = [];
            b = d.split("(");
            d = b[1].substring(0, b[1].length - 1);
            b = [];
            b = d.split(",");
            e = b.length === 0 ? {x:0, y:0} : {x:b[0], y:b[1]};
          }else {
            if(a[i].substring(0, 1) === "r") {
              d = a[i];
              b = d.split("(");
              d = b[1].substring(0, b[1].length - 1);
              b = d.split(",");
              h = b.length === 0 ? {x:0, y:0, z:0} : {x:b[0], y:b[1], z:b[2]};
            }else {
              if(a[i].substring(0, 1) === "s") {
                d = a[i];
                b = d.split("(");
                d = b[1].substring(0, b[1].length - 1);
                b = d.split(",");
                j = b.length === 0 ? {x:1, y:1} : {x:b[0], y:b[1]};
              }
            }
          }
        }
        if(typeof e === "undefined") {
          e = {x:0, y:0};
        }
        if(typeof h === "undefined") {
          h = {x:0, y:0, z:0};
        }
        if(typeof j === "undefined") {
          j = {x:1, y:1};
        }
        
        if(c == "translate") {
          var k = e;
        }else {
          if(c == "rotate") {
            k = h;
          }else {
            if(c == "scale") {
              k = j;
            }
          }
        }
        return k;
      };
      this.group.copy = function(el){
         this.copy = el.node.cloneNode(true);
         this.appendChild(this.copy);
      };
      return this.group;
    };
})();


/**
 * adding support method to check if the node is already visible
 **/
(function() {
    Raphael.el.isVisible = function() {
        return (this.node.style.display !== "none");
    }
})();

Math.sign = function()
{
 if (this < 0) {return -1;}
 return 1;
};

;
/*jshint sub:true*/


/**
 * 
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 * 
 * @author Andreas Herz
 */

var Application = Class.extend(
{

    /**
     * @constructor
     * 
     * @param {String} canvasId the id of the DOM element to use as paint container
     */
    init : function()
    {
        var _this = this;

        this.localStorage = [];
        this.loggedIn = false;

        try {
            if( 'localStorage' in window && window.localStorage !== null){
                this.localStorage = localStorage;
            }
        } catch(e) {

        }


        this.currentFileHandle= {
            title: "Untitled"+conf.fileSuffix
        };
        this.palette  = new Palette(this);
        this.view     = new View(this, "draw2dCanvas");
        this.filePane = new Files(this);
        this.loggedIn = false;

        $("#appLogin, .editorLogin").on("click", function(){_this.login();});
        $("#fileOpen, #editorFileOpen").on("click", function(){ _this.fileOpen(); });
        $("#fileNew").on("click", function(){_this.fileNew();});
        $("#fileSave, #editorFileSave").on("click", function(){ _this.fileSave();});
        $("#appHelp").on("click", function(){$("#leftTabStrip .gitbook").click();});
        $("#appAbout").on("click", function(){ $("#leftTabStrip .about").click();});

        // First check if a valid token is inside the local storage
        //
        this.autoLogin();

        /*
         * Replace all SVG images with inline SVG
         */
        $('img.svg').each(function(){
            var $img = $(this);
            var imgURL = $img.attr('src');

            jQuery.get(imgURL, function(data) {
                // Get the SVG tag, ignore the rest
                var $svg = $(data).find('svg');
                // Remove any invalid XML tags as per http://validator.w3.org
                $svg = $svg.removeAttr('xmlns:a');
                // Replace image with new SVG
                $img.replaceWith($svg);
            }, 'xml');

        });
    },


    login:function()
    {
        var _this = this;
        // store the current document and visible tab pane.
        // This will be restored after the login has been done
        //
        var id= $("#leftTabStrip .active").attr("id");
        this.localStorage["pane"]=id;
        var writer = new draw2d.io.json.Writer();
        writer.marshal(this.view, function (json, base64) {
            _this.localStorage["json"]=JSON.stringify(json, undefined,2);
            window.location.href=conf.backend.oauth;
        });
    },



    dump:function()
    {
        var writer = new draw2d.io.json.Writer();
        writer.marshal(this.view, function (json) {
            console.log(JSON.stringify(json, undefined,2));
        });
    },

    getParam: function( name )
    {
        name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
        var regexS = "[\\?&]"+name+"=([^&#]*)";
        var regex = new RegExp( regexS );
        var results = regex.exec( window.location.href );

        // the param isn'T part of the normal URL pattern...
        //
        if( results === null ) {
            // maybe it is part in the hash.
            //
            regexS = "[\\#]"+name+"=([^&#]*)";
            regex = new RegExp( regexS );
            results = regex.exec( window.location.hash );
            if( results === null ) {
                return null;
            }
        }

        return results[1];
    },

    fileNew: function(shapeTemplate)
    {
        $("#leftTabStrip .editor").click();
        this.currentFileHandle = {
            title: "Untitled"+conf.fileSuffix
        };
        this.view.clear();
        if(shapeTemplate){
            var reader = new Reader();
            reader.unmarshal(this.view, shapeTemplate);
        }
        this.view.centerDocument();
    },


    fileSave: function()
    {
        var _this = this;

        if(this.loggedIn!==true){
            this.loginFirstMessage();
            return;
        }

        new FileSave(this.currentFileHandle).show(this.view, function(){
            _this.filePane.render();
        });
    },


    fileOpen: function(name)
    {
        var _this = this;

        if(this.loggedIn!==true){
            this.loginFirstMessage();
            return;
        }

        var openByIdCallback = function(id){
            $.ajax({
                    url: conf.backend.file.get,
                    method: "POST",
                    xhrFields: {
                        withCredentials: true
                    },
                    data:{
                        id:id
                    }
                }
            ).done(function(content){
                _this.currentFileHandle.title=name;
                _this.view.clear();
                var reader = new Reader();
                reader.unmarshal(_this.view, content);
                _this.view.getCommandStack().markSaveLocation();
                _this.view.centerDocument();
            });
        };


        $("#leftTabStrip .editor").click();
        if(name){
            openByIdCallback(name);
        }
        else {
            new FileOpen(this.currentFileHandle).show(openByIdCallback);
        }
    },


    fileDelete: function(id, successCallback)
    {
        if(this.loggedIn!==true){
            this.loginFirstMessage();
            return;
        }

        $.ajax({
                url: conf.backend.file.del,
                method: "POST",
                xhrFields: {
                    withCredentials: true
                },
                data:{
                    id:id
                }
            }
        ).done(function(){
            successCallback();
        });
    },

    autoLogin:function()
    {
        var _this = this;
        $.ajax({
            url:conf.backend.isLoggedIn,
            xhrFields: {
                withCredentials: true
             },
            success:function(data){
                _this.setLoginStatus(data==="true");
            },
            error:function(){
                _this.setLoginStatus(false);
            }
        });
    },

    loginFirstMessage:function()
    {
        $("#appLogin").addClass("shake");
        window.setTimeout(function(){
            $("#appLogin").removeClass("shake");
        },500);
        $.bootstrapGrowl("You must first sign in to use this functionality", {
            type: 'danger',
            align: 'center',
            width: 'auto',
            allow_dismiss: false
        });
    },

    setLoginStatus:function(isLoggedIn)
    {
        var _this = this;
        this.loggedIn = isLoggedIn;
        if (this.loggedIn) {
            $(".notLoggedIn").removeClass("notLoggedIn");
            $("#editorgroup_login").hide();
            $("#editorgroup_fileoperations").show();
        }
        else{
            $(".notLoggedIn").addClass("notLoggedIn");
            $("#editorgroup_login").show();
            $("#editorgroup_fileoperations").hide();
        }

        this.filePane.render();

        var id = this.localStorage["pane"];
        if(!id){
            id = this.getParam("pane");
        }
        console.log(id);
        if(id){
            this.localStorage.removeItem("pane");
            window.setTimeout(function(){
                $("#"+id+" a").click();
                var json = this.localStorage["json"];
                _this.localStorage.removeItem("json");
                if(json){
                    window.setTimeout(function(){
                        _this.fileNew(json);
                    },200);
                }
            },100);
        }
    }
});

;
ConnectionRouter = draw2d.layout.connection.InteractiveManhattanConnectionRouter.extend({
    NAME: "ConnectionRouter",

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function ()
    {
        this._super();

        this.setBridgeRadius(4);
        this.setVertexRadius(3);
    },

    onInstall: function(conn)
    {
        this._super.apply(this,arguments);
        conn.installEditPolicy(new ConnectionSelectionFeedbackPolicy());
    },

    /**
     * @method
     * Set the radius of the vertex circle.
     *
     * @param {Number} radius
     */
    setVertexRadius: function(radius)
    {
        this.vertexRadius=radius;

        return this;
    },

    /**
     * @method
     * Set the radius or span of the bridge. A bridge will be drawn if two connections are crossing and didn't have any
     * common port.
     *
     * @param {Number} radius
     */
    setBridgeRadius: function(radius)
    {
        this.bridgeRadius=radius;
        this.bridge_LR = [" r", 0.5, -0.5, radius-(radius/2), -(radius-radius/4), radius, -radius,radius+(radius/2), -(radius-radius/4), radius*2, "0 "].join(" ");
        this.bridge_RL = [" r", -0.5, -0.5, -(radius-(radius/2)), -(radius-radius/4), -radius, -radius,-(radius+(radius/2)), -(radius-radius/4), -radius*2, "0 "].join(" ");

        return this;
    },

    /**
     * @inheritdoc
     */
    x_paint: function(conn)
    {
        var _this = this;
        // get the intersections to the other connections
        //
        var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
        var intersectionsDESC= intersectionsASC.clone().reverse();

        var intersectionForCalc = intersectionsASC;

        // add a ArrayList of all added vertex nodes to the connection
        //
        if(typeof conn.vertexNodes!=="undefined" && conn.vertexNodes!==null){
            conn.vertexNodes.remove();
        }
        conn.vertexNodes = conn.canvas.paper.set();

        // ATTENTION: we cast all x/y coordinates to integer and add 0.5 to avoid subpixel rendering of
        //            the connection. The 1px or 2px lines look much clearer than before.
        //
        var ps = conn.getVertices();
        var p = ps.get(0);
        var path = [ "M", p.x, " ", p.y];

        var oldP = p;
        var bridgeWidth =  this.bridgeRadius;
        var bridgeCode  = null;

        var calc = function(ii, interP) {
            if (draw2d.shape.basic.Line.hit(5, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {
                // It is a vertex node..
                //
                if(conn.sharingPorts(interP.other)){
                    var other = interP.other;
                    var otherZ = other.getZOrder();
                    var connZ = conn.getZOrder();
                    if(connZ<otherZ){
                        var vertexNode=conn.canvas.paper.ellipse(interP.x,interP.y, _this.vertexRadius, _this.vertexRadius).attr({fill:conn.lineColor.hash()});
                        conn.vertexNodes.push(vertexNode);
                    }
                }
                // ..or a bridge. We draw only horizontal bridges. Just a design decision
                //
                else if ((p.y|0) === (interP.y|0)) {
                    path.push(" L", (interP.x - bridgeWidth), " ", interP.y);
                    path.push(bridgeCode);
                }
            }
        };

        for (var i = 1; i < ps.getSize(); i++) {
            p = ps.get(i);

            // line goes from right->left.
            if (oldP.x > p.x) {
                intersectionForCalc=intersectionsDESC;
                bridgeCode  = this.bridge_RL;
                bridgeWidth = -this.bridgeRadius;
            }
            // line goes from left->right
            else{
                intersectionForCalc=intersectionsASC;
                bridgeCode  = this.bridge_LR;
                bridgeWidth = this.bridgeRadius;
            }

            // bridge   => the connections didn't have a common port
            // vertex => the connections did have a common source or target port
            //
            intersectionForCalc.each(calc);

            path.push(" L", p.x, " ", p.y);
            oldP = p;
        }
        conn.svgPathString = path.join("");
    }
});
;
ConnectionSelectionFeedbackPolicy = draw2d.policy.line.OrthogonalSelectionFeedbackPolicy.extend({

    NAME: "ConnectionSelectionFeedbackPolicy",

    /**
     * @constructor
     * Creates a new Router object.
     *
     */
    init: function ()
    {
        this._super();
    },



    onRightMouseDown: function(conn, x, y, shiftKey, ctrlKey)
    {
        var segment = conn.hitSegment(x,y);

        if(segment===null){
            return;
        }

        // standard menu entry "split". It is always possible to split a connection
        //
        var items = { };

        // add/remove of connection segments is only possible in the edit mode
        //
        if(conn.getCanvas().isSimulationRunning()===false){
            items.split= {name: draw2d.Configuration.i18n.menu.addSegment};

            // "remove" a segment isn't always possible. depends from the router algorithm
            //
            if(conn.getRouter().canRemoveSegmentAt(conn, segment.index)){
                items.remove= {name: draw2d.Configuration.i18n.menu.deleteSegment};
            }
        }

        // add a probe label is always possible
        //
        var probeFigure = conn.getProbeFigure();
        if(probeFigure===null) {
            items.probe = {name: "Add Probe"};
        }
        else{
            items.unprobe = {name: "Remove Probe"};
        }

        $.contextMenu({
            selector: 'body',
            events:
            {
                hide: function(){ $.contextMenu( 'destroy' ); }
            },
            callback: $.proxy(function(key, options)
            {
                var originalVertices, newVertices ;

                switch(key){
                    case "remove":
                        // deep copy of the vertices of the connection for the command stack to avoid side effects
                        originalVertices = conn.getVertices().clone(true);
                        this.removeSegment(conn, segment.index);
                        newVertices = conn.getVertices().clone(true);
                        conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                        break;

                    case "split":
                        // deep copy of the vertices of the connection for the command stack to avoid side effects
                        originalVertices = conn.getVertices().clone(true);
                        this.splitSegment(conn, segment.index, x, y);
                        newVertices = conn.getVertices().clone(true);
                        conn.getCanvas().getCommandStack().execute(new draw2d.command.CommandReplaceVertices(conn, originalVertices, newVertices));
                        break;

                    case "probe":
                        var text = prompt("Probe Signal Label");
                        if(text) {
                            var label = new ProbeFigure({text: text, stroke: 0, x: -20, y: -40});
                            var locator = new draw2d.layout.locator.ManhattanMidpointLocator();
                            label.installEditor(new draw2d.ui.LabelInplaceEditor());
                            conn.add(label, locator);
                        }
                        break;

                    case "unprobe":
                        conn.remove(conn.getProbeFigure());
                        break;
                    default:
                        break;
                }
            },this),
            x:x,
            y:y,
            items: items
        });
    }
});


;
var DropInterceptorPolicy = draw2d.policy.canvas.DropInterceptorPolicy.extend({

    NAME : "draw2d.policy.canvas.DropInterceptorPolicy",

    /**
     * @constructor
     *
     */
    init: function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
    },


    /**
     * @method
     * Called if the user want connect a port with any kind draw2d.Figure.<br>
     * Return a non <b>null</b> value if the interceptor accept the connect event.<br>
     * <br>
     * It is possible to delegate the drop event to another figure if the policy
     * returns another figure. This is usefull if a figure want to accept a port
     * drop event and delegates this drop event to another port.<br>
     *
     *
     * @param {draw2d.Figure} connectInquirer the figure who wants connect
     * @param {draw2d.Figure} connectIntent the potential connect target
     *
     * @return {draw2d.Figure} the calculated connect intent or <b>null</b> if the interceptor uses the veto right
     */
    delegateTarget: function(connectInquirer, connectIntent)
    {
        // a composite accept any kind of figures exceptional ports
        //
        if(!(connectInquirer instanceof draw2d.Port) && connectIntent instanceof draw2d.shape.composite.StrongComposite){
            return connectIntent;
        }

        // Ports accepts only Ports as DropTarget
        //
        if(!(connectIntent instanceof draw2d.Port) || !(connectInquirer instanceof draw2d.Port)){
            return null;
        }

        // consider the max possible connections for this port
        //
        if(connectIntent.getConnections().getSize() >= connectIntent.getMaxFanOut()){
            return null;
        }

        // It is not allowed to connect two output ports
        if (connectInquirer instanceof draw2d.OutputPort && connectIntent instanceof draw2d.OutputPort) {
            return null;
        }

        // It is not allowed to connect two input ports
        if (connectInquirer instanceof draw2d.InputPort && connectIntent instanceof draw2d.InputPort) {
            return null;
        }

        // It is not possible to create a loop back connection at the moment.
        // Reason: no connection router implemented for this case
        if((connectInquirer instanceof draw2d.Port) && (connectIntent instanceof draw2d.Port)){
        //    if(connectInquirer === connectIntent){
         //       return null;
           // }
        }

        // redirect the dragEnter handling to the hybrid port
        //
        if((connectInquirer instanceof draw2d.Port) && (connectIntent instanceof draw2d.shape.node.Hub)) {
            return connectIntent.getHybridPort(0);
        }

        // return the connectTarget determined by the framework or delegate it to another
        // figure.
        return connectIntent;
    }

});

;
var EditEditPolicy = draw2d.policy.canvas.BoundingboxSelectionPolicy.extend({


    init:function()
    {
      this._super();
      this.mouseMoveProxy = $.proxy(this._onMouseMoveCallback, this);
      this.configIcon=null;
    },

    /**
     * @method
     * Called by the canvas if the user click on a figure.
     *
     * @param {draw2d.Figure} the figure under the click event. Can be null
     * @param {Number} mouseX the x coordinate of the mouse during the click event
     * @param {Number} mouseY the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 3.0.0
     */
    onClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
        // we only foreward the click-event to the MarkerFigure hich the user can show hide per
        // default
        // lt in the edit mode as well.
        if(figure instanceof MarkerFigure){
            this._super(figure, mouseX, mouseY, shiftKey, ctrlKey);
        }
    },

    onInstall:function(canvas)
    {
        this._super(canvas);
        var _this = this;

        // provide configuration menu if the mouse is close to a shape
        //
        canvas.on("mousemove", this.mouseMoveProxy);
    },


    onUninstall:function(canvas)
    {
        this._super(canvas);

        canvas.off(this.mouseMoveProxy);
    },


    onMouseUp: function(canvas, x,y, shiftKey, ctrlKey)
    {
        if(shiftKey ===true && this.mouseDownElement===null){
            var rx = Math.min(x, this.x);
            var ry = Math.min(y, this.y);
            var rh = Math.abs(y-this.y);
            var rw = Math.abs(x-this.x);
            var raftFigure = new Raft();
            raftFigure.attr({
                x:rx,
                y:ry,
                width:rw,
                height:rh,
                color:"#1c9bab"
            });
            canvas.add(raftFigure);
            this.boundingBoxFigure1.setCanvas(null);
            this.boundingBoxFigure1 = null;
            this.boundingBoxFigure2.setCanvas(null);
            this.boundingBoxFigure2 = null;
        }
        else{
            this._super(canvas, x, y, shiftKey, ctrlKey);
        }
    },

    _onMouseMoveCallback:function(emitter, event)
    {
        // there is no benefit to show decorations during Drag&Drop of an shape
        //
        if(this.mouseMovedDuringMouseDown===true){
            if(this.configIcon!==null) {
                this.configIcon.remove();
                this.configIcon = null;
            }
            return;
        }

        var hit = null;
        var _this = this;

        emitter.getFigures().each(function(index, figure){
            if(figure.hitTest(event.x,event.y, 30)){
                hit = figure;
                return false;
            }
        });

        if(hit!==null && hit.getParameterSettings().length>0){
            var pos = hit.getBoundingBox().getTopLeft();
            pos = emitter.fromCanvasToDocumentCoordinate(pos.x, pos.y);
            pos.y -=30;

            if(_this.configIcon===null) {
                _this.configIcon = $("<div class='ion-gear-a' id='configMenuIcon'></div>");
                $("body").append(_this.configIcon);
              //  FigureConfigDialog.hide();
                _this.configIcon.on("click",function(){
                    FigureConfigDialog.show(hit, pos);
                    _this.configFigure = hit;
                    if(_this.configIcon!==null) {
                        _this.configIcon.remove();
                        _this.configIcon = null;
                    }
                });
            }
            _this.configIcon.css({top: pos.y, left: pos.x, position:'absolute'});
        }
        else{
            if(_this.configIcon!==null) {
                var x=_this.configIcon;
                _this.configIcon = null;
                x.fadeOut(500, function(){ x.remove(); });
            }
        }
    }
});
;
/*jshint sub:true*/


/**
 * 
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 * 
 * @author Andreas Herz
 */

var Files = Class.extend(
{

    /**
     * @constructor
     * 
     * @param {String} canvasId the id of the DOM element to use as paint container
     */
    init : function(app)
    {
        this.app = app;
        this.render();
    },

    render: function()
    {
        var _this = this;
        if(this.app.loggedIn!==true){
            return;
        }

        $.ajax({
            url:conf.backend.file.list ,
            xhrFields: {
                withCredentials: true
            },
            success:function(response) {
                var files = response.files;
                // sort the result
                // Directories are always on top
                //
                files.sort(function (a, b) {
                    if (a.type === b.type) {
                        if (a.id.toLowerCase() < b.id.toLowerCase())
                            return -1;
                        if (a.id.toLowerCase() > b.id.toLowerCase())
                            return 1;
                        return 0;
                    }
                    return 1;
                });

                var compiled = Hogan.compile(
                    '{{#files}}' +
                    '<div class="col-lg-3 col-md-4 col-xs-6 thumb">'+
                    '  <span class="ion-ios-close-outline deleteIcon"  data-toggle="confirmation"  data-id="{{id}}"></span>'+
                    '  <a class="thumbnail" data-id="{{id}}">'+
                    '    <img class="img-responsive" src="'+conf.backend.file.image+'?id={{id}}" data-id="{{id}}">'+
                    '    <h4 data-name="{{name}}">{{name}}</h4>'+
                    '  </a>'+
                    '</div>'+
                    '{{/files}}'
                );


                var output = compiled.render({
                    files: files
                });

                $("#files .container > .row").html(
                '<div class="col-lg-3 col-md-4 col-xs-6 thumbAdd">'+
                '    <div class="img-responsive ion-ios-plus-outline"></div>'+
                '    <h4>New File</h4>'+
                '</div>');

                $("#files .container > .row").append($(output));

                $("#files .container .deleteIcon").on("click", function(){
                    var $el = $(this);
                    var name =  $el.data("id");
                    app.fileDelete(name,function(){
                        var parent = $el.parent();
                        parent.hide('slow', function(){ parent.remove(); });
                    });
                });

                $("[data-toggle='confirmation']").popConfirm({
                    title: "Delete File?",
                    content: "",
                    placement: "bottom" // (top, right, bottom, left)
                });


                $("#files .container .thumbnail h4").on("click", function() {
                    var $el = $(this);
                    var name = $el.data("name");
                    var $replaceWith = $('<input type="input" class="filenameInplaceEdit" value="' + name + '" />');
                    $el.hide();
                    $el.after($replaceWith);
                    $replaceWith.focus();

                    var fire = function () {
                        var newName = $replaceWith.val();
                        if (newName !== "") {
                            // get the value and post them here
                            $.ajax({
                                    url: conf.backend.file.rename,
                                    method: "POST",
                                    xhrFields: { withCredentials: true},
                                    data:{
                                        from:name+conf.fileSuffix,
                                        to:newName+conf.fileSuffix
                                    }
                                }
                            ).done(function(){
                                $replaceWith.remove();
                                $el.html(newName);
                                $el.show();
                                $el.data("name", newName);
                                $(".thumb [data-id='"+name+conf.fileSuffix+"']").data("id",newName+conf.fileSuffix);
                            });

                        }
                        else {
                            // get the value and post them here
                            $replaceWith.remove();
                            $el.show();
                        }
                    };
                    $replaceWith.blur(fire);
                    $replaceWith.keypress(function (e) {
                        if (e.which === 13) {
                            fire();
                        }
                    });
                });

                $("#files .container .thumbnail img").on("click", function(){
                    var $el = $(this);
                    var name =  $el.data("id");
                    app.fileOpen(name);
                });

                $("#files .thumbAdd").on("click", function(){
                    new FileNew(_this.app).show();
                });
            }
        });
    }
});

;
/*jshint sub:true*/


/**
 * 
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 * 
 * @author Andreas Herz
 */

var Palette = Class.extend(
{

    /**
     * @constructor
     * 
     * @param {String} canvasId the id of the DOM element to use as paint container
     */
    init : function(app)
    {
        var _this = this;

        var $grid = $("#paletteElements");

        $.getJSON(conf.shapes.url+ "index.json", function(data) {

            data.forEach(function (element){
                element.basename = element.name.split("_").pop();
            });

            var tmpl = $.templates("#shapeTemplate");
            var html = tmpl.render({
                shapesUrl :conf.shapes.url,
                shapes: data
            });

            $("#paletteElements").html(html);

            // Advanced filtering
            $('#filter').on('keyup change', function (event) {
                if(event.keyCode===27){
                    $('#filter').val("");
                }
                var val = this.value.toLowerCase();
                $grid.shuffle('shuffle', function ($el, shuffle) {
                    var text = $.trim($el.data("name")).toLowerCase();
                    if(text==="_request_")
                        return true;
                    return text.indexOf(val) !== -1;
                });
            });


            // Create the jQuery-Draggable for the palette -> canvas drag&drop interaction
            //
            $(".draw2d_droppable").draggable({
                appendTo:"body",
              //  stack:"body",
              //  zIndex: 27000,
                helper:"clone",
                drag: function(event, ui){
                    event = app.view._getEvent(event);
                    var pos = app.view.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    app.view.onDrag(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
                },
                stop: function(e, ui){
                },
                start: function(e, ui){
                    $(ui.helper).addClass("shadow");
                }
            });

            $('.draw2d_droppable')
                .on('mouseover', function(){
                    $(this).parent().addClass('glowBorder');
                })
                .on('mouseout', function(){
                $(this).parent().removeClass('glowBorder');
            });

            // add the "+" to the palette
            //
            var requestUrl =conf.issues.url+'?title=Request for shape&body='+encodeURIComponent("Please add the description of the shape you request.\nWe try to implement it as soon as possible...");
            $("#paletteElements").append(
             '  <div data-name="_request_" class="mix col-md-6 pallette_item">'+
             '  <a href="'+requestUrl+'" target="_blank">'+
             '    <div class="request">'+
             '       <div class="icon ion-ios-plus-outline"></div>'+
             '       <div >Request a Shape</div>'+
             '   </div>'+
             '   </a>  '+
             '  </div>');

        //    $("#paletteElements").append("<div>++</div>");
        });

    }
});

;
var ProbeWindow = Class.extend({

    init:function(canvas)
    {
        var _this = this;
        this.canvas = canvas;

        // sync the setting in the local storage
        this.stick = Locstor.get("stickWindow",false);
        this.watch("stick",function(id, oldval, newval){
            Locstor.set("stickWindow",newval);
            return newval;
        });

        // the tick function if the oszi goes from left to the right
        //
        this.rightShiftTick= $.proxy(function(entry){
            entry.data.unshift(entry.probe.getValue()?5:0);
            entry.vis
                .selectAll("path")
                .attr("transform", "translate(-" + _this.xScale(1) + ")")
                .attr("d", entry.path)
                .transition()
                .ease("linear")
                .duration(this.intervalTime )
                .attr("transform", "translate(0)");
                entry.data.pop();
        },this);

        this.leftShiftTick= $.proxy(function(entry){
            entry.data.push(entry.probe.getValue()?5:0);
            entry.vis
                .selectAll("path")
                .attr("transform", "translate(" + _this.xScale(1) + ")")
                .attr("d", entry.path)
                .transition()
                .ease("linear")
                .duration(this.intervalTime )
                .attr("transform", "translate(0)");
            entry.data.shift();
        },this);


        $(window).resize(function(){
            _this.resize();
        });

        this.canvas.on("probe:add", function(emitter, event){
           _this.addProbe(event.figure);
        });
        this.canvas.on("probe:remove", function(emitter, event){
            _this.removeProbe(event.figure);
        });

        this.channelBufferSize = 500;
        this.channelHeight =20;
        this.channelWidth = $("#probe_window").width();
        this.probes = [];

        this.xScale = d3.scale.linear().domain([0, this.channelBufferSize - 1]).range([0,this.channelWidth]);
        this.yScale = d3.scale.linear().domain([0, 5]).range([this.channelHeight, 0]);

        $("#probe_window_stick").on("click",function(){
            _this.stick = !_this.stick;
            if(_this.stick){
                $("#probe_window_stick").addClass("ion-ios-eye").removeClass("ion-ios-eye-outline");
            }
            else{
                $("#probe_window_stick").addClass("ion-ios-eye-outline").removeClass("ion-ios-eye");
            }

            // try to hide the window if the simulation isn't running.
            if(!_this.stick && !_this.canvas.isSimulationRunning()){
                _this.hide();
            }
        });

        if(this.stick){
            $("#probe_window_stick").addClass("ion-ios-eye").removeClass("ion-ios-eye-outline");
            this.show(true);
        }
    },

    show:function(force)
    {
        if(!force && this.stick){
            return;
        }

        var _this = this;
        var probes = [];

        this.resize();

        // get all probes from the canvas and add them to the window
        //
        this.canvas.getLines().each(function(i,line){
            var probe = line.getProbeFigure();
            if(probe!==null){
                probes.push(probe);
            }
        });


        // sort the probes by the "index" attribute
        //
        probes.sort(function(a,b){
            return a.index - b.index;
        });

        $("#probeSortable").remove();
        $("#probe_window").append('<ul id="probeSortable"></ul>');


        probes.forEach(function(probe){
            _this.addProbe(probe);
        });

        if(probes.length>0)$("#probe_hint").hide(); else $("#probe_hint").show();
        $("#probe_window").show().animate({height:'200px'},300);
        $("#draw2dCanvasWrapper").animate({bottom:'200px'},300);
        $( "#probeSortable" ).sortable({
            update: function( event, ui ) {
                var lis =  $( "#probeSortable li" );
                $.each(lis,function(index, li){
                    probeEntry = _this.probes.find(function(entry){
                        return entry.probe.id===li.attributes.id.value;
                    });
                    probeEntry.probe.setIndex(index);
                });
            }
        });

    },

    hide:function()
    {
        if(this.stick){
            return;
        }

        $("#probe_window").animate({height:'0'},300);
        $("#draw2dCanvasWrapper").animate({bottom:'0'},300, function(){
            $("#probeSortable").remove();
        });
    },

    resize:function()
    {
        var _this = this;
        this.channelWidth = $("#probe_window").width();
        this.xScale = d3.scale.linear().domain([0, this.channelBufferSize - 1]).range([0,this.channelWidth]);
        this.yScale = d3.scale.linear().domain([0, 5]).range([this.channelHeight, 0]);

        this.probes.forEach(function(entry){
            entry.svg.attr("width", _this.channelWidth);
        });
    },

    tick:function( intervalTime)
    {
       // test fiddle for D3 line chart
       // http://jsfiddle.net/Q5Jag/1859/

       this.intervalTime = intervalTime;
       this.probes.forEach(this.leftShiftTick);
    },

    removeProbe: function(probeFigure)
    {
        this.probes = $.grep(this.probes, function(entry) {
            return entry.probe != probeFigure;
        });
        $("#"+probeFigure.id).remove();
        this.resize();
        if(this.probes.length>0)$("#probe_hint").fadeOut(); else $("#probe_hint").fadeIn();
    },

    addProbe: function(probeFigure)
    {
        probeFigure.setIndex(this.probes.length);

        var _this = this;

        var data = d3.range(this.channelBufferSize).map(function(){return 0;});

        var li    = d3.select("#probeSortable").append("li").attr("id",probeFigure.id).attr("index",probeFigure.getIndex());
        var label = li.append("div").text(probeFigure.getText());

        var svg   = li.append("svg:svg").attr("width", this.channelWidth).attr("height", this.channelHeight);
        var vis   = svg.append("svg:g");
        var path  = d3.svg
            .line()
            .x(function(d, i) {
                return _this.xScale(i);
            })
            .y(function(d, i) {
                return _this.yScale(d);
            })
            .interpolate("step-before");

        vis.selectAll("path")
            .data([data])
            .enter()
            .append("svg:path")
            .attr("d", path)
            .attr('stroke', 'green')
            .attr('stroke-width', 1)
            .attr('fill', 'none');

        this.probes.push({
            data: data,
            svg:svg,
            vis : vis,
            path:path,
            probe:probeFigure
        });
        if(this.probes.length>0)$("#probe_hint").hide(); else $("#probe_hint").show();

        // direct edit of the label
        //
        var $label = $(label[0]);
        $label.click(function() {

            var $replaceWith = $('<input type="input" class="inplaceEdit" value="'+probeFigure.getText()+'" />');
            $label.hide();
            $label.after($replaceWith);
            $replaceWith.focus();

            var fire=function() {
                var newLabel = $replaceWith.val();
                if(newLabel!=="") {
                    $replaceWith.remove();
                    $label.html(newLabel);
                    $label.show();
                    probeFigure.setText(newLabel);
                }
                else{
                    // get the value and post them here
                    $replaceWith.remove();
                    $label.show();
                }
            };
            $replaceWith.blur(fire);
            $replaceWith.keypress(function (e) {
                if (e.which == 13) {
                    fire();
                }
            });
        });
        this.resize();
    }
});

;
var SimulationEditPolicy = draw2d.policy.canvas.ReadOnlySelectionPolicy.extend({


    init:function()
    {
        this._super();
        this.mouseDownElement=null;
    },


    onInstall:function(canvas)
    {
        canvas.getFigures().each(function(index , shape){
            shape.onStart();
        });
    },


    onUninstall:function(canvas)
    {
        canvas.getFigures().each(function(index , shape){
            shape.onStop();
        });
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function(canvas, x, y, shiftKey, ctrlKey) {
       var figure = canvas.getBestFigure(x, y);

        // may the figure is assigned to a composite. In this case the composite can
        // override the event receiver
        while (figure !== null) {
            var delegated = figure.getSelectionAdapter()();
            if (delegated === figure) {
                break;
            }
            figure = delegated;
        }

        // ignore ports since version 6.1.0. This is handled by the ConnectionCreatePolicy
        //
        if (figure instanceof draw2d.Port) {
            return;// silently
        }

        this.mouseDownElement = figure;

        if (this.mouseDownElement !== null) {
            this.mouseDownElement.fireEvent("mousedown", {x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey});
        }
    },

    /**
     * @method
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseUp: function(canvas, x,y, shiftKey, ctrlKey)
    {
        if(this.mouseDownElement!==null){
            this.mouseDownElement.fireEvent("mouseup", {x:x, y:y, shiftKey:shiftKey, ctrlKey:ctrlKey});
        }
        this.mouseDownElement = null;
    },


    /**
     * @method
     * Called by the canvas if the user click on a figure.
     *
     * @param {draw2d.Figure} the figure under the click event. Can be null
     * @param {Number} mouseX the x coordinate of the mouse during the click event
     * @param {Number} mouseY the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 3.0.0
     */
    onClick: function(figure, mouseX, mouseY, shiftKey, ctrlKey)
    {
        if(figure!==null){
            figure.fireEvent("click", {
                figure:figure,
                x:mouseX,
                y:mouseY,
                relX: mouseX-figure.getAbsoluteX(),
                relY: mouseY-figure.getAbsoluteY(),
                shiftKey:shiftKey,
                ctrlKey:ctrlKey});

            figure.onClick();
        }
    }
});
;
/*jshint sub:true*/
/*jshint evil:true */


/**
 * 
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 * 
 * @author Andreas Herz
 */


var View = draw2d.Canvas.extend({

    init:function(app, id)
    {
        var _this = this;

        this._super(id, 6000,6000);

        this.probeWindow = new ProbeWindow(this);

        this.simulate = false;
        this.animationFrameFunc = $.proxy(this._calculate,this);


        this.timerBase = 10; // ms calculate every 10ms all elements

        this.setScrollArea("#draw2dCanvasWrapper");

        // register this class as event listener for the canvas
        // CommandStack. This is required to update the state of
        // the Undo/Redo Buttons.
        //
        this.getCommandStack().addEventListener(this);

        var router = new ConnectionRouter();
        router.abortRoutingOnFirstVertexNode=false;
        var createConnection=function(sourcePort, targetPort){
            var c = new Connection({
                color:"#000000",
                router: router,
                stroke:1.5,
                radius:2
            });
            if(sourcePort) {
                c.setSource(sourcePort);
                c.setTarget(targetPort);
            }
            return c;
        };

        this.installEditPolicy( new DropInterceptorPolicy());

        // install a Connection create policy which matches to a "circuit like"
        // connections
        //
        this.connectionPolicy = new draw2d.policy.connection.ComposedConnectionCreatePolicy(
                [
                    // create a connection via Drag&Drop of ports
                    //
                    new draw2d.policy.connection.DragConnectionCreatePolicy({
                        createConnection:createConnection
                    }),
                    // or via click and point
                    //
                    new draw2d.policy.connection.OrthogonalConnectionCreatePolicy({
                        createConnection:createConnection
                    })
                ]);
        this.installEditPolicy(this.connectionPolicy);

        // show the ports of the elements only if the mouse cursor is close to the shape.
        //
        this.coronaFeedback = new draw2d.policy.canvas.CoronaDecorationPolicy({diameterToBeVisible:50});
        this.installEditPolicy(this.coronaFeedback);

        // nice grid decoration for the canvas paint area
        //
        this.grid =  new draw2d.policy.canvas.ShowGridEditPolicy(20);
        this.installEditPolicy( this.grid);

        // add some SnapTo policy for better shape/figure alignment
        //
        this.installEditPolicy( new draw2d.policy.canvas.SnapToGeometryEditPolicy());
        this.installEditPolicy( new draw2d.policy.canvas.SnapToCenterEditPolicy());
        this.installEditPolicy( new draw2d.policy.canvas.SnapToInBetweenEditPolicy());

        this.installEditPolicy(new EditEditPolicy());

        // Enable Copy&Past for figures
        //
        Mousetrap.bind(['ctrl+c', 'command+c'], $.proxy(function (event) {
            var primarySelection = this.getSelection().getPrimary();
            if(primarySelection!==null){
                this.clippboardFigure = primarySelection.clone({excludePorts:true});
                this.clippboardFigure.translate(5,5);
            }
            return false;
        },this));
        Mousetrap.bind(['ctrl+v', 'command+v'], $.proxy(function (event) {
            if(this.clippboardFigure!==null){
                var cloneToAdd = this.clippboardFigure.clone({excludePorts:true});
                var command = new draw2d.command.CommandAdd(this, cloneToAdd, cloneToAdd.getPosition());
                this.getCommandStack().execute(command);
                this.setCurrentSelection(cloneToAdd);
            }
            return false;
        },this));


        Mousetrap.bind(['left'],function (event) {
            var diff = _this.getZoom()<0.5?0.5:1;
            _this.getSelection().each(function(i,f){f.translate(-diff,0);});
            return false;
        });
        Mousetrap.bind(['up'],function (event) {
            var diff = _this.getZoom()<0.5?0.5:1;
            _this.getSelection().each(function(i,f){f.translate(0,-diff);});
            return false;
        });
        Mousetrap.bind(['right'],function (event) {
            var diff = _this.getZoom()<0.5?0.5:1;
            _this.getSelection().each(function(i,f){f.translate(diff,0);});
            return false;
        });
        Mousetrap.bind(['down'],function (event) {
            var diff = _this.getZoom()<0.5?0.5:1;
            _this.getSelection().each(function(i,f){f.translate(0,diff);});
            return false;
        });


        var setZoom = function(newZoom){
            var bb = _this.getBoundingBox().getCenter();
            var c = $("#draw2dCanvasWrapper");
            _this.setZoom(newZoom);
            _this.scrollTo((bb.y/newZoom- c.height()/2), (bb.x/newZoom- c.width()/2));
        };

        //  ZoomIn Button and the callbacks
        //
        $("#canvas_zoom_in").on("click",function(){
            setZoom(_this.getZoom()*1.2);
        });

        // OneToOne Button
        //
        $("#canvas_zoom_normal").on("click",function(){
            setZoom(1.0);
        });

        //ZoomOut Button and the callback
        //
        $("#canvas_zoom_out").on("click",function(){
            setZoom(_this.getZoom()*0.8);
        });


        $(".toolbar").delegate("#editDelete:not(.disabled)","click", function(){
            var selection = _this.getSelection();
            _this.getCommandStack().startTransaction(draw2d.Configuration.i18n.command.deleteShape);
            selection.each(function(index, figure){

                // Don't delete the conection if the source or target node part of the
                // selection. In this case the nodes deletes all connections by itself.
                //
                if(figure instanceof draw2d.Connection){
                    if(selection.contains(figure.getSource().getRoot()) || selection.contains(figure.getTarget().getRoot())){
                       return;
                    }
                }

                var cmd = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE));
                if(cmd!==null){
                    _this.getCommandStack().execute(cmd);
                }
            });
            // execute all single commands at once.
            _this.getCommandStack().commitTransaction();
        });


        $(".toolbar").delegate("#editUndo:not(.disabled)","click", function(){
            _this.getCommandStack().undo();
        });

        $(".toolbar").delegate("#editRedo:not(.disabled)","click", function(){
            _this.getCommandStack().redo();
        });

        $("#simulationStartStop").on("click", function(){
            _this.simulationToggle();
        });


        // Register a Selection listener for the state hnadling
        // of the Delete Button
        //
        this.on("select", function(emitter, event){
            if(event.figure===null ) {
                $("#editDelete").addClass("disabled");
            }
            else{
                $("#editDelete").removeClass("disabled");
            }
        });

        this.on("contextmenu", function(emitter, event){
            var figure = _this.getBestFigure(event.x, event.y);

            // a connectionprovides its own context menu
            //
            if(figure instanceof draw2d.Connection){
                return;
            }
            if(figure instanceof ProbeFigure){
                return;
            }

            if(figure!==null){
                var x = event.x;
                var y = event.y;

                var pathToFile   = "https://github.com/freegroup/draw2d_js.shapes/blob/master/"+ eval(figure.NAME+".github");
                var pathToMD     = conf.shapes.url+figure.NAME+".md";
                var pathToCustom = conf.shapes.url+figure.NAME+".custom";
                var pathToDesign = conf.designer.url+"#file="+ figure.NAME+".shape";
                var items = {
                    "label":   {name: "Add Label"        , icon :"x ion-ios-pricetag-outline"     },
                    "delete":  {name: "Delete"           , icon :"x ion-ios-close-outline"        },
                    "sep1":    "---------",
                    "design":  {name: "Open Designer"    , icon :"x ion-ios-compose-outline"      },
                    "bug":     {name: "Report Bug"       , icon :"x ion-social-github"            },
                    "help":    {name: "Help"             , icon :"x ion-ios-information-outline"  }
                };

                // if the designer is running on the Raspi
                //
                if(conf.designer.url===null){
                     items = {
                        "label":   {name: "Add Label"        , icon :"x ion-ios-pricetag-outline"     },
                        "delete":  {name: "Delete"           , icon :"x ion-ios-close-outline"        },
                        "sep1":    "---------",
                        "help":    {name: "Help"             , icon :"x ion-ios-information-outline"  }
                     };
                }

                $.contextMenu({
                    selector: 'body',
                    events:
                    {
                        hide:function(){ $.contextMenu( 'destroy' ); }
                    },
                    callback: $.proxy(function(key, options)
                    {
                        switch(key){
                            case "code":
                                $.get(pathToCustom, function(content){
                                    new CodeDialog().show(content);
                                });
                                break;
                            case "label":
                                var text = prompt("Label");
                                if(text) {
                                    var label = new draw2d.shape.basic.Label({text:text, stroke:0, x:-20, y:-40});
                                    var locator = new draw2d.layout.locator.SmartDraggableLocator();
                                    label.installEditor(new draw2d.ui.LabelInplaceEditor());
                                    figure.add(label,locator);
                                }
                                break;
                            case "design":
                                window.open(pathToDesign);
                                break;
                            case "help":
                                $.get(pathToMD, function(content){
                                    new MarkdownDialog().show(content);
                                });
                                break;
                            case "bug":
                                var createUrl = conf.issues.url+"?title=Error in shape '"+figure.NAME+"'&body="+encodeURIComponent("I found a bug in "+figure.NAME+".\n\nError Description here...\n\n\nLinks to the code;\n[GitHub link]("+pathToFile+")\n[Designer Link]("+pathToDesign+")\n");
                                window.open(createUrl);
                                break;
                            case "delete":
                                var cmd = new draw2d.command.CommandDelete(figure);
                                _this.getCommandStack().execute(cmd);
                                break;
                            default:
                                break;
                        }

                    },this),
                    x:x,
                    y:y,
                    items:items

                });
            }
        });

        // hide the figure configuration dialog if the user clicks inside the canvas
        //
        this.on("click", function(){
            $("#figureConfigDialog").hide();
        });

        this.slider= $('#simulationBaseTimer')
            .slider({
                id:"simulationBaseTimerSlider"
            })
            .on("slide",function(event){
                // min = 50     => 100ms
                // norm= 100    => 10ms ticks
                // max = 500    =>  2ms ticks
                //
                // To map between the different intervals
                // [A, B] --> [a, b]
                // use this formula
                // (val - A)*(b-a)/(B-A) + a

                if(event.value<100){
                    _this.timerBase = parseInt(100-((event.value-50)*(100-10)/(100-50)+10));
                }
                else{
                    _this.timerBase = parseInt(11-((event.value-100)*(10-2)/(500-100)+2));
                }
            });

        // force focus for the searchbox in the object palette
        //
        /*
        setInterval(function(){
            // force only the focus if the editor tab pane is visible
            if(!$("#editor").hasClass("active")){
                return;
            }

            // fore only the focus if the "filter" input element the one and only visible
            // input field
            //
            if($("input:visible").length>1){
                return;
            }

            document.getElementById("filter").focus();
        },10);
        */


        socket.on('disconnect',function(){
            $(".raspiConnection").fadeIn();
        });

        socket.on('connect',function(){
            $(".raspiConnection").fadeOut();
        });
    },

    isSimulationRunning:function()
    {
        return this.simulate;
    },

    /**
     * @method
     * Clear the canvas and stop the simulation. Be ready for the next clean circuit
     * load. Start from the beginning
     */
    clear: function()
    {
        this.simulationStop();

        this._super();

        this.centerDocument();
    },

    /**
     * Disable snapTo GRID if we have select more than one element
     * @param figure
     * @param pos
     */
    snapToHelper : function(figure, pos)
    {
        if(this.getSelection().getSize()>1){
            return pos;
        }
        return this._super(figure, pos);
    },

    /**
     * @method
     * Called if the user drop the droppedDomNode onto the canvas.<br>
     * <br>
     * Draw2D use the jQuery draggable/droppable lib. Please inspect
     * http://jqueryui.com/demos/droppable/ for further information.
     *
     * @param {HTMLElement} droppedDomNode The dropped DOM element.
     * @param {Number} x the x coordinate of the drop
     * @param {Number} y the y coordinate of the drop
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onDrop : function(droppedDomNode, x, y, shiftKey, ctrlKey)
    {
        var type = $(droppedDomNode).data("shape");
        var figure = eval("new "+type+"();"); // jshint ignore:line
        // create a command for the undo/redo support
        var command = new draw2d.command.CommandAdd(this, figure, x, y);
        this.getCommandStack().execute(command);
    },

    simulationToggle:function()
    {
        if(this.simulate===true){
            this.simulationStop();
        } else {
            this.simulationStart();
        }
    },

    simulationStart:function()
    {
        if(this.simulate===true){
            return; // silently
        }

        this.simulate=true;

        this.installEditPolicy(new SimulationEditPolicy());
        this.uninstallEditPolicy(this.connectionPolicy);
        this.uninstallEditPolicy(this.coronaFeedback);
        this.commonPorts.each(function(i,p){
            p.setVisible(false);
        });

        this._calculate();

        $("#simulationStartStop").addClass("pause");
        $("#simulationStartStop").removeClass("play");
        $(".simulationBase" ).fadeIn( "slow" );
        $("#paletteElementsOverlay" ).fadeIn( "fast" );
        $("#paletteElementsOverlay").height($("#paletteElements").height());
        this.slider.slider("setValue",100);

        this.probeWindow.show();
    },

    simulationStop:function()
    {
        this.simulate = false;
        this.commonPorts.each(function(i,p){
            p.setVisible(true);
        });
        this.installEditPolicy(new EditEditPolicy());
        this.installEditPolicy(this.connectionPolicy);
        this.installEditPolicy(this.coronaFeedback);

        $("#simulationStartStop").addClass("play");
        $("#simulationStartStop").removeClass("pause");
        $(".simulationBase" ).fadeOut( "slow" );
        $("#paletteElementsOverlay" ).fadeOut( "fast" );
        this.probeWindow.hide();
    },

    _calculate:function()
    {
        // call the "calculate" method if given to calculate the output-port values
        //
        this.getFigures().each(function(i,figure){
            figure.calculate();
        });

        // transport the value from oututPort to inputPort
        //
        this.getLines().each(function(i,line){
            var outPort = line.getSource();
            var inPort  = line.getTarget();
            inPort.setValue(outPort.getValue());
            line.setColor(outPort.getValue()?conf.color.high:conf.color.low);
        });

        if(this.simulate===true){
       //     setImmediate(this.animationFrameFunc);
            setTimeout(this.animationFrameFunc,this.timerBase);
        }

        this.probeWindow.tick(this.timerBase);
    },

    /**
     * @method
     * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
     * can be used to identify the type of event which has occurred.
     *
     * @template
     *
     * @param {draw2d.command.CommandStackEvent} event
     **/
    stackChanged:function(event)
    {
        $("#editUndo").addClass("disabled");
        $("#editRedo").addClass("disabled");

        if(event.getStack().canUndo()) {
            $("#editUndo").removeClass("disabled");
        }

        if(event.getStack().canRedo()) {
            $("#editRedo").removeClass("disabled");
        }

    },

    getBoundingBox: function()
    {
        var xCoords = [];
        var yCoords = [];
        this.getFigures().each(function(i,f){
           var b = f.getBoundingBox();
            xCoords.push(b.x, b.x+b.w);
            yCoords.push(b.y, b.y+b.h);
        });
        var minX   = Math.min.apply(Math, xCoords);
        var minY   = Math.min.apply(Math, yCoords);
        var width  = Math.max(100,Math.max.apply(Math, xCoords)-minX);
        var height = Math.max(100,Math.max.apply(Math, yCoords)-minY);

        return new draw2d.geo.Rectangle(minX,minY,width,height);
    },


    centerDocument:function()
    {
        var bb=null;
        var c = $("#draw2dCanvasWrapper");
        if(this.getFigures().getSize()>0){
            // get the bounding box of the document and translate the complete document
            // into the center of the canvas. Scroll to the top left corner after them
            //
            bb = this.getBoundingBox();
            this.scrollTo(bb.y- c.height()/2,bb.x- c.width()/2);
        }
        else{
            bb={
                x:this.getWidth()/2,
                y:this.getHeight()/2
            };
            this.scrollTo(bb.y- c.height()/2,bb.x- c.width()/2);

        }
    },

    /**
     * @method
     * Transforms a document coordinate to canvas coordinate.
     *
     * @param {Number} x the x coordinate relative to the window
     * @param {Number} y the y coordinate relative to the window
     *
     * @returns {draw2d.geo.Point} The coordinate in relation to the canvas [0,0] position
     */
    fromDocumentToCanvasCoordinate: function(x, y)
    {
        return new draw2d.geo.Point(
            (x - this.getAbsoluteX())*this.zoomFactor,
            (y - this.getAbsoluteY())*this.zoomFactor);
    },

    /**
     * @method
     * Transforms a canvas coordinate to document coordinate.
     *
     * @param {Number} x the x coordinate in the canvas
     * @param {Number} y the y coordinate in the canvas
     *
     * @returns {draw2d.geo.Point} the coordinate in relation to the document [0,0] position
     */
    fromCanvasToDocumentCoordinate: function(x,y)
    {
        return new draw2d.geo.Point(
            ((x*(1/this.zoomFactor)) + this.getAbsoluteX()),
            ((y*(1/this.zoomFactor)) + this.getAbsoluteY()));
    }
});

;
/*jshint sub:true*/
/*jshint evil:true */


/**
 * 
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 * 
 * @author Andreas Herz
 */


var Widget = draw2d.Canvas.extend({

    init:function()
    {
        var _this = this;
        var id = "draw2dCanvas";
        this._super(id, 6000,6000);
        this.simulate = false;
        this.animationFrameFunc = $.proxy(this._calculate,this);

        // nice grid decoration for the canvas paint area
        //
        this.grid =  new draw2d.policy.canvas.ShowGridEditPolicy(20);
        this.installEditPolicy( this.grid);

        var circuit = this.getParam("circuit");
       $.getJSON(circuit, function (json) {
            var reader = new Reader();
            reader.unmarshal(widget, json);

            _this.shiftDocument();
            _this.simulationStart();
        });

    },

    simulationStart:function()
    {
        this.simulate=true;

        this.installEditPolicy(new SimulationEditPolicy());
        this.commonPorts.each(function(i,p){
            p.setVisible(false);
        });
        requestAnimationFrame(this.animationFrameFunc);
    },

    _calculate:function()
    {
        // call the "calculate" method if given to calculate the output-port values
        //
        this.getFigures().each(function(i,figure){
            figure.calculate();
        });

        // transport the value from outputPort to inputPort
        //
        this.getLines().each(function(i,line){
            var outPort = line.getSource();
            var inPort  = line.getTarget();
            inPort.setValue(outPort.getValue());
            line.setColor(outPort.getValue()?"#C21B7A":"#0078F2");
        });

        if(this.simulate===true){
            requestAnimationFrame(this.animationFrameFunc);
        }
    },


    getParam: function( name )
    {
        name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
        var regexS = "[\\?&]"+name+"=([^&#]*)";
        var regex = new RegExp( regexS );
        var results = regex.exec( window.location.href );

        // the param isn'T part of the normal URL pattern...
        //
        if( results === null ) {
            // maybe it is part in the hash.
            //
            regexS = "[\\#]"+name+"=([^&#]*)";
            regex = new RegExp( regexS );
            results = regex.exec( window.location.hash );
            if( results === null ) {
                return null;
            }
        }

        return results[1];
    },

    getBoundingBox: function(){
        var xCoords = [];
        var yCoords = [];
        this.getFigures().each(function(i,f){
            var b = f.getBoundingBox();
            xCoords.push(b.x, b.x+b.w);
            yCoords.push(b.y, b.y+b.h);
        });
        var minX   = Math.min.apply(Math, xCoords);
        var minY   = Math.min.apply(Math, yCoords);
        var width  = Math.max(10,Math.max.apply(Math, xCoords)-minX);
        var height = Math.max(10,Math.max.apply(Math, yCoords)-minY);

        return new draw2d.geo.Rectangle(minX,minY,width,height);
    },

    shiftDocument:function()
    {
        // get the bounding box of the document and translate the complete document
        // into the center of the canvas. Scroll to the top left corner after them
        //
        var bb = this.getBoundingBox();

        var dx = -bb.x;
        var dy = -bb.y;

        this.getFigures().each(function(i,f){
            f.translate(dx,dy);
        });
        this.getLines().each(function(i,f){
            f.translate(dx,dy);
        });
    }


});

;
var About = Class.extend(
{

    init:function(){
     },

	show:function(){
		
	    this.splash = $(
	            '<div id="splash">'+
	            '<div>Draw2D Designer<br>'+
	            '@VERSION@'+
	            '</div>'+
	            '</div>');
	    this.splash.hide();
	    $("body").append(this.splash);
	    
	    this.splash.fadeIn("fast");
	},
	
	hide: function()
	{
        this.splash.delay(2500)
        .fadeOut( "slow", $.proxy(function() {
            this.splash.remove();
        },this));
	}

      
});  
;
var CodeDialog = Class.extend(
    {

        init:function(){
        },

        show:function(js){
            $('#codePreviewDialog .prettyprint').text(js);
            $('#codePreviewDialog .prettyprint').removeClass("prettyprinted");
            prettyPrint();
            $('#codePreviewDialog').modal('show');
        }
});
;
var FigureConfigDialog = (function () {

    //"private" variables
    var currentFigure =null;

    //"public" stuff
    return {
        show: function(figure, pos)
        {
            currentFigure=figure;

            var settings = figure.getParameterSettings().slice(0);
            $.each(settings,function(i,el){
                el.value = currentFigure.attr("userData."+el.name);
            });
            var compiled = Handlebars.compile(
                '  <div class="header">Object Configuration</div>   '+
                '  {{#each settings}}               '+
                '      {{#ifCond property.type "===" "blocid"}}      '+
                '         <div class="form-group">'+
                '           <label for="figure_property_{{name}}">{{label}}</label>'+
                '           <select class="form-control" id="figure_property_{{name}}" data-name="{{name}}" size="4"> '+
                '               <option value="-unconnected-">no device selected</option>   '+
                '               {{#each ../blocs_push}}               '+
                '               <option data-name="{{name}}" value="{{blocId}}">Push {{blocNr}}</option>   '+
                '               {{/each}}               '+
                '           </select>   '+
                '         </div>                  '+
                      '{{else}}                   '+
                '         <div class="form-group">'+
                '           <label for="figure_property_{{name}}">{{label}}</label>'+
                '           <input type="text" class="form-control" id="figure_property_{{name}}" data-name="{{name}}" value="{{value}}" placeholder="{{label}}">'+
                '         </div>                  '+
                    '{{/ifCond}}                  '+
                '  {{/each}}                  '+
                '<button class="submit">Ok</button> '
            );
            var output = compiled({
                settings: settings,
                blocs_push : hardware.bloc.connected().filter(function(val){return val.blocType==="Push";})
            });

            $("#figureConfigDialog").html(output);
            $("#figureConfigDialog").show().css({top: pos.y, left: pos.x, position:'absolute'});
            $("#figureConfigDialog input, #figureConfigDialog select").focus();

            $("#figureConfigDialog input").keypress(function(e) {
                if(e.which == 13) {
                    FigureConfigDialog.hide();
                }
            });
            $("#figureConfigDialog .submit").on("click",function(){FigureConfigDialog.hide();});

            $.each(settings,function(index, setting){
                var figureValue = currentFigure.attr("userData." + setting.name);
                $('#figureConfigDialog select[data-name="'+setting.name+'"] option[value="'+figureValue+'"]').attr('selected','selected');

            });
        },

        hide: function()
        {
            if(currentFigure!==null) {
                $("#figureConfigDialog input, #figureConfigDialog select").each(function (i, element) {
                    element = $(element);
                    var value = element.val();
                    var name = element.data("name");

                    currentFigure.attr("userData." + name, value);
                });
            }
            $("#figureConfigDialog").hide();
            $("#figureConfigDialog").html("");

            currentFigure=null;
        }
    };
})();

;
var FileNew = Class.extend({

    /**
     * @constructor
     *
     */
    init:function(app){
        this.app = app;
    },

    /**
     * @method
     *
     * Open the file picker and load the selected file.<br>
     *
     * @param {Function} successCallback callback method if the user select a file and the content is loaded
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    show: function()
    {
        var _this = this;
        $("#githubNewFileDialog .githubFileName").val("NewDocument");
        $('#githubNewFileDialog').on('shown.bs.modal', function () {
            $(this).find('input:first').focus();
        });
        $("#githubNewFileDialog").modal("show");

        $("#githubNewFileDialog .okButton").on("click", function () {
             var name = $("#githubNewFileDialog .githubFileName").val();
            $('#githubNewFileDialog').modal('hide');
            _this.app.fileNew();
            _this.app.currentFileHandle.title = name;
        });
    }
});
;
FileOpen = Class.extend({

    /**
     * @constructor
     *
     */
    init:function(fileHandle)
    {
        this.currentFileHandle=fileHandle;
    },

    /**
     * @method
     *
     * Open the file picker and load the selected file.<br>
     *
     * @param {Function} successCallback callback method if the user select a file and the content is loaded
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    show: function(successCallback)
    {
        $('#githubFileSelectDialog').modal('show');

        this.fetchPathContent( successCallback);
    },

    fetchPathContent: function( successCallback )
    {
        var _this = this;

        $.ajax({
                url:conf.backend.file.list ,
                xhrFields: {
                    withCredentials: true
                },
                success:function(response) {
                    var files = response.files;
                    // sort the reusult
                    // Directories are always on top
                    //
                    files.sort(function (a, b) {
                        if (a.type === b.type) {
                            if (a.name.toLowerCase() < b.name.toLowerCase())
                                return -1;
                            if (a.name.toLowerCase() > b.name.toLowerCase())
                                return 1;
                            return 0;
                        }
                        if (a.type === "dir") {
                            return -1;
                        }
                        return 1;
                    });

                    var compiled = Hogan.compile(
                        '         {{#files}}' +
                        '           <a href="#" data-draw2d="{{draw2d}}" class="list-group-item githubPath text-nowrap" data-name="{{name}}" data-id="{{id}}">' +
                        '              <span class="fa fa-file-o"></span>' +
                        '              {{{name}}}' +
                        '           </a>' +
                        '         {{/files}}'
                    );
                    var output = compiled.render({
                        files: files,
                        draw2d: function () {
                            return this.id.endsWith(conf.fileSuffix);
                        }
                    });

                    $("#githubFileSelectDialog .githubNavigation").html($(output));
                    $("#githubFileSelectDialog .githubNavigation").scrollTop(0);


                    $('.githubPath[data-draw2d="true"]').on("click", function () {
                        var id   = $(this).data("id");
                        $('#githubFileSelectDialog').modal('hide');
                        successCallback(id);
                    });
                }
        });
    }
});
;
var FileSave = Class.extend({

    /**
     * @constructor
     *
     */
    init:function(fileHandler){
        this.currentFileHandle = fileHandler;
    },

    /**
     * @method
     *
     * Open the file picker and load the selected file.<br>
     *
     * @param {Function} successCallback callback method if the user select a file and the content is loaded
     * @param {Function} errorCallback method to call if any error happens
     *
     * @since 4.0.0
     */
    show: function(canvas, successCallback)
    {
        var _this = this;

        $("#githubSaveFileDialog .githubFileName").val(_this.currentFileHandle.title);

        $('#githubSaveFileDialog').on('shown.bs.modal', function () {
            $(this).find('input:first').focus();
        });
        $("#githubSaveFileDialog").modal("show");

        // Button: Commit to GitHub
        //
        $("#githubSaveFileDialog .okButton").on("click", function () {

            canvas.setCurrentSelection(null);
            new draw2d.io.png.Writer().marshal(canvas, function (imageDataUrl){
                var writer = new draw2d.io.json.Writer();
                writer.marshal(canvas, function (json, base64) {
                    var name = $("#githubSaveFileDialog .githubFileName").val();
                    $.ajax({
                            url: conf.backend.file.save,
                            method: "POST",
                            xhrFields: {
                                withCredentials: true
                            },
                            data:{
                                id:name,
                                content:JSON.stringify({draw2d:json, image:imageDataUrl}, undefined, 2)
                            }
                        }
                    ).done(function(){
                        _this.currentFileHandle.title=name;
                        $('#githubSaveFileDialog').modal('hide');
                        successCallback();
                    });

                });
            }, canvas.getBoundingBox().scale(10, 10));
        });

    }

});
;
var MarkdownDialog = Class.extend(
    {

        init:function()
        {
            this.defaults = {
                html:         true,         // Enable HTML tags in source
                xhtmlOut:     false,        // Use '/' to close single tags (<br />)
                breaks:       false,        // Convert '\n' in paragraphs into <br>
                langPrefix:   'language-',  // CSS language prefix for fenced blocks
                linkify:      true,         // autoconvert URL-like texts to links
                linkTarget:   '_blank',     // set target to open link in
                typographer:  true          // Enable smartypants and other sweet transforms
            };
        },

        show:function(markdown)
        {
            var markdownParser = new Remarkable('full', this.defaults);
            $('#markdownDialog .html').html(markdownParser.render(markdown));
            $('#markdownDialog').modal('show');
        }
});
;
/*!

 <!-- Complete usage -->
 <button class=" popconfirm_full" data-toggle='confirmation' id="important_action">Full featured</button>


 // (example jquery click event)
 $('#important_action').on("click",function() {
     alert('You clicked, and valided this button !');
 });

 // Full featured example
 $("[data-toggle='confirmation']").popConfirm({
     title: "Delete File?",
     content: "",
     placement: "bottom" // (top, right, bottom, left)
 });


 */

(function ($) {
    'use strict';
    /*global jQuery, $*/
    /*jslint nomen: true, evil: true*/
    $.fn.extend({
        popConfirm: function (options) {
            var defaults = {
                    title: 'Confirmation',
                    content: 'Are you really sure ?',
                    placement: 'right',
                    container: 'body',
                    yesBtn: 'Yes',
                    noBtn: 'No'
                },
                last = null;
            options = $.extend(defaults, options);
            return this.each(function () {
                var self = $(this),
                    arrayActions = [],
                    arrayDelegatedActions = [],
                    eventToConfirm,
                    optName,
                    optValue,
                    i,
                    elmType,
                    code,
                    form;

                // Load data-* attriutes
                for (optName in options) {
                    if (options.hasOwnProperty(optName)) {
                        optValue = $(this).attr('data-confirm-' + optName);
                        if (optValue) {
                            options[optName] = optValue;
                        }
                    }
                }

                // If there are jquery click events
                if (jQuery._data(this, "events") && jQuery._data(this, "events").click) {

                    // Save all click handlers
                    for (i = 0; i < jQuery._data(this, "events").click.length; i = i + 1) {
                        arrayActions.push(jQuery._data(this, "events").click[i].handler);
                    }

                    // unbind it to prevent it firing
                    $(self).unbind("click");
                }

                // If there are jquery delegated click events
                if (self.data('remote') && jQuery._data(document, "events") && jQuery._data(document, "events").click) {

                    // Save all delegated click handlers that apply
                    for (i = 0; i < jQuery._data(document, "events").click.length; i = i + 1) {
                        elmType = self[0].tagName.toLowerCase();
                        if (jQuery._data(document, "events").click[i].selector && jQuery._data(document, "events").click[i].selector.indexOf(elmType + "[data-remote]") !== -1) {
                            arrayDelegatedActions.push(jQuery._data(document, "events").click[i].handler);
                        }
                    }
                }

                // If there are hard onclick attribute
                if (self.attr('onclick')) {
                    // Extracting the onclick code to evaluate and bring it into a closure
                    code = self.attr('onclick');
                    arrayActions.push(function () {
                        eval(code);
                    });
                    $(self).prop("onclick", null);
                }

                // If there are href link defined
                if (!self.data('remote') && self.attr('href')) {
                    // Assume there is a href attribute to redirect to
                    arrayActions.push(function () {
                        window.location.href = self.attr('href');
                    });
                }

                // If the button is a submit one
                if (self.attr('type') && self.attr('type') === 'submit') {
                    // Get the form related to this button then store submiting in closure
                    form = $(this).parents('form:first');
                    arrayActions.push(function () {
                        // Add the button name / value if specified
                        if(typeof self.attr('name') !== "undefined") {
                            $('<input type="hidden">').attr('name', self.attr('name')).attr('value', self.attr('value')).appendTo(form);
                        }
                        form.submit();
                    });
                }

                self.popover({
                    trigger: 'manual',
                    title: options.title,
                    html: true,
                    placement: options.placement,
                    container: options.container,
                    //Avoid using multiline strings, no support in older browsers.
                    content: options.content + '<p class="button-group" style="margin-top: 10px; text-align: center;"><button type="button" class="btn btn-small confirm-dialog-btn-abort">' + options.noBtn + '</button> <button type="button" class="btn btn-small btn-danger confirm-dialog-btn-confirm">' + options.yesBtn + '</button></p>'
                }).click(function (e) {
                    if (last && last !== self) {
                        last.popover('hide').removeClass('popconfirm-active');
                    }
                    last = self;
                });

                $(document).on('click', function () {
                    if (last) {
                        last.popover('hide').removeClass('popconfirm-active');
                    }
                });

                self.bind('click', function (e) {
                    eventToConfirm = e;

                    e.preventDefault();
                    e.stopPropagation();

                    $('.popconfirm-active').not(self).popover('hide').removeClass('popconfirm-active');
                    self.popover('show').addClass('popconfirm-active');

                    $(document).find('.popover .confirm-dialog-btn-confirm').one('click', function (e) {
                        for (i = 0; i < arrayActions.length; i = i + 1) {
                            arrayActions[i].apply(self);
                        }

                        for (i = 0; i < arrayDelegatedActions.length; i = i + 1) {
                            arrayDelegatedActions[i].apply(self, [eventToConfirm.originalEvent]);
                        }

                        self.popover('hide').removeClass('popconfirm-active');
                    });
                    $(document).find('.popover .confirm-dialog-btn-abord').bind('click', function (e) {
                        self.popover('hide').removeClass('popconfirm-active');
                    });
                });
            });
        }
    });
}(jQuery));
;
/*jshint evil:true */

var Connection = draw2d.Connection.extend({

    NAME: "Connection",

    init : function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
    },

    setCanvas: function(canvas)
    {
        this._super(canvas);

        // remove any decoration if exists
        if(canvas===null){

        }
    },

    getValue:function()
    {
        return this.getSource().getValue();
    },

    /**
     * Return the ProbeFigure if the connection has any or NULL
     *
     * @return {ProbeFigure}
     */
    getProbeFigure:function()
    {
        var entry= this.children.find(function(entry){
               return entry.figure instanceof ProbeFigure;
             });
        return (entry!==null)?entry.figure:null;
    },

    disconnect: function()
    {
       this._super();

       // remove some decorations of the router.
       // This is a design flaw. the router creates the decoration and the connection must remove them :-/
       // Unfortunately the Router didn't have a callback when a connection is removed from the canvas.
       //
        if(typeof this.vertexNodes!=="undefined" && this.vertexNodes!==null){
            this.vertexNodes.remove();
            delete this.vertexNodes;
        }
    },

    add: function(figure)
    {
        this._super.apply(this,arguments);

        if(figure instanceof ProbeFigure && this.canvas !==null){
            this.canvas.fireEvent("probe:add", {figure:figure});
        }
    },


    remove: function(figure)
    {
        this._super.apply(this,arguments);

        if(figure instanceof ProbeFigure && this.canvas !==null){
            this.canvas.fireEvent("probe:remove", {figure:figure});
        }
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes : function()
    {
        var memento = this._super();

        // add all decorations to the memento
        //
        memento.labels = [];
        this.children.each(function(i,e){
            var labelJSON = e.figure.getPersistentAttributes();
            labelJSON.locator=e.locator.NAME;
            memento.labels.push(labelJSON);
        });

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes : function(memento)
    {
        // patch the router from some legacy data
        //
        memento.router ="ConnectionRouter";

        this._super(memento);

        // remove all decorations created in the constructor of this element
        //
        this.resetChildren();

        // and add all children of the JSON document.
        //
        if(memento.labels) {
            $.each(memento.labels, $.proxy(function (i, json) {
                // create the figure stored in the JSON
                var figure = eval("new " + json.type + "()");

                // apply all attributes
                figure.setPersistentAttributes(json);

                // instantiate the locator
                var locator = eval("new " + json.locator + "()");

                // add the new figure as child to this figure
                this.add(figure, locator);
            }, this));
        }
    }

});

;

var DecoratedInputPort = draw2d.InputPort.extend({

    NAME: "DecoratedInputPort",

    init : function(attr, setter, getter)
    {
        this.hasChanged = false;

        this._super(attr, setter, getter);
        
        this.decoration = new MarkerFigure();

        this.add(this.decoration, new draw2d.layout.locator.LeftLocator({margin:8}));

        this.on("disconnect",function(emitter, event){
            this.decoration.setVisible(this.getConnections().getSize()===0);

            // default value of a not connected port is always HIGH
            //
            if(this.getConnections().getSize()===0){
                this.setValue(true);
            }
        }.bind(this));

        this.on("connect",function(emitter, event){
            this.decoration.setVisible(false);
        }.bind(this));

        this.on("dragend",function(emitter, event){
            this.decoration.setVisible(this.getConnections().getSize()===0);
        }.bind(this));
        
        this.on("drag",function(emitter, event){
            this.decoration.setVisible(false);
        }.bind(this));

        // a port can have a value. Usefull for workflow engines or circuit diagrams
        this.setValue(true);
    },

    useDefaultValue:function()
    {
        this.decoration.setStick(true);
    },

    setValue:function(value)
    {
        this.hasChanged = this.value !==value;
        this._super(value);
    },

    hasChangedValue: function()
    {
        return this.hasChanged;
    },

    hasRisingEdge: function()
    {
        return this.hasChangedValue()&& this.getValue();
    },

    hasFallingEdge: function()
    {
        return this.hasChangedValue() && !this.getValue();
    }
});

;
/**
 * The markerFigure is the left hand side annotation for a DecoratedPort.
 *
 * It contains two children
 *
 * StateAFigure: if the mouse hover and the figure isn't permanent visible
 * StateBFigure: either the mouse is over or the user pressed the checkbox to stick the figure on the port
 *
 * This kind of decoration is usefull for defualt values on workflwos enginges or circuit diagrams
 *
 */
var MarkerFigure = draw2d.shape.layout.VerticalLayout.extend({

    NAME : "MarkerFigure",

    init : function(attr, setter, getter)
    {
        var _this = this;

        this.isMouseOver = false;        // indicator if the mouse is over the element
        this.stick       = false;        // indicator if the stateBFigure should always be visible
        this.defaultValue= true;         // current selected default value for the decoration

        this._super($.extend({
              stroke:0
        },attr),
        setter, 
        getter);


        // figure if the decoration is not permanent visible (sticky note)
        this.add(this.stateA = new MarkerStateAFigure({text:"X"}));
        // figure if the decoration permanent visible
        this.add(this.stateB = new MarkerStateBFigure({text:"X"}));


        this.on("mouseenter",function(emitter, event){
            _this.onMouseOver(true);
        });

        this.on("mouseleave",function(emitter, event){
            _this.onMouseOver(false);
        });

        this.on("click",function(emitter, event){
            if (_this.isVisible() === false) {
                return;//silently
            }

            if(_this.stateB.getStickTickFigure().getBoundingBox().hitTest(event.x, event.y) === true){
                _this.setStick(!_this.getStick());
            }
            else if(_this.stateB.getLabelFigure().getBoundingBox().hitTest(event.x, event.y) === true){
                $.contextMenu({
                    selector: 'body',
                    trigger:"left",
                    events:
                    {
                        hide:function(){ $.contextMenu( 'destroy' ); }
                    },
                    callback: $.proxy(function(key, options)
                    {
                        // propagate the default value to the port
                        //
                        switch(key){
                            case "high":
                                _this.setDefaultValue(true);
                                _this.setStick(true);
                                break;
                            case "low":
                                _this.setDefaultValue(false);
                                _this.setStick(true);
                                break;
                            default:
                                break;
                        }

                    },this),
                    x:event.x,
                    y:event.y,
                    items:{
                        "high": {name: "High"},
                        "low":  {name: "Low" }
                    }
                });

            }
        });

        this.setDefaultValue(true);
        this.onMouseOver(false);
    },

    onMouseOver: function(flag)
    {
        this.isMouseOver = flag;

        if(this.visible===false){
            return; // silently
        }

        if(this.stick===true) {
            this.stateA.setVisible(false);
            this.stateB.setVisible(true);
        }
        else{
            this.stateA.setVisible(!this.isMouseOver);
            this.stateB.setVisible( this.isMouseOver);
        }

        return this;
    },


    setVisible: function(flag)
    {
        this._super(flag);

        // update the hover/stick state of the figure
        this.onMouseOver(this.isMouseOver);

        return this;
    },


    setStick:function(flag)
    {
        this.stick = flag;
        this.onMouseOver(this.isMouseOver);


        // the port has only a default value if the decoration is visible
        this.parent.setValue(flag?this.defaultValue:null);

        this.stateB.setTick(this.getStick());

        return this;
    },


    getStick:function()
    {
        return this.stick;
    },


    setText: function(text)
    {
        this.stateB.setText(text);

        return this;
    },

    setDefaultValue: function(value)
    {
        this.defaultValue = value;

        this.setText((this.defaultValue===true)?"High":"Low ");
        this.stateB.setTintColor((this.defaultValue===true)?conf.color.high:conf.color.low);

        // only propagate the value to the parent if the decoration permanent visible
        //
        if(this.stick===true){
            this.parent.setValue(this.defaultValue);
        }
    }
});

;
/**
 * This is only the mouseover reactive shape. A little bit smaller than the visible shape
 *
 * Or you can display this shape with opacity of 0.2 to indicate that this is a reactive area.
 */
var MarkerStateAFigure = draw2d.shape.basic.Label.extend({

    NAME : "MarkerStateAFigure",

    /**
     * @param attr
     */
    init : function(attr, setter, getter)
    {
        this._super($.extend({
            padding:{left:5, top:2, bottom:2, right:10},
            bgColor:null,
            stroke:1,
            color:null,
            fontColor:null,
            fontSize:8
        },attr), 
        setter, 
        getter);

        // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.
        // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.
        //
        // now this shape is "dead" for any mouse events and the parent must/can handle this.
        this.hitTest = function(){return false;};
    }

});
;
var MarkerStateBFigure = draw2d.shape.layout.HorizontalLayout.extend({

    NAME : "MarkerStateBFigure",

    /**
     * @param attr
     */
    init : function(attr, setter, getter)
    {
        this.tintColor = conf.color.low;

        this._super($.extend({
            bgColor:"#FFFFFF",
            stroke:1,
            color:conf.color.low,
            radius:2,
            padding:{left:3, top:2, bottom:0, right:8},
            gap:5
        },attr), 
        setter, 
        getter);

        this.stickTick = new draw2d.shape.basic.Circle({
            diameter:8,
            bgColor:"#f0f0f0",
            stroke:1,
            resizeable:false
        });
        this.add(this.stickTick);
        this.stickTick.hitTest = function(){return false;};
        this.stickTick.addCssClass("highlightOnHover");

        this.label = new draw2d.shape.basic.Label({
            text:attr.text,
            resizeable:false,
            stroke:0,
            padding:0,
            fontSize:8,
            fontColor:"#303030"
        });
        this.add(this.label);
        this.label.hitTest = function(){return false;};
        this.label.addCssClass("highlightOnHover");

        // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.
        // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.
        //
        // now this shape is "dead" for any mouse events and the parent must/can handle this.
        this.hitTest = function(){return false;};
    },

    setText: function(text)
    {
        this.label.setText(text);
    },

    setTintColor: function(color)
    {
        this.tintColor = color;
        this.attr({color:color});
        this.label.attr({fontColor:color});
    },

    setTick :function(flag)
    {
        this.stickTick.attr({bgColor:flag?this.tintColor:"#f0f0f0"});
    },

    getStickTickFigure:function()
    {
        return this.stickTick;
    },

    getLabelFigure:function()
    {
        return this.label;
    },

    /**
     * @method
     *
     *
     * @template
     **/
    repaint: function(attributes)
    {
        if(this.repaintBlocked===true || this.shape===null){
            return;
        }

        attributes= attributes || {};

        attributes.path = this.calculatePath();

        this._super(attributes);
    },


    /**
     * @method
     *
     * Override the default rendering of the HorizontalLayout, which is a simple
     * rectangle. We want an arrow.
     */
    createShapeElement : function()
    {
        return this.canvas.paper.path(this.calculatePath());
    },

    /**
     * stupid copy&paste the code from the Polygon shape...unfortunately the LayoutFigure isn't a polygon.
     *
     * @returns {string}
     */
    calculatePath: function()
    {
        var arrowLength=8;

        this.vertices   = new draw2d.util.ArrayList();

        var w  = this.width;
        var h  = this.height;
        var pos= this.getAbsolutePosition();
        var i  = 0;
        var length=0;
        this.vertices.add(new draw2d.geo.Point(pos.x,  pos.y)  );
        this.vertices.add(new draw2d.geo.Point(pos.x+w-arrowLength,pos.y)  );

        this.vertices.add(new draw2d.geo.Point(pos.x+w,pos.y+h/2));

        this.vertices.add(new draw2d.geo.Point(pos.x+w-arrowLength,pos.y+h));
        this.vertices.add(new draw2d.geo.Point(pos.x  ,pos.y+h));

        var radius = this.getRadius();
        var path = [];
        // hard corners
        //
        if(radius === 0){
            length = this.vertices.getSize();
            var p = this.vertices.get(0);
            path.push("M",p.x," ",p.y);
            for(i=1;i<length;i++){
                p = this.vertices.get(i);
                path.push("L", p.x, " ", p.y);
            }
            path.push("Z");
        }
        // soften/round corners
        //
        else{
            length = this.vertices.getSize();
            var start = this.vertices.first();
            var end   = this.vertices.last();
            if(start.equals(end)){
                length = length-1;
                end = this.vertices.get(length-1);
            }
            var begin   = draw2d.geo.Util.insetPoint(start,end, radius);
            path.push("M", begin.x, ",", begin.y);
            for( i=0 ;i<length;i++){
                start = this.vertices.get(i);
                end   = this.vertices.get((i+1)%length);
                modStart = draw2d.geo.Util.insetPoint(start,end, radius);
                modEnd   = draw2d.geo.Util.insetPoint(end,start,radius);
                path.push("Q",start.x,",",start.y," ", modStart.x, ", ", modStart.y);
                path.push("L", modEnd.x, ",", modEnd.y);
            }
        }
        return path.join("");
    }


});

;
var ProbeFigure = draw2d.shape.basic.Label.extend({

    NAME : "ProbeFigure",

    /**
     * @param attr
     */
    init : function(attr, setter, getter)
    {
        this._super($.extend({
                padding:{left:5, top:2, bottom:2, right:10},
                bgColor:"#FFFFFF",
                stroke:0,
                color:"#000000",
                fontSize:8
            },attr),
            setter,
            getter);

        // the sort index in the probe window
        //
        this.index = 0;
    },


    getValue:function()
    {
        return this.getParent().getValue();
    },

    getIndex: function()
    {
        return this.index;
    },

    setIndex: function( index)
    {
        this.index = index;

        return this;
    },


    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes : function()
    {
        var memento = this._super();

        memento.index = this.index;

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes : function(memento)
    {
        this._super(memento);

        if(typeof memento.index !=="undefined"){
            this.index = parseInt(memento.index);
        }
    }

});

;
/*jshint evil:true */


/**
 * The markerFigure is the left hand side annotation for a DecoratedPort.
 *
 * It contains two children
 *
 * StateAFigure: if the mouse hover and the figure isn't permanent visible
 * StateBFigure: either the mouse is over or the user pressed the checkbox to stick the figure on the port
 *
 * This kind of decoration is usefull for defualt values on workflwos enginges or circuit diagrams
 *
 */
var Raft = draw2d.shape.composite.Raft.extend({

    NAME : "Raft",

    init : function(attr, setter, getter)
    {
        this._super(attr, setter, getter);
    },

    calculate: function()
    {

    },

    onStart:function()
    {

    },

    onStop:function()
    {

    },

    toBack:function(figure)
    {
        if(this.canvas.getFigures().getSize()===1){
            return ; // silently
        }

        // unfortunately the shape goes behind the "canvas decoration" which could be the grid or dots.
        // this is sad and unwanted. In this case we select the first figure in th canvas and set the Raft behind of them
        // instead of "behind of ALL shapes"
        var first = this.canvas.getFigures().first();
        this._super(first);
    },

    getParameterSettings: function()
    {
        return [];
    },

    /**
     * @method
     * Return an objects with all important attributes for XML or JSON serialization
     *
     * @returns {Object}
     */
    getPersistentAttributes : function()
    {
        var memento = this._super();

        // add all decorations to the memento
        //
        memento.labels = [];
        this.children.each(function(i,e){
            var labelJSON = e.figure.getPersistentAttributes();
            labelJSON.locator=e.locator.NAME;
            memento.labels.push(labelJSON);
        });

        return memento;
    },

    /**
     * @method
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     * @returns
     */
    setPersistentAttributes : function(memento)
    {
        this._super(memento);

        // remove all decorations created in the constructor of this element
        //
        this.resetChildren();

        // and add all children of the JSON document.
        //
        $.each(memento.labels, $.proxy(function(i,json){
            // create the figure stored in the JSON
            var figure =  eval("new "+json.type+"()");

            // apply all attributes
            figure.attr(json);

            // instantiate the locator
            var locator =  eval("new "+json.locator+"()");

            // add the new figure as child to this figure
            this.add(figure, locator);
        },this));
    }

});

;
/**
 * Registry of all available devices (connected via RF24 adapter) and of the hub GPIO pins.
 * The hub could be an RaspberryPi or and Arduino.
 *
 * The "hub" is the receiver for the connected devices and expose its own
 * GPIO pins as well.
 *
 */
var hardware=(function(){
    var eventSubscriptions = {}; // event listener to the registry

    var values= {};
    var blocs = [];
    var socket= null;
    var fireEvent = function(event, args)
    {
        if (typeof eventSubscriptions[event] === 'undefined') {
            return;
        }

        var subscribers = eventSubscriptions[event];
        for (var i=0; i<subscribers.length; i++) {
            try{
                subscribers[i]( args);
            }
            catch(exc){
                console.log(exc);
                console.log(subscribers[i]);
            }
        }
    };

    return {
        /**
         * Init the listener for the socket.io events
         * Events could be
         *  - changes on the GPIO pins
         *  - new registered devices (blocs)
         *  - unregister of devices (blocs)
         *  - provides events of devices (blocs)
         *
         * @param s
         */
        init: function (s) {
            socket = s;
            socket.on("gpo:change", function (msg) {
                values[msg.pin] = !!parseInt(msg.value);
            });
            socket.on("bloc:value", function (msg) {
               values[msg.blocId] = !!parseInt(msg.value);
            });
            socket.on("bloc:register", function (msg) {
                blocs= blocs.filter(function(bloc) {
                    return bloc.blocId != msg.blocId;
                });
                blocs.push(msg);
                fireEvent("bloc:register",msg );
            });
            socket.on("bloc:unregister", function (msg) {
                blocs= blocs.filter(function(bloc) {
                    return bloc.blocId != msg.blocId;
                });
                fireEvent("bloc:unregister",msg );
            });

            // load all registered devices from the node.js server if any connected
            //
            socket.on('connect',function() {
                if (conf.backend.bloc.list !== null) {
                    $.ajax({url: conf.backend.bloc.list,method: "GET"})
                        .done(function (content) {
                            blocs = content;
                        });
                }
            });
        },
        gpio: {
            set: function (pin, value) {
                socket.emit('gpi:set', {
                    pin: pin,
                    value: value
                });
            },
            get: function (pin) {
                return values[pin];
            }
        },
        bloc: {
            set: function (blocId, value) {
                socket.emit('bloc:set', {
                    blocId: blocId,
                    value: value
                });
            },
            get: function (blocId) {
                return values[blocId];
            },
            connected: function () {
                return blocs;
            },

            isConnected: function(blocId){
                return $.grep(blocs, function(e){ return e.blocId == blocId; }).length>0;
            },

            /**
             * @method
             * Attach an event handler function to "bloc" based events
             *
             * possible events are:<br>
             * <ul>
             *   <li>bloc:register</li>
             *   <li>bloc:unregister</li>
             * </ul>
             *
             * @param {String}   event One or more space-separated event types
             * @param {Function} callback A function to execute when the event is triggered.
             *
             * @since 5.0.0
             */
            on: function(event, callback)
            {
                var events = event.split(" ");
                for(var i=0; i<events.length; i++){
                    if (typeof eventSubscriptions[events[i]] === 'undefined') {
                        eventSubscriptions[events[i]] = [];
                    }
                    eventSubscriptions[events[i]].push(callback);
                }
                return this;
            },

            /**
             * @method
             * The .off() method removes event handlers that were attached with {@link #on}.<br>
             * Calling .off() with no arguments removes all handlers attached to the registry.<br>
             *
             * @param {String|Function} eventOrFunction the event name of the registered function
             * @since 5.0.0
             */
            off: function( eventOrFunction)
            {
                if(typeof eventOrFunction ==="undefined"){
                    eventSubscriptions = {};
                }
                else if( typeof eventOrFunction === 'string'){
                    eventSubscriptions[eventOrFunction] = [];
                }
                else{
                    var check = function( callback ) { return callback !== eventOrFunction; };
                    for(var event in this.eventSubscriptions ){
                        eventSubscriptions[event] =$.grep(eventSubscriptions[event], check);
                    }
                }

                return this;
            }
        }
    };
})();

// deprecated
var raspi = hardware;


;


var Reader = draw2d.io.json.Reader.extend({

    init:function(){
        this._super();
    },

    unmarshal:function(view, fileData)
    {
        // new JSON format with draw2&image content
        if(fileData.draw2d){
            this._super(view, fileData.draw2d);
        }
        // native JSON format
        else{
            this._super(view, fileData);
        }
    },

    createFigureFromType:function(type)
    {
        // path object types from older versions of JSON
        if(type === "draw2d.Connection"){
            type = "Connection";
        }

        return this._super(type);
    }
});

;
// Handlebars isn't loaded if "brain" circuit is running within an widget
//
if(typeof Handlebars !=="undefined") {
    Handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {
        switch (operator) {
            case '==':
                return (v1 == v2) ? options.fn(this) : options.inverse(this);
            case '===':
                return (v1 === v2) ? options.fn(this) : options.inverse(this);
            case '!==':
                return (v1 !== v2) ? options.fn(this) : options.inverse(this);
            case '<':
                return (v1 < v2) ? options.fn(this) : options.inverse(this);
            case '<=':
                return (v1 <= v2) ? options.fn(this) : options.inverse(this);
            case '>':
                return (v1 > v2) ? options.fn(this) : options.inverse(this);
            case '>=':
                return (v1 >= v2) ? options.fn(this) : options.inverse(this);
            case '&&':
                return (v1 && v2) ? options.fn(this) : options.inverse(this);
            case '||':
                return (v1 || v2) ? options.fn(this) : options.inverse(this);
            default:
                return options.inverse(this);
        }
    });
}


/*
 * object.watch polyfill
 *
 * 2012-04-03
 *
 * By Eli Grey, http://eligrey.com
 * Public Domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */
// object.watch
if (!Object.prototype.watch) {
    Object.defineProperty(Object.prototype, "watch", {
        enumerable: false ,
        configurable: true,
        writable: false,
        value: function (prop, handler) {
            var
                oldval = this[prop],
                newval = oldval,
                getter = function () {
                    return newval;
                },
                setter = function (val) {
                    oldval = newval;
                    newval = handler.call(this, prop, oldval, val);
                    return newval;
                };

            if (delete this[prop]) { // can't watch constants
                Object.defineProperty(this, prop, {
                    get: getter,
                    set: setter,
                    enumerable: true,
                    configurable: true
                });
            }
        }
    });
}

// object.unwatch
if (!Object.prototype.unwatch) {
    Object.defineProperty(Object.prototype, "unwatch", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: function (prop) {
            var val = this[prop];
            delete this[prop]; // remove accessors
            this[prop] = val;
        }
    });
}